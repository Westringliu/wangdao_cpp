
<?xml version="1.0" encoding="utf-8" ?><?xml-stylesheet type="text/xsl" title="XSL Formatting" href="/static_files/markdown/rss.xsl" media="all" ?>
<rss version="2.0">
    <channel>
        <title>青萍之末的博客</title>
        <image>
            <link>http://blog.csdn.net</link>
            <url>http://static.blog.csdn.net/images/logo.gif</url>
        </image>
        <description>学无止境</description>
        <link>//blog.csdn.net/daaikuaichuan</link>
        <language>zh-cn</language>
        <generator>http://blog.csdn.net</generator>
        <ttl>5</ttl>
        <copyright><![CDATA[Copyright &copy; daaikuaichuan]]></copyright>
        <pubDate>2018/03/16 15:51:24</pubDate>
                    <item>
                                <title><![CDATA[[转]C++设计一个无法被继承且能正常使用的类]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79476758</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79476758</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/03/07 20:55:44</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4">首先，不能被继承的类，也就是它的子类继承它后不能正常的实例化。其实，如果能考虑到这里，就很简单了：子类需要实例化父类，将父类的构造函数设为private，子类就无法实例化了。再进一步，子类的析构函数需要调用父类的析构函数，所以将父类的析构函数设为private也能解决我们的问题。</font></p>

<p>  <font size="4">但是如果将父类的构造函数设为private，它自己就无法正常，它自己的对象没法正常的声明、实例化。将构造函数设为了private非常的像单例模式，促使我们想通过friend函数解决无法实例化的问题。</font></p>

<p>  <font size="4" color="red">一切难题都可以通过增加一个中间层去解决：</font></p>

<p>  <font size="4" color="green">要正常的使用该类，它的构造函数和析构函数必然是public访问权限。我们为它增加一个虚继承的父类，它是父类的friend(友元)，父类的构造函数是private。</font></p>

<pre class="prettyprint"><code class=" hljs java">class A;

class <span class="hljs-keyword">final</span>
{
    friend class A;
    <span class="hljs-keyword">final</span>(){}
};

class A : virtual <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span>
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-title">A</span>(){}
};

class B : <span class="hljs-keyword">public</span> A
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-title">B</span>(){}
};</code></pre>

<p>  <font size="4">class A 是final的friend，所以A可以调用final的构造函数。</font></p>

<p>  <font size="4">因为A虚继承了final，往后所有继承A的子类，都必须自己实例化final，以保证final在对象中的唯一性。</font></p>

<p>  <font size="4" color="blue">所以，B继承A后，需要自己调用虚继承的父类final的构造函数。显然，B不是final的友元，不能访问private中的构造函数。</font></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/03/07 20:55:44 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79476758">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79476758                    </div>
                    <div>
                        阅读：6                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[转]C++四种强制转换]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79476501</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79476501</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/03/07 20:36:47</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4" color="red">C++的四种强制类型转换，所以C++不是类型安全的。分别为：static_cast , dynamic_cast , const_cast , reinterpret_cast。</font> <br>
  <font size="4">为什么使用C风格的强制转换可以把想要的任何东西转换成合乎心意的类型。那为什么还需要一个新的C++类型的强制转换呢？新类型的强制转换可以提供更好的控制强制转换过程，允许控制各种不同种类的强制转换。 <br>
  <font size="4">C++中风格是static_cast(content)。<font size="4" color="green">C++风格的强制转换其他的好处是，它们能更清晰的表明它们要干什么</font>。程序员只要扫一眼这样的代码，就能立即知道一个强制转换的目的。</font></font></p>

<p><font size="4"><strong>1、隐式类型转换</strong></font></p>

<p>  <font size="4">何时发生隐式类型转换？在下面这些情况下，编译器会自动地转换运算对象的类型： <br>
<font size="4"> <br>
 - 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型； <br>
 - 在条件中，非布尔值转换为布尔类型； <br>
 - 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型； <br>
 - 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型； <br>
 - 函数调用时也会发生类型转换。</font></font></p>

<p>  <font size="4">除了算术转换之外还有几种隐式转换，包括如下几种：</font></p>

<p><font size="4" color="green">1、数组转换成指针：</font> 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针：</p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>];   <span class="hljs-comment">//含有10个整数的数组</span>
<span class="hljs-keyword">int</span> *ip=ia;  <span class="hljs-comment">//ia转换成指向数组首元素的指针</span></code></pre>

<p><font size="4">当数组被用作decltype关键字的参数，或者作为取地址符（&amp;）、sizeof及typeid等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生。</font></p>

<p><font size="4" color="green">2、指针的转换：</font><font size="4">C++还规定了几种其他转换方式，包括常量整数值0或字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void*。</font></p>

<p><font size="4" color="green">3、转换成布尔类型：</font><font size="4">存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果为false；否则转换结果是true；</font></p>

<p><font size="4" color="green">4、转换成常量：</font><font size="4">允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换成指向const T的指针或引用。相反的转换不存在，因为它试图删除掉底层const。</font></p>

<p><font size="4" color="green">5、类类型定义的转换：</font><font size="4">类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。</font></p>

<p><font size="4"><strong>2、显式类型转换</strong></font></p>

<p>  <font size="4">关于强制类型转换的问题，很多书都讨论过，写的最详细的是C++ 之父的《C++ 的设计和演化》。<font size="4" color="blue">最好的解决方法就是不要使用C风格的强制类型转换，而是使用标准C++的类型转换符</font>：static_cast, dynamic_cast。标准C++中有四个类型转换符：static_cast、dynamic_cast、reinterpret_cast、和const_cast。下面对它们一一进行介绍。</font></p>

<p><font size="4" color="green">1、static_cast</font></p>

<p><font size="4">用法：static_cast &lt; type-id &gt; ( expression )</font></p>

<p><font size="4">说明：该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。</font></p>

<p><font size="4" color="red">来源：为什么需要static_cast强制转换？</font> <br>
<font size="4"> <br>
情况1：void指针-&gt;其他类型指针 <br>
情况2：改变通常的标准转换 <br>
情况3：避免出现可能多种转换的歧义</font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> c=<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">7.987</span>);<span class="hljs-comment">//如果涉及到类的话，static_cast只能在有相互联系的类型中进行相互转换,不一定包含虚函数。</span>

<span class="hljs-keyword">class</span> A{};
<span class="hljs-keyword">class</span> B:<span class="hljs-keyword">public</span> A{};
<span class="hljs-keyword">class</span> C{};

<span class="hljs-keyword">int</span> main()
{ 
    A* a=<span class="hljs-keyword">new</span> A;
    B* b; C* c;
    b=<span class="hljs-keyword">static_cast</span>&lt;B&gt;(a); <span class="hljs-comment">// 编译不会报错, B类继承A类</span>
    c=<span class="hljs-keyword">static_cast</span>&lt;B&gt;(a); <span class="hljs-comment">// 编译报错, C类与A类没有任何关系</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4" color="green">2、dynamic_cast</font></p>

<p><font size="4">用法：dynamic_cast &lt; type-id &gt; ( expression )</font></p>

<p><font size="4">说明：该运算符把expression转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用。</font></p>

<p><font size="4" color="red">来源：为什么需要dynamic_cast强制转换？</font></p>

<p><font size="4">简单的说，当无法使用virtual函数的时候。</font></p>

<p><font size="4" color="green">【Note】：</font> <br>
<font size="4"> <br>
（1）其他三种都是编译时完成的，dynamic_cast是运行时处理的，运行时要进行类型检查。 <br>
（2）不能用于内置的基本数据类型的强制转换。 <br>
（3）dynamic_cast转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回NULL。 <br>
（4）使用dynamic_cast进行转换的，基类中一定要有虚函数，否则编译不通过。需要检测有虚函数的原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义。 这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表， 只有定义了虚函数的类才有虚函数表。 <br>
（5）在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有类型检查的功能，比 static_cast更安全。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">void</span> doSomething(Flyable *obj)
{
    <span class="hljs-comment">//name的返回值因系统而异，类型不同返回的字符串有所区别即可。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(*obj).name() &lt;&lt; endl;
    obj-&gt;takeoff();
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeid</span>(*obj) == <span class="hljs-keyword">typeid</span>(Bird))
    {
        Bird *bird = <span class="hljs-keyword">dynamic_cast</span>&lt;Bird *&gt;(obj);
        bird-&gt;foraging();
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeid</span>(*obj) == <span class="hljs-keyword">typeid</span>(Plane))
    {
        Plane *plane = <span class="hljs-keyword">dynamic_cast</span>&lt;Plane *&gt;(obj);
        plane-&gt;carry();
    }
    obj-&gt;land();
}</code></pre>

<p><font size="4" color="green">3、reinpreter_cast</font></p>

<p><font size="4">用法：reinpreter_cast (expression)</font></p>

<p><font size="4">说明：type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。<font size="4" color="red">它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。</font></font></p>

<p><font size="4" color="green">4、const_cast</font></p>

<p><font size="4">用法：const_cast (expression)</font></p>

<p><font size="4">说明：该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。</font></p>

<p><font size="4">常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> B{

<span class="hljs-keyword">public</span>:

<span class="hljs-keyword">int</span> m_iNum;

}

<span class="hljs-keyword">void</span> foo(){

<span class="hljs-keyword">const</span> B b1;

b1.m_iNum = <span class="hljs-number">100</span>; <span class="hljs-comment">//comile error</span>

B b2 = <span class="hljs-keyword">const_cast</span>&lt;B&gt;(b1);

b2. m_iNum = <span class="hljs-number">200</span>; <span class="hljs-comment">//fine</span>
}</code></pre>

<p><font size="4">上面的代码编译时会报错，因为b1是一个常量对象，不能对它进行改变；使用const_cast把它转换成一个常量对象，就可以对它的数据成员任意改变。注意：b1和b2是两个不同的对象。</font></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/03/07 20:36:47 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79476501">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79476501                    </div>
                    <div>
                        阅读：5                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[转]C++在循环内和循环外定义变量的差异]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79476137</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79476137</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/03/07 20:08:15</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4">在C++里面，我们通常会这样写for循环：</font></p>

<pre class="prettyprint"><code class=" hljs matlab"><span class="hljs-keyword">for</span>(int <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>;<span class="hljs-built_in">i</span>&lt;<span class="hljs-number">10</span>;<span class="hljs-built_in">i</span>++)
<span class="hljs-cell">{
     cout &lt;&lt; i;      
}</span></code></pre>

<p>  <font size="4">还有另外一种写法：</font></p>

<pre class="prettyprint"><code class=" hljs matlab">int <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(; <span class="hljs-built_in">i</span>&lt;<span class="hljs-number">10</span> ;<span class="hljs-built_in">i</span>++)
<span class="hljs-cell">{
      cout &lt;&lt; i;     
}</span></code></pre>

<p>  <font size="4">首先是在内层循环中定义变量到底会不会存在重复分配的问题，这涉及到编译器的优化，不过主流编译器（如vs和gcc）这一块优化都比较好，不会反复分配变量。函数的定义是编译器的事情，运行的时候不存在什么定义，更没有什么开销。</font></p>

<p>  <font size="4"> 除非是类对象或者结构体对象, 在for循环里面与外面, 开销可能会不一样.基本数据类型, 那是一样的, 编译器肯定会优化这个东西。</font></p>

<p>  <font size="4">一般来说, 在进入函数时, 所有的栈变量都分配好空间了。所以那个for变量写在哪里都是一样的. 具体你可以看一下反汇编代码, 全部就展现在你眼前了。</font></p>

<p>  <font size="4">自己在编程的时候要注意不要让上一次的结果影响到下一次循环，比如上一次 a = 3, 当下一次循环在给a赋值的时候出了错误，而你捕获了错误，却没修正a的值，程序继续执行，那么这时候a=3还成立，可能就会有问题了，如果是每次都重新定义，那就不存在这样的问题。</font></p>

<p>  <font size="4" color="red">最后总结：</font></p>

<p>  <font size="4">1、对于使用int等基本数据类型作为循环变量，只要你用的优化方面足够给力的主流的编译器，完全不需要关心在循环外还是循环内定义循环变量。</font></p>

<p>  <font size="4">2、如果循环变量本身是复杂的对象，建议在循环外定义好，并且在for循环的赋值语句、判断语句中，都要避免重复创建对象。</font></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/03/07 20:08:15 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79476137">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79476137                    </div>
                    <div>
                        阅读：14                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]map和pair]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79475973</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79475973</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/03/07 19:55:14</pubDate>
                <description>
                    <![CDATA[
                    <p><font size="5"><strong>一、pair简介</strong></font></p>

<p><font size="4">1、pair的类型：pair是一种模版类型。<font size="4" color="red">每个pair 可以存储两个值。这两种值的类型没有限制</font>，也可以将自己写的类放进去。</font></p>

<p><font size="4">2、pair 应用：如果一个函数有两个返回值的话，<font size="4" color="green">如果是相同类型，就可以用数组返回，如果是不同类型，两个属性的话，就可以用pair 进行操作，有多个属性的时候 ，可以使用tuple。</font></font></p>

<p><font size="4">3、生成方法2种：</font></p>

<pre class="prettyprint"><code class=" hljs cs">pair&lt;<span class="hljs-keyword">int</span> ,<span class="hljs-keyword">int</span> &gt;p (<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);

pair&lt;<span class="hljs-keyword">int</span> ,<span class="hljs-keyword">int</span> &gt; p1= make_pair(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);

pair&lt;<span class="hljs-keyword">string</span>,<span class="hljs-keyword">double</span>&gt; p2 (<span class="hljs-string">"aa"</span>,<span class="hljs-number">5.0</span>);

pair &lt;<span class="hljs-keyword">string</span> ,<span class="hljs-keyword">double</span>&gt; p3 = make_pair(<span class="hljs-string">"aa"</span>,<span class="hljs-number">5.0</span>);</code></pre>

<p><font size="5"><strong>二、map简介</strong></font></p>

<p>  <font size="4">map可以当做一个容器（装载具有一定格式的数据）；pair可以理解为元素（放入到容器的的每个个体），pair并没有单独行动的典型用法，正常都是配合map来使用（即把pair这个元素插入到map这个容器里面）。 <br>
  <font size="4" color="red">pair与map怎样联系起来：</font> <br>
通过map的insert()可以把一个pair对象作为map 的参数，如<code>map1.insert(pair1&lt;id,grade&gt;);</code></font></p>

<p>  <font size="4">map的相应的接口说明：</font></p>

<pre class="prettyprint"><code class=" hljs scss">　　<span class="hljs-function">begin()</span> 返回指向<span class="hljs-tag">map</span>头部的迭代器

　　<span class="hljs-function">clear(） 删除所有元素

　　<span class="hljs-function">count()</span> 返回指定元素出现的次数

　　<span class="hljs-function">empty()</span> 如果map为空则返回true

　　<span class="hljs-function">end()</span> 返回指向map末尾的迭代器

　　<span class="hljs-function">equal_range()</span> 返回特殊条目的迭代器对

　　<span class="hljs-function">erase()</span> 删除一个元素

　　<span class="hljs-function">find()</span> 查找一个元素

　　<span class="hljs-function">get_allocator()</span> 返回map的配置器

　　<span class="hljs-function">insert()</span> 插入元素

　　<span class="hljs-function">key_comp()</span> 返回比较元素key的函数

　　<span class="hljs-function">lower_bound()</span> 返回键值&gt;=给定元素的第一个位置

　　<span class="hljs-function">max_size()</span> 返回可以容纳的最大元素个数

　　<span class="hljs-function">rbegin()</span> 返回一个指向map尾部的逆向迭代器

　　<span class="hljs-function">rend()</span> 返回一个指向map头部的逆向迭代器

　　<span class="hljs-function">size()</span> 返回map中元素的个数

　　<span class="hljs-function">swap()</span> 交换两个map

　　<span class="hljs-function">upper_bound()</span> 返回键值&gt;给定元素的第一个位置

　　<span class="hljs-function">value_comp()</span> 返回比较元素value的函数</span></code></pre>

<p><font size="5"><strong>三、map按value排序 </strong></font></p>

<p>  <font size="4">我们知道C++ STL中的map是以key排序的。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> main()
{
    <span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;</span> map_a;
    iMap[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    iMap[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;
    iMap[<span class="hljs-number">5</span>] = <span class="hljs-number">3</span>;
    iMap[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = map_a.begin(); it != map_a.end(); it++)
        <span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">':'</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>  <font size="4"> 那如果我要以value进行排序呢？ <br>
  <font size="4">方案：将map的key和value以pair的形式装到vector中，对vector进行排序。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> main()
{
    <span class="hljs-stl_container"><span class="hljs-built_in">multimap</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;</span> map_a;
    iMap[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    iMap[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;
    iMap[<span class="hljs-number">5</span>] = <span class="hljs-number">3</span>;
    iMap[<span class="hljs-number">4</span>] = <span class="hljs-number">4</span>;

    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;</span>&gt; map_b;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = map_a.begin(); it != map_a.end(); it++)
        map_b.push_back(make_pair(it-&gt;first, it-&gt;second));

    sort(map_b.begin(), map_b.end(), 
        [](<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &amp;x, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; &amp;y) -&gt; <span class="hljs-keyword">int</span> {
        <span class="hljs-keyword">return</span> x.second &lt; y.second;
    });

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = map_b.begin(); it != map_b.end(); it++)
        <span class="hljs-built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="hljs-string">':'</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="hljs-string">'\n'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>                    <div>
                        作者：daaikuaichuan 发表于 2018/03/07 19:55:14 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79475973">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79475973                    </div>
                    <div>
                        阅读：8                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]C++记录程序运行时间]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79301577</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79301577</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/02/09 20:11:00</pubDate>
                <description>
                    <![CDATA[
                    <pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include &lt;ctime&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    clock_t start_time = clock();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100000000</span>; ++i)
    {
        ++i;
    }
    <span class="hljs-comment">//clock_t,clock()定义于time.h中，clock（）返回从程序运行时刻开始的时钟周期数，</span>
    <span class="hljs-comment">//类型为long.CLOCKS_PER_SEC定义了每秒钟包含多少了时钟单元数，因为计算ms，所以*1000。</span>
    clock_t end_time = clock();
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Running time is: "</span> &lt;&lt; <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(end_time-start_time)/CLOCKS_PER_SEC*<span class="hljs-number">1000</span> &lt;&lt;
         <span class="hljs-string">"ms"</span> &lt;&lt; endl;<span class="hljs-comment">//输出运行时间。</span>
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180209201026103?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/02/09 20:11:00 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79301577">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79301577                    </div>
                    <div>
                        阅读：26                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[转]前期学习资料]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79301568</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79301568</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/02/09 20:08:53</pubDate>
                <description>
                    <![CDATA[
                    <h2 id="一-c">一、 C++</h2>

<ul>
<li><font size="4">  《C++ Primer》</font></li>
<li><font size="4">《Effective C++》</font></li>
<li><font size="4">《Effective STL》</font></li>
<li><font size="4">《深度探索C++对象模型》</font></li>
</ul>



<h2 id="二数据结构和算法">二、数据结构和算法</h2>

<ul>
<li><font size="4">《大话数据结构》</font></li>
<li><font size="4">《图解数据结构》</font></li>
<li><font size="4">《数据结构与算法分析C++语言描述》</font></li>
 - 
</ul>

<h2 id="三图像处理相关">三、图像处理相关</h2>

<ul>
<li><font size="4">《图像处理、分析与机器视觉》</font></li>
<li><font size="4">《机器视觉算法与应用》</font></li>
<li><font size="4">《统计学习方法》李航</font></li>
<li><font size="4">《opencv3编程入门》</font></li>
</ul>

<h2 id="四linux及操作系统">四、LINUX及操作系统</h2>

<ul>
<li><font size="4">《鸟哥的LINUX私房菜》</font></li>
<li><font size="4"> 《UNIX环境高级编程》</font></li>
</ul>



<h2 id="五面试刷题">五、面试刷题</h2>

<ul>
<li><font size="4">《剑指offer》</font></li>
<li><font size="4">《程序员面试笔试宝典》.何昊 </font></li>
<li><font size="4">《C和C++程序员面试秘笈》董海山</font></li>
<li><font size="4">《程序员面试金典》（crack the coding interview）</font></li>
<li><font size="4">《编程之美》</font></li>
<li><font size="4">《编程珠玑》</font></li>
</ul>



<h2 id="六在线测试平台">六、在线测试平台</h2>

<p><font size="4">1.牛客网</font></p>

<p><a href="http://www.nowcoder.com/">http://www.nowcoder.com/</a></p>

<p>app：<a href="http://www.nowcoder.com/app">http://www.nowcoder.com/app</a></p>

<p><font size="4">2.华为在线软件训练与测试平台 </font></p>

<p><a href="http://career-oj.huawei.com/exam">http://career-oj.huawei.com/exam</a> </p>

<p><font size="4">3.浙大的Programming Ability Test </font></p>

<p><a href="http://www.patest.cn/">http://www.patest.cn/</a></p>

<p><a href="http://www.patest.cn/contests/pat-b-practise">http://www.patest.cn/contests/pat-b-practise</a></p>

<p><font size="4">4.leetcode、 lintcode </font></p>

<p> <a href="http://www.lintcode.com/zh-cn/problem/">http://www.lintcode.com/zh-cn/problem/</a></p>

<p><font size="4">5.快客网</font></p>

<p><a href="http://www.cricode.com/">http://www.cricode.com/</a></p>

<p>转自：<a href="http://blog.csdn.net/liuuze5/article/details/49721585">http://blog.csdn.net/liuuze5/article/details/49721585</a></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/02/09 20:08:53 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79301568">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79301568                    </div>
                    <div>
                        阅读：26                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]C++11特性总结]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79240196</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79240196</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/02/02 15:58:57</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4"> C++11包括大量的新特性：主要特征像lambda表达式和移动语义，实用的类型推导关键字auto，更简单的容器遍历方法，和大量使模板更容易使用的改进。这一系列教程将包含所以以上特性。 <br>
  <font size="4">很明显，C++11为C++带来了大量的新特性。C++11将修复大量缺陷和降低代码拖沓，比如lambda表达式的支持将使代码更简洁。像移动语义这种特性会提高语言内核的基础效率，使你可以写出更快的代码。对模板系统的优化可以使你更容易写出泛型的代码。</font></font></p>

<p><font size="4" color="red"><strong>1、long long 类型</strong></font></p>

<p>  <font size="4">long long 类型实际上没有在C++ 98中存在，而之后被C99标准收录，其实现在市面上大多数编译器是支持 long long 的，但是这个类型正式成为C++的标准类型是在C++11中。标准要求long long至少是64位也就是8个字节。一个字面常量使用LL后缀表示long long类型，使用ULL后缀表示unsigned long long 类型。</font></p>

<p><font size="4" color="red"><strong>2、列表初始化</strong></font></p>

<p>  <font size="4">C++11中全面加入了列表初始化的功能，包括对vector，map，值类型，struct等等都可以使用列表初始化，还可以在函数中返回一个花括号括起来的列表，而在这之前我们只能对数组进行列表初始化。</font></p>

<p><font size="4" color="green">【Note】：C++有哪几种情况只能用初始化列表，而不能用赋值？</font> <br>
<font size="4"> <br>
（1）对于const和reference类型成员变量，它们只能够被初始化而不能做赋值操作，因此只能用初始化列表； 因为常量不能被赋值，只能被初始化，所以必须在初始化列表中完成；C++的引用也一定要初始化，所以必须在初始化列表中完成。 <br>
【 <br>
      1) 引用必须被初始化，指针不必； <br>
      2) 引用初始化以后不能被改变，指针可以改变所指的对象； <br>
      3) 不存在指向空值的引用，但是存在指向空值的指针。 <br>
】 <br>
（2）子类初始化父类的私有成员。 <br>
（3）需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//数组列表初始化</span>
<span class="hljs-keyword">int</span> xx[<span class="hljs-number">5</span>]={<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
<span class="hljs-keyword">int</span> yy[]={<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>};

<span class="hljs-comment">//值类型进行初始化</span>
<span class="hljs-keyword">int</span> a{<span class="hljs-number">10</span>};
<span class="hljs-keyword">int</span> b={<span class="hljs-number">10</span>};
<span class="hljs-keyword">int</span> c={<span class="hljs-number">10.123</span>}; <span class="hljs-comment">// 编译器报错，g++ 5.3.1当列表初始化用于值类型的时候，如果有精度损失，编译器会报错。</span>

<span class="hljs-comment">//列表初始化还可以用结构体</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> Str{
   <span class="hljs-keyword">int</span> x;
   <span class="hljs-keyword">int</span> y;
}Str;
Str s = {<span class="hljs-number">10</span>,<span class="hljs-number">20</span>};

<span class="hljs-comment">//列表初始化类,必须是public成员,如果含有私有成员会失败</span>
<span class="hljs-keyword">class</span> Cls{
<span class="hljs-keyword">public</span>:
   <span class="hljs-keyword">int</span> x;
   <span class="hljs-keyword">int</span> y;
};
Cls c  = {<span class="hljs-number">10</span>,<span class="hljs-number">20</span>};

<span class="hljs-comment">//vector不仅可以使用列表初始化，还可以使用列表进行赋值，数组不能用列表赋值</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>v1={<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}; <span class="hljs-comment">// 初始化</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span>v2;
v2={<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>}; <span class="hljs-comment">//赋值</span>

<span class="hljs-comment">//map列表初始化</span>
<span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span> ,<span class="hljs-keyword">int</span>&gt;</span> m = {
      {<span class="hljs-string">"x"</span>,<span class="hljs-number">1</span>},
      {<span class="hljs-string">"y"</span>,<span class="hljs-number">2</span>},
      {<span class="hljs-string">"z"</span>,<span class="hljs-number">3</span>}
};

<span class="hljs-comment">//用函数返回初始化列表只展示关键代码，相关头文件自行添加</span>
<span class="hljs-comment">//同理结构体，类，map的返回也可以使用初始化列表返回</span>
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> getVector()
{
  <span class="hljs-keyword">return</span> {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>};
}

<span class="hljs-keyword">int</span> main()
{
  <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> v = getVector();
  <span class="hljs-built_in">cout</span>&lt;&lt;v[<span class="hljs-number">0</span>]&lt;&lt;v[<span class="hljs-number">1</span>]&lt;&lt;v.size()&lt;&lt;endl;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;
}</code></pre>

<p><font size="4" color="red"><strong>3、nullptr 空指针</strong></font></p>

<p>  <font size="4">C++11中新加入的字面值表示不指向任何对象的空指针，以前我们常常用一个预定义的宏NULL来表示空指针，实际上NULL的值是0，<font size="4" color="blue">新标准推荐使用nullptr而不是NULL。</font></font></p>

<p><font size="4" color="red"><strong>4、constexpr变量</strong></font></p>

<p>  <font size="4">我们在定义常量的时候一般使用const来定义，一个常量必须在定义的时候进行初始化，并且之后不可更改。一个常量必须使用一个常量表达式进行初始化，并且<font size="4" color="green">在编译期间就可以得到常量的值</font>，但是如何确定一个表达式就是常量表达式呢，C++11提供了一个新的关键字constexpr，使用该关键字定义的常量，由编译器检查为其赋值的表达式是否是常量表达式，例如：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span> ;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> x =  a; </code></pre>

<p>  <font size="4">编译器编译的时候就会报错说a并不是常量。显然constexpr关键字将常量表达式的检查转交给编译器处理，而不是程序员自己，所以使用constexpr定义常量要比const安全。</font></p>

<p><font size="4" color="red"><strong>5、constexpr函数</strong></font></p>

<p>  <font size="4">普通的函数一般是不能用来为constexpr常量赋值的，但是C++11允许定义一种constexpr的函数，这种函数在编译期间就可以计算出结果，这样的函数是可以用来为constexpr赋值的。定义constexpr函数需要遵守一些约定，函数的返回类型以及所有形参的类型都应该是字面值，<font size="4" color="green">一般情况下函数体中必须有且只有一条return语句。</font></font></p>

<pre class="prettyprint"><code class=" hljs mel">constexpr <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>()
{
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
}

constexpr <span class="hljs-keyword">int</span> si = <span class="hljs-keyword">size</span>();</code></pre>

<p>  <font size="4">执行初始化的时候编译器将函数的调用替换成结果值，constexpr函数体中也可以出现除了return之外的其他语句，但是这些语句在运行时不应该执行任何操作，例如空语句，using声明等。constexpr函数允许其返回值并非是一个字面值，例如：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> size(<span class="hljs-keyword">int</span> s)
{
    <span class="hljs-keyword">return</span> s*<span class="hljs-number">4</span>;
}

<span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">30</span>;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> c = <span class="hljs-number">40</span>;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> si = size(a);  <span class="hljs-comment">//error a是一个变量所以函数返回的是一个可变的值</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> si1 = size(<span class="hljs-number">20</span>); <span class="hljs-comment">//ok 函数返回的实际上是一个常量</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> si2 = size(b);  <span class="hljs-comment">//ok</span>
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> si3 = size(c);  <span class="hljs-comment">//ok</span></code></pre>

<p>  <font size="4">由上可知constexpr函数并不一定返回常量，如果应用于函数的参数是一个常量表达式则返回常量，否则返回变量，而该函数调用到底是一个常量表达式还是非常量表达式则由编译器来判断。这就是constexpr的好处。</font></p>

<p><font size="4" color="red"><strong>6、using类型别名</strong></font></p>

<p>  <font size="4">类型别名其实早在C语言中就有了，一般情况下我们使用关键字typedef来声明一个类型的别名，在C++11中增加了另一种声明类型别名的方法就是使用using关键字，using关键字在C++11以前一般用来引用命名空间。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> INT;  <span class="hljs-comment">// 右侧符号代表左侧</span>
<span class="hljs-keyword">using</span> INT2 = <span class="hljs-keyword">int</span>; <span class="hljs-comment">// 左侧符号代表右侧</span>

INT a = <span class="hljs-number">20</span>;
INT2 b = <span class="hljs-number">30</span>;</code></pre>

<p><font size="4" color="red"><strong>7、auto类型指示符</strong></font></p>

<p>  <font size="4">如果编译器在定义一个变量的时候可以推断出变量的类型，不用写变量的类型，你只需写auto即可：</font></p>

<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">auto</span> str = <span class="hljs-string">"sissie"</span>;
<span class="hljs-keyword">assert</span>(<span class="hljs-keyword">typeid</span>(str) == <span class="hljs-keyword">typeid</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> *));</code></pre>

<p>  <font size="4">在迭代器中使用auto，简化代码：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> vs{{<span class="hljs-string">"sissie"</span>, <span class="hljs-string">"robin"</span>, <span class="hljs-string">"playjokes"</span>, <span class="hljs-string">"sky"</span>, <span class="hljs-string">"hatlonely"</span>}};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vs.begin(); it != vs.end(); ++it) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-string">", "</span>;
}</code></pre>

<p>  <font size="4">在模板中使用auto：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> BuiltType, <span class="hljs-keyword">typename</span> Builder&gt;
<span class="hljs-keyword">void</span> makeAndProcessObject(<span class="hljs-keyword">const</span> Builder&amp; builder)
{
    BuiltType val = builder.makeObject();
    <span class="hljs-comment">// do stuff with val</span>
}
MyObjBuilder builder;
makeAndProcessObject&lt;MyObj&gt;(builder);

<span class="hljs-comment">// 使用auto只需要一个模板参数，让编译器自动推导</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Builder&gt;
<span class="hljs-keyword">void</span> makeAndProcessObject(<span class="hljs-keyword">const</span> Builder&amp; builder)
{
    <span class="hljs-keyword">auto</span> val = builder.makeObject();
    <span class="hljs-comment">// do stuff with val</span>
}
MyObjBuilder builder;
makeAndProcessObject(builder);</code></pre>

<p><font size="4" color="red"><strong>8、decltype类型指示符</strong></font></p>

<p>  <font size="4">decltype 返回操作数的类型，可以对基本上任何类型使用decltype，包括函数的返回值：</font></p>

<pre class="prettyprint"><code class=" hljs scss">int ia<span class="hljs-attr_selector">[10]</span>;
<span class="hljs-function">decltype(ia)</span> ib;    <span class="hljs-comment">// int ib[10];</span></code></pre>

<p>  <font size="4">新的函数返回值声明语法，把返回类型放在函数声明的后面，用auto代替前面的返回类型：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// 这两种函数声明方式等效</span>
<span class="hljs-keyword">int</span> multiply(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y);
<span class="hljs-keyword">auto</span> multiply(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) -&gt; <span class="hljs-keyword">int</span>;

<span class="hljs-comment">// 返回auto</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Builder&gt;
<span class="hljs-keyword">auto</span> makeAndProcessObject(<span class="hljs-keyword">const</span> Builder&amp; builder) -&gt; <span class="hljs-keyword">decltype</span>(builder.makeObject())
{
    <span class="hljs-keyword">auto</span> val = builder.makeObject();
    <span class="hljs-comment">// do stuff with val</span>
    <span class="hljs-keyword">return</span> val;
}</code></pre>

<p>  <font size="4">对于引用类型decltype有一些特别的地方： <br>
（1）decltype如果作用于一个引用类型，其得到的还是一个引用类型：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span> ;
<span class="hljs-keyword">int</span> &amp;b = a;
<span class="hljs-keyword">decltype</span>(b) c ;  <span class="hljs-comment">// Error c是引用类型必须赋值</span>
<span class="hljs-keyword">decltype</span>(b) d = a; <span class="hljs-comment">// OK  d是引用类型，指向a</span></code></pre>

<p><font size="4">（2）如果一个表达式是一个解指针引用的操作，decltype得到的也是一个引用类型：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span> ;
<span class="hljs-keyword">int</span> *p = &amp;a;
<span class="hljs-keyword">decltype</span>(*p) c = a;  <span class="hljs-comment">// c的类型是int&amp;</span>
c = <span class="hljs-number">50</span>;
<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;endl;  <span class="hljs-comment">// 输出50</span></code></pre>

<p><font size="4">（3）当decltype作用于一个变量的时候，变量加不加括号是有区别的，例如：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">20</span>;
<span class="hljs-keyword">decltype</span>(a) b = <span class="hljs-number">30</span>; <span class="hljs-comment">//ok b的类型是 int</span>
<span class="hljs-keyword">decltype</span>((a)) c = a ; <span class="hljs-comment">// ok c的类型是int&amp; 其关联变量 a</span></code></pre>

<p><font size="4" color="red"><strong>9、范围for语句</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt;</span> vs{{<span class="hljs-string">"sissie"</span>, <span class="hljs-string">"robin"</span>, <span class="hljs-string">"playjokes"</span>, <span class="hljs-string">"sky"</span>, <span class="hljs-string">"hatlonely"</span>}};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; name: vs) {
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">", "</span>;
}</code></pre>

<p><font size="4" color="red"><strong>10、尾置返回类型</strong></font></p>

<p>  <font size="4">要想引入尾置类型，我们还得从复杂的类型声明说起。</font></p>

<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = <span class="hljs-string">{0}</span>; <span class="hljs-regexp">//</span>定义一个含有<span class="hljs-number">10</span>个<span class="hljs-keyword">int</span>元素的数组。

<span class="hljs-keyword">int</span> (<span class="hljs-variable">*p_arr</span>)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-regexp">//</span>注意：<span class="hljs-keyword">int</span> <span class="hljs-variable">*p_arr</span>[<span class="hljs-number">10</span>] 表示一个数组，有<span class="hljs-number">10</span>个元素，元素类型是<span class="hljs-keyword">int</span>*

<span class="hljs-keyword">int</span> (<span class="hljs-variable">*func</span>(char <span class="hljs-keyword">x</span>))[<span class="hljs-number">10</span>]; <span class="hljs-regexp">//</span>要定义一个函数，这个函数接受一个char类型的参数，并返回一个指向<span class="hljs-number">10</span>个<span class="hljs-keyword">int</span>类型数组的指针呢</code></pre>

<p>  <font size="4">C++11的另外一个特性，尾置返回类型，任何函数都可以使用尾置返回类型，  <font size="4" color="red">这种形式对于返回类型比较复杂的函数最有效</font>，比如上面的函数可以使用如下方式：</font></p>

<pre class="prettyprint"><code class=" hljs scss"><span class="hljs-attribute">auto</span> <span class="hljs-function">func(char x)</span> -&gt; <span class="hljs-function">int(*)</span> <span class="hljs-attr_selector">[10]</span>; </code></pre>

<p>  <font size="4">这种形式将函数的返回类型写在函数声明的最后面，并且在函数形参列表后面加上 -&gt; 符号，然后紧接着是函数需要返回的类型，由于函数的返回类型被放在了形参列表之后，所以在函数名前面使用一个 auto替代。</font></p>

<p><font size="4" color="red"><strong>11、强枚举类型</strong></font></p>

<p>  <font size="4">在标准C++中，枚举类型不是类型安全的。枚举类型被视为整数，这使得两种不同的枚举类型之间可以进行比较。C++03 唯一提供的安全机制是一个整数或一个枚举型值不能隐式转换到另一个枚举别型。 此外，枚举所使用整数类型及其大小都由实现方法定义，皆无法明确指定。 最后，枚举的名称全数暴露于一般范围中，因此C++03两个不同的枚举，不可以有相同的枚举名。 (好比 enum Side{ Right, Left }; 和 enum Thing{ Wrong, Right }; 不能一起使用。)</font></p>

<p>C++11 引进了一种特别的 “枚举类”，可以避免上述的问题。使用 enum class 的语法来声明：</p>

<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Enumeration</span>
{</span>
  Val1,
  Val2,
  Val3 = <span class="hljs-number">100</span>,
  Val4 <span class="hljs-comment">/* = 101 */</span>,
};</code></pre>

<p>  <font size="4">此种枚举为类型安全的。枚举类型不能隐式地转换为整数；也无法与整数数值做比较。 (表示式 Enumeration::Val4 == 101 会触发编译期错误)。 <br>
  <font size="4">枚举类型所使用类型必须显式指定。在上面的示例中，使用的是默认类型 int，但也可以指定其他类型：</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> Enum2 : <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> {Val1, Val2};</code></pre>

<p><font size="4" color="red"><strong>12、=default 生成默认构造函数</strong></font></p>

<p>  <font size="4">在C++的类中，如果我们没有定义构造函数，编译器会为我们合成默认的无参构造函数，如果我们定义了构造函数，则编译器就不生成默认构造函数了，但是如果我们定义构造函数同时也希望编译器生成默认构造函数呢? C++11中可以通过在构造函数的声明中直接  =default的方式要求编译器生成构造函数。</font></p>

<pre class="prettyprint"><code class=" hljs cs">class ClassName{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-title">ClassName</span>(<span class="hljs-keyword">int</span> x);
        ClassName()=<span class="hljs-keyword">default</span>; <span class="hljs-comment">// 显示要求编译器生成构造函数</span>
};</code></pre>

<p><font size="4" color="red"><strong>13、类对象成员的类内初始化</strong></font></p>



<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span>
{</span>
        <span class="hljs-keyword">public</span>:
                <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">//C++11 之前是不允许的</span>
};</code></pre>

<p><font size="4" color="red"><strong>14、lambda表达式与bind函数</strong></font></p>

<p>  <font size="4">C++11中得lambda表达式用来定义和创建匿名函数，lambda表达式语法形式如下：</font></p>

<pre class="prettyprint"><code class=" hljs d">[ capture ] ( params ) mutable exception attribute -&gt; ret { <span class="hljs-keyword">body</span> }      <span class="hljs-comment">// 完整的 lambda 表达式形式</span>
[ capture ] ( params ) -&gt; ret { <span class="hljs-keyword">body</span> }                                  <span class="hljs-comment">// const 类型的 lambda 表达式，该类型的表达式不能改捕获("capture")列表中的值</span>
[ capture ] ( params ) { <span class="hljs-keyword">body</span> }                                         <span class="hljs-comment">// 省略了返回值类型的 lambda 表达式</span>
[ capture ] { <span class="hljs-keyword">body</span> }                                                    <span class="hljs-comment">// 省略了参数列表，类似于无参函数 f()</span></code></pre>

<p>  <font size="4">lambda表达式是一个可以被调用的代码单元，相当于一个内联函数，有参数和返回值以及函数体。但是跟函数不同的是，lambda表达式可以定义在函数的内部，一个完整的lambda表达式具有如下形式：</font></p>

<pre class="prettyprint"><code class=" hljs markdown">[<span class="hljs-link_label">捕获列表</span>](<span class="hljs-link_url">参数列表</span>) mutable -&gt; 返回类型 {函数体}</code></pre>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">auto</span> add= [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)-&gt;<span class="hljs-keyword">int</span>{
        <span class="hljs-keyword">return</span> a + b;
    };
    <span class="hljs-keyword">int</span> ret = add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ret:"</span> &lt;&lt; ret &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>  <font size="4">lambda可以省略参数列表(如果没有参数的话)，可以省略返回类型，但是不能省略捕获部分与函数体部分，即使捕获列表为空,也要有一个空的[]，<font size="4" color="blue">lambda有两种捕获，一种是值捕获，一种是引用捕获</font>。如果是值捕获那么lambda中获得的是捕获的变量的副本，如果是引用捕获则获得的是引用，可以在lambda内部修改引用的变量的值，如上x是值捕获，y是引用捕获，lambda中默认是值捕获，如果变量前面添加&amp;则是引用捕获，另外lambda中还有两种形式的引用捕获，<font size="4" color="blue">例如[=]表示值捕获所有可见的变量，而[&amp;]则表示引用捕获所有可见变量。</font>如果希望值捕获所有可见变量，但是又有个别变量采用引用捕获呢，[=,&amp;x]表示值捕获所有可见变量，同时引用捕获x。而[&amp;,x]则表示引用捕获所有可见变量，x采用值捕获的方式。</font></p>

<p>  <font size="4">lambda的捕获表达式中的内容转换成函数不可行，C++11提供了bind函数来完成这样的操作。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;functional&gt; <span class="hljs-comment">//bind()</span></span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::placeholders; <span class="hljs-comment">// _1,_2所在的命名空间</span>
<span class="hljs-keyword">int</span> f(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y,<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)
{
  <span class="hljs-keyword">return</span> a+b+x+y;
}

<span class="hljs-keyword">void</span> main()
{
  <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">int</span> y = <span class="hljs-number">20</span>;

  <span class="hljs-keyword">auto</span> f_wrap = bind(f,x,y,_1,_2);
  <span class="hljs-built_in">cout</span>&lt;&lt;f_wrap(<span class="hljs-number">33</span>,<span class="hljs-number">44</span>)&lt;&lt;endl; <span class="hljs-comment">// _1,_2是占位符,表示调用f_wrap的时候_1是第一个参数,_2是第二个参数。最终会被替换成调用  f(10,20,33,44)</span>
}</code></pre>

<p><font size="4" color="red"><strong>15、可调用对象与function</strong></font></p>

<p>  <font size="4">C++语言中有几种可调用对象：函数、函数指针、lambda表达式、bind创建的对象以及重载子函数调用运算符的类。 <br>
  <font size="4" color="green">不同类型可能具有相同的调用形式，所以C++11中提供了名为function的标准库类型，定义在头文件中，该类型用来存储一个可调用的对象，统一了所有可以像函数一样调用的调用形式，例如：</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;functional&gt;</span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> add(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
{
    <span class="hljs-keyword">return</span> x+y;
}

<span class="hljs-keyword">class</span> Add
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)
        {
            <span class="hljs-keyword">return</span> x+y;
        }
};

<span class="hljs-keyword">void</span> main()
{
  <span class="hljs-comment">//function模版的参数是函数调用形式,包括返回类型,以及参数列表个数和类型</span>
    function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f1 = add;  <span class="hljs-comment">//函数指针</span>
    function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f2 = Add(); <span class="hljs-comment">// 可调用类对象</span>
    function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)&gt; f3 = [](<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y){<span class="hljs-keyword">return</span> x+y;}; <span class="hljs-comment">//lambda表达式</span>

    <span class="hljs-built_in">cout</span>&lt;&lt;f1(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>)&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;f2(<span class="hljs-number">30</span>,<span class="hljs-number">40</span>)&lt;&lt;<span class="hljs-string">" "</span>&lt;&lt;f3(<span class="hljs-number">50</span>,<span class="hljs-number">60</span>)&lt;&lt;endl;
}</code></pre>

<p><font size="4" color="red"><strong>16、move语义与右值引用</strong></font></p>

<p>  <font size="4" color="blue">左值和右值是针对表达式而言，表达式之后依然存在的对象是左值，表达式之后不再存在的临时对象为右值，左值可以对其取地址，右值不能。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> hello = <span class="hljs-string">"hello"</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> world = <span class="hljs-string">"world"</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp; ri = <span class="hljs-number">1</span>;

<span class="hljs-comment">// 左值：i, ++i, hello, world</span>
<span class="hljs-comment">// 右值：i++, hello + world, ri</span></code></pre>

<p>  <font size="4">为了支持移动操作，C++11中使用了一种称为右值引用的类型。移动操作是什么呢，一般情况下我们将一个对象赋值给另一个对象的时候会调用对象到拷贝构造函数或者拷贝赋值运算符。而移动构造函数和移动赋值运算符则用来将数据从一个对象移动到另一个对象。在很多情况下对象拷贝之后需要被销毁，此时使用移动操作会大幅提高性能。右值引用被使用之后，其关联的对象会被销毁。右值引用使用两个&amp;&amp;表示，例如 int &amp;&amp; 表示右值引用，而int &amp;则是左值。通过C++11标准库提供的函数 std::move()可以得到某一对象的右值引用。</font></p>

<pre class="prettyprint"><code class=" hljs cpp">TestClass::TestClass(TestClass &amp;&amp;t) <span class="hljs-keyword">noexcept</span> <span class="hljs-comment">//移动构造函数不应该抛出任何异常</span>
:x(t.x),y(t.y),z(t.z),p(t.p)
{
  t.p=<span class="hljs-keyword">nullptr</span>; <span class="hljs-comment">// 实现移动操作之后需要保证被移动的对象的析构是安全的，所以源对象的指针成员置为空，随后t的析构函数将会被自动调用，t被销毁。</span>
}

<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;TestClass&gt;</span> v;
TestClass tc;
v.push_back(<span class="hljs-built_in">std</span>::move(tc));</code></pre>

<p><font size="4" color="red"><strong>17、智能指针share_ptr,unique_ptr</strong></font></p>

<p>  <font size="4">简单地说，智能指针只是<font size="4" color="green">用对象去管理一个资源指针，同时用一个计数器计算当前指针引用对象的个数，</font>当管理指针的对象增加或减少时，计数器也相应加1或减1，当最后一个指针管理对象销毁时，计数器为1，此时在销毁指针管理对象的同时，也把指针管理对象所管理的指针进行delete操作。 <br>
<img src="http://img.blog.csdn.net/20180202154004427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
<font size="4"> <br>
    <font size="4" color="red">unique_ptr：</font>作用域结束之后自动释放资源，不可复制，可以移动 <br>
    <font size="4" color="red">shared_ptr：</font>通过引用计数共享资源，当引用计数为0时，自动释放资源 <br>
  <font size="4" color="red">weak_ptr：</font>  一个shared_ptr的弱引用，不修改引用计数，为了解决循环引用问题而引入。</font></font></p>

<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-comment">#include &lt;cassert&gt;</span>
<span class="hljs-comment">#include &lt;memory&gt;</span>

int main() {
    {
        <span class="hljs-symbol">std:</span><span class="hljs-symbol">:unique_ptr&lt;int&gt;</span> upi(new int(<span class="hljs-number">6</span>));
    }

    {
        <span class="hljs-regexp">//</span> 用make_shared来初始化shared_ptr
        <span class="hljs-symbol">std:</span><span class="hljs-symbol">:shared_ptr&lt;int&gt;</span> spi = <span class="hljs-symbol">std:</span><span class="hljs-symbol">:make_shared&lt;int&gt;</span>(<span class="hljs-number">6</span>);
        <span class="hljs-regexp">//</span> use_count获取引用计数
        assert(spi.use_count() == <span class="hljs-number">1</span>);
        {
            <span class="hljs-symbol">std:</span><span class="hljs-symbol">:shared_ptr&lt;int&gt;</span> spi_shared(spi);
            assert(spi.use_count() == <span class="hljs-number">2</span>);
        }
        assert(spi.use_count() == <span class="hljs-number">1</span>);
    }

    {
        <span class="hljs-symbol">std:</span><span class="hljs-symbol">:shared_ptr&lt;int&gt;</span> spi = <span class="hljs-symbol">std:</span><span class="hljs-symbol">:make_shared&lt;int&gt;</span>(<span class="hljs-number">6</span>);
        assert(spi.use_count() == <span class="hljs-number">1</span>);

        <span class="hljs-regexp">//</span> 通过shared_ptr来构造weak_ptr
        <span class="hljs-symbol">std:</span><span class="hljs-symbol">:weak_ptr&lt;int&gt;</span> wpi(spi);
        <span class="hljs-regexp">//</span> weak_ptr不改变引用计数
        assert(spi.use_count() == <span class="hljs-number">1</span>);
        assert(wpi.use_count() == <span class="hljs-number">1</span>);

        <span class="hljs-regexp">//</span> lock() 获取weak_ptr引用的shared_ptr
        assert(*wpi.lock() == <span class="hljs-number">6</span>);
        <span class="hljs-regexp">//</span> expired() 返回引用的对象是否已经释放
        assert(!wpi.expired());
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4" color="red"><strong>18、STL容器</strong></font></p>

<p><font size="4" color="green">（1）std::array ：</font></p>

<p>  <font size="4">array是C++11新引入的数组类型，和std::vector不同的是array的长度是固定的，不能动态拓展。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> T, <span class="hljs-built_in">std</span>::size_t N&gt; <span class="hljs-keyword">struct</span> <span class="hljs-built_in">array</span>

<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 3&gt;</span> a1{{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}};
<span class="hljs-built_in">std</span>::sort(a1.begin(), a1.end());</code></pre>

<p><font size="4" color="green">（2）std::forward_list ：</font></p>

<p>  <font size="4">C++11引入的新类型，forward_list是单链表（std::list是双链表），只需要顺序遍历的场合，forward_list能更加节省内存，插入和删除的性能高于list。</font></p>

<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-symbol">std:</span><span class="hljs-symbol">:forward_list&lt;int&gt;</span> fli{{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}};</code></pre>

<p><font size="4" color="green">（3）unordered ：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span> 
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">multiset</span> 
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span> 
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">multimap</span></code></pre>

<p>  <font size="4">用平衡树实现的有序的容器，插入、删除和查找的时间复杂度都是O(nlogn)。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span> 
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_multiset</span> 
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span> 
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_multimap</span></code></pre>

<p>  <font size="4">C++11引入的新类型，用hash实现的无序的容器，插入、删除和查找的时间复杂度都是O(1)，<font size="4" color="red">在不关注容器内元素顺序的场合，使用unordered的容器能获得更高的性能。</font></font></p>

<p><font size="4" color="red"><strong>19、其他内容</strong></font> <br>
<font size="4"> <br>
<font size="4" color="blue">（1）static_assert：</font>做编译期间的断言，因此叫做静态断言，其语法：static_assert(常量表达式，提示字符串)。 <br>
<font size="4" color="blue">（2）tuple：</font>适用于存储不同类型和不同数量的元素。 <br>
<font size="4" color="blue">（3）bitset：</font>位图，适用于进制操作和海量数据排序。 <br>
<font size="4" color="blue">（4）正则表达式：</font>regex则是C++11中新增的正则表达式库。</font></p>

<p>参考<a href="http://www.cnblogs.com/wangqiguo/p/5635441.html">http://www.cnblogs.com/wangqiguo/p/5635441.html</a> <br>
<a href="http://www.cnblogs.com/feng-sc/p/5710724.html">http://www.cnblogs.com/feng-sc/p/5710724.html</a> <br>
<a href="https://segmentfault.com/a/1190000003004734#articleHeader6">https://segmentfault.com/a/1190000003004734#articleHeader6</a></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/02/02 15:58:57 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79240196">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79240196                    </div>
                    <div>
                        阅读：43                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]特殊的工具和技术]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79233070</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79233070</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/02/01 20:37:48</pubDate>
                <description>
                    <![CDATA[
                    <p><font size="5"><strong>一、控制内存分配</strong></font></p>

<p><font size="4"><strong>1、重载new和delete</strong></font></p>

<p>  <font size="4">new的操作过程：第一步、new表达式调用operator new(或者 operator new[])的标准库函数，该函数分配一块足够大的、原始的、未命名的内存空间以便存储特定类型的对象（或数组）。第二步、编译器运行相应的构造函数以构造这些对象，并为其传入初始值。第三步、对象分配了空间并构造完成，返回一个指向该对象的指针 <br>
  <font size="4">delete的操作过程：第一步：对指针所指对象的数组指针所指数组执行相应的析构函数。第二步：编译器调用operator delete（或者operator delete[]）的标准库函数释放内存空间 <br>
  <font size="4" color="red">重载new和delete：</font>若分配（释放）的对象是类类型，则编译器首先在类及其基类的作用域中查找，若该类中含有operator new成员或者operator delete成员，则相应表达式将调用这些成员，否则，编译器将在全局作用域查找匹配函数，若找到用户自定义版本，则执行，找不到，会使用标准库版本。</font></font></p>

<p>  <font size="4">C++从C语言中继承了malloc和free函数，头文件为cstdlib，malloc接受一个表示待分配字节数的size_t，返回指向该内存空间的指针或者返回0表示分配失败。free()函数接受一个void *，它是malloc返回指针的副本，free将相关内存返回给系统，free(0)无意义。所以operator new可以用malloc来实现。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;  </span>
<span class="hljs-preprocessor">#include &lt;cstdlib&gt;  </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  

<span class="hljs-keyword">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size_t n)
{  
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new(size_t)"</span> &lt;&lt; endl;  
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">void</span> *mem = <span class="hljs-built_in">malloc</span>(n))  
        <span class="hljs-keyword">return</span> mem;  
    <span class="hljs-keyword">else</span>  
        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::bad_alloc();  
}  

<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">void</span> *mem) <span class="hljs-keyword">noexcept</span>
{  
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete(void*)"</span> &lt;&lt; endl;  
    <span class="hljs-built_in">free</span>(mem);  
} 

<span class="hljs-keyword">int</span> main()  
{  
    <span class="hljs-keyword">int</span> *a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">486</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *a &lt;&lt; endl;  
    <span class="hljs-keyword">delete</span> a;
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}  </code></pre>

<p><font size="4"><strong>2、定位new表达式</strong></font></p>

<p>  <font size="4">operator new和operator delete和alloctor类的allocate和deallocate很像，都是负责分配和释放内存的函数，但是对于operator new分配的内存空间我们无法使用construct函数构造对象，我们应该使用new的<font size="4" color="green">定位new</font>形式构造对象。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;new&gt;</span>
<span class="hljs-keyword">const</span> intchunk = <span class="hljs-number">16</span>;
<span class="hljs-keyword">class</span> Foo
{
<span class="hljs-keyword">public</span> :
    <span class="hljs-keyword">int</span> val( ) { <span class="hljs-keyword">return</span> _val; }
    Foo( ) { _val = <span class="hljs-number">0</span>; }
<span class="hljs-keyword">private</span> :
    int_val;
};

<span class="hljs-comment">//预分配内存，但没有Foo对象</span>
<span class="hljs-keyword">char</span>*buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[ <span class="hljs-keyword">sizeof</span>(Foo) * chunk ];
<span class="hljs-keyword">int</span> main( <span class="hljs-keyword">void</span> )
{
    <span class="hljs-comment">//在buf中创建一个Foo对象</span>
    Foo*pb = <span class="hljs-keyword">new</span> (buf) Foo;
    <span class="hljs-comment">//检查一个对象是否被放在buf中</span>
    <span class="hljs-keyword">if</span> ( pb-&gt;val() == <span class="hljs-number">0</span> )
    {
        <span class="hljs-built_in">cout</span> &lt;&lt;<span class="hljs-string">"new expressio worked!"</span> &lt;&lt;endl;
    }
    <span class="hljs-comment">//到这里不能再使用pb</span>
    <span class="hljs-keyword">delete</span>[] buf;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>  <font size="4">placement new的作用就是：创建对象但是不分配内存，而是在已有的内存块上面创建对象。用于需要反复 创建并删除的对象上，可以降低分配释放内存的性能消耗。定位new表达式（placement new expression），允许程序员将对象创建在已经被分配好的内存中，new表的式的形式如下：</font></p>

<pre class="prettyprint"><code class=" hljs ocaml"><span class="hljs-keyword">new</span> (place_address) <span class="hljs-class"><span class="hljs-keyword">type</span></span>
<span class="hljs-keyword">new</span> (palce_address) <span class="hljs-class"><span class="hljs-keyword">type</span> (</span><span class="hljs-keyword">initializer</span>-<span class="hljs-built_in">list</span>)</code></pre>

<p>  <font size="4">place_address必须是个指针，指向已经分配好的内存。为了使用这种形式的new表达式，必须包含头文件new。</font></p>

<p><font size="4" color="green">【Note】： <br>
1）当只传入一个指针类型的实参时，定位new表达式构造对象但是不分配内存，这个指针没有要求，甚至可能是一个不是一个指向动态内存的指针 <br>
2）调用析构函数会销毁对象，但是不会释放内存。 <br>
<img src="http://img.blog.csdn.net/20180201203054117?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></p>

<p><font size="5"><strong>二、运行时类型识别（RTTI）</strong></font></p>

<p>  <font size="4">RTTI的功能由两个运算符实现： <br>
  <font size="4" color="red">typeid：</font>用于返回表达式的类型。 <br>
  <font size="4" color="red">dynamic_cast：</font>用于将基类的指针或引用转换成派生类的指针或引用，当我们将这两个运算符用于某种类型的引用或指针时，并且该类型含有虚函数，运算符将会使用指针或引用所绑定对象的动态类型。 <br>
<font size="4" color="green">【Note】： <br>
1）使用基类的指针或引用调用派生类的操作并且该操作不是虚函数，一般来说，我们应该尽量将其定义为虚函数（最好是定义为虚函数），编译器会根据对象的动态类型自动选择正确版本的函数。</font></font></p>

<p><font size="4"><strong>1、dynamic_cast运算符</strong></font></p>

<p>  <font size="4">三种形式：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">dynamic_cast</span>&lt;type *&gt; (e)、
<span class="hljs-keyword">dynamic_cast</span>&lt;type &amp;&gt; (e)、
<span class="hljs-keyword">dynamic_cast</span>&lt;type &amp;&amp;&gt; (e)</code></pre>

<p>  <font size="4">type的类型必须含有虚函数，e分别为指针、左值、除了左值以外的类型，e需要满足的条件：目标type的共有派生类、目标type的共有基类或者就是目标type类型，转换失败时，指针类型返回0，引用类型转换失败抛出bad_cast异常，头文件为typeinfo。 <br>
  <font size="4">可以对空指针进行dynamic_cast，结果是所需的空指针，在条件部分执行dynamic_cast可以确保类型转换和检查结果在同一条表达式中完成！ <br>
<font size="4" color="green">【Note】： <br>
1）只能用于引用和指针的转换。 <br>
2）要转换的类型中必须包含虚函数。 <br>
3）转换成功返回子类地址，失败返回null。</font></font></font></p>

<p><font size="4"><strong>2、typeid运算符</strong></font></p>

<p>  <font size="4">typeid(e)，其中e可以是任何类型或表达式的名字，若为表达式，返回的是引用所引对象的类型，若作用域数组名，返回的是数组类型，若作用于指针，返回的是该指针的静态编译的类型。 <br>
  <font size="4">type_info的name()成员返回一个C风格的字符串，表示对象的类型名字，由编译器决定。</font></font></p>

<p><font size="4"><strong>3、使用RTTI</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;  </span>
<span class="hljs-preprocessor">#include &lt;cstdlib&gt;  </span>
<span class="hljs-preprocessor">#include &lt;typeinfo&gt;<span class="hljs-comment">//type_info对象定义在此头文件中。</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  

<span class="hljs-keyword">class</span> Flyable
{
<span class="hljs-keyword">public</span>:
    Flyable() = <span class="hljs-keyword">default</span>;
    ~Flyable() = <span class="hljs-keyword">default</span>;
    <span class="hljs-comment">//定义纯虚函数。</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> takeoff() = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> land() = <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> Bird : <span class="hljs-keyword">public</span> Flyable
{
<span class="hljs-keyword">public</span>:
    Bird() = <span class="hljs-keyword">default</span>;
    ~Bird() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">void</span> foraging() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bird-foraging"</span> &lt;&lt; endl; }<span class="hljs-comment">//觅食。</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> takeoff() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bird-takeoff"</span> &lt;&lt; endl; } 
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> land() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Bird-land"</span> &lt;&lt; endl; } 
};

<span class="hljs-keyword">class</span> Plane : <span class="hljs-keyword">public</span> Flyable
{
<span class="hljs-keyword">public</span>:
    Plane() = <span class="hljs-keyword">default</span>;
    ~Plane() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">void</span> carry() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"plane-carry"</span> &lt;&lt; endl; }  <span class="hljs-comment">//运输。</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> takeoff() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"plane-takeoff"</span> &lt;&lt; endl; } 
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> land() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"plane-land"</span> &lt;&lt; endl; } 
};

<span class="hljs-keyword">void</span> doSomething(Flyable *obj)
{
    <span class="hljs-comment">//name的返回值因系统而异，类型不同返回的字符串有所区别即可。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(*obj).name() &lt;&lt; endl;
    obj-&gt;takeoff();
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeid</span>(*obj) == <span class="hljs-keyword">typeid</span>(Bird))
    {
        Bird *bird = <span class="hljs-keyword">dynamic_cast</span>&lt;Bird *&gt;(obj);
        bird-&gt;foraging();
    }
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeid</span>(*obj) == <span class="hljs-keyword">typeid</span>(Plane))
    {
        Plane *plane = <span class="hljs-keyword">dynamic_cast</span>&lt;Plane *&gt;(obj);
        plane-&gt;carry();
    }
    obj-&gt;land();
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    Bird b;
    doSomething(&amp;b);
    Plane p;
    doSomething(&amp;p);
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201203113969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="5"><strong>三、枚举类型</strong></font></p>

<p>  <font size="4">枚举类型使得我们可以将一组整型常量组织在一起，但是每一个枚举类型都定义了一种新的类型。 <br>
  <font size="4">在限定作用域的枚举类型中，遵循常规的作用域准则，在枚举类型作用域外不可访问，不限定作用域的枚举类型，枚举成员的作用域和枚举类型本身的作用域相同（一般来说两个不限定作用域的枚举类型的成员不可以相同，因为其作用域是相同的，会重复定义）。</font></font></p>

<p>  <font size="4">默认情况下，枚举成员的枚举值从0开始，依次加1，但我们也可以为枚举成员指定初值。</font></p>

<p>  <font size="4" color="red">枚举成员是const的，所以赋值时必须使用常量表达式。</font></p>

<p>  <font size="4" color="red">要想初始化一个enum对象或者为enum赋值，必须使用该类型的一个枚举成员或者该类型的另一个对象，不限定作用域的枚举类型的对象或其枚举成员会自动转换为整形。</font></p>

<p>  <font size="4">C++11新标准，可以在enum之后加上冒号再加上我们想在enum中使用的类型：enum：unsigned int ｛｝，默认情况下为int。可以先声明不定义。</font></p>

<p><font size="5"><strong>四、类成员指针</strong></font></p>

<p>  <font size="4" color="blue">成员指针是指可以指向类的非静态成员的指针，由于类的静态成员不属于任何对象，所以无需特殊的指向该成员的指针，成员指针的类型需要包括类的类型和成员的类型，例如：const string Screen:: *p，一个指向Screen类的const string成员的指针p</font></p>

<p><font size="4"><strong>1、数据成员指针</strong></font></p>

<p>  <font size="4">在给成员指针赋值时，我们将取址运算符作用域screen的成员而不是内存中的一个类的对象的成员。 <br>
  <font size="4" color="green">我们需要注意，当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据，成员指针只指定了成员而非该成员所属的对象，只有解引用成员指针时我们才提供对象的信息。</font></font></p>

<p>  <font size="4"> 成员指针的访问运算符：.<em>或者-&gt;</em>，可以获得对象的指定成员。 <br>
  <font size="4">由于在类中数据成员一般都是私有类型的，所以通常我们不能直接获得数据成员的指针，最好的方法就是定义一个函数，返回一个指向该成员的指针（return &amp;XX）。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> Screen
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> Screen::*data()<span class="hljs-comment">//定义一个函数。</span>
    {
        <span class="hljs-keyword">return</span> &amp;Screen::contents;
    }
    pos cursor;<span class="hljs-comment">//公有成员。</span>
}

<span class="hljs-comment">//数据成员指针：</span>
Screen myScreen(<span class="hljs-string">"abc"</span>, <span class="hljs-number">1</span>), *pScreen = &amp;myScreen;
<span class="hljs-keyword">auto</span> pdata1 = &amp;Screen::cursor;<span class="hljs-comment">//初始化一个数据成员指针。</span>
<span class="hljs-keyword">auto</span> s1 = pScreen-&gt;*pdata1;<span class="hljs-comment">//使用数据成员指针（-&gt;*）。</span>
<span class="hljs-built_in">cout</span> &lt;&lt; s1 &lt;&lt; endl;

<span class="hljs-keyword">auto</span> pdata2 = Screen::data();
<span class="hljs-keyword">auto</span> s2 = myScreen.*pdata2;
<span class="hljs-built_in">cout</span> &lt;&lt; s2 &lt;&lt; endl;</code></pre>

<p><font size="4"><strong>2、成员函数指针</strong></font></p>

<p><font size="4" color="green">【Note】： <br>
1）使用指向成员函数的指针时，在解引用完成之后需要加一对小括号，在其之前的括号也是必须的，另外还可以传入实参：char c = (MyScreen.*P) (0,0)，指向成员函数的一个指针 <br>
2）由于有时指向成员函数的指针较为复杂，我们可以使用类型别名来简化处理：using Action = char (Screen::*p) (Screen::pos，Screen::pos) const;  Action的类型就是指向成员函数的指针。</font></p>

<p>  <font size="4">成员函数表，保存自身函数的指针，为private，组成一个数组，有时会比较有用：</font></p>

<pre class="prettyprint"><code class=" hljs autohotkey">//初始化函数表。
<span class="hljs-label">Screen::Action Screen::</span>Menu[] = 
{
<span class="hljs-label">    &amp;Screen::</span>home,
<span class="hljs-label">    &amp;Screen::</span>left,
<span class="hljs-label">    &amp;Screen::</span>right,
<span class="hljs-label">    &amp;Screen::</span>up,
<span class="hljs-label">    &amp;Screen::</span>down
}<span class="hljs-comment">;</span></code></pre>

<p>  <font size="4">因为成员指针不是可调用对象，所以我们不能直接将一个指向成员函数的指针传递给算法，若想从指向成员函数的指针获取可调用对象的一种方法是使用标准库模版function，头文件为functional，标准库功能mem_fn让编译器负责推断成员的类型。</font></p>

<p><font size="4"><strong>3、本节demo：</strong></font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;functional&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> Screen
{
 <span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> pos = <span class="hljs-built_in">string</span>::size_type;
    Screen(<span class="hljs-built_in">string</span> s, pos p) : contents(s), cursor(p) { }
    ~Screen() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">char</span> get_cursor() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> contents[cursor]; }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> Screen::*data()<span class="hljs-comment">//定义一个函数。</span>
    {
        <span class="hljs-keyword">return</span> &amp;Screen::contents;
    }
    pos cursor;<span class="hljs-comment">//公有成员。</span>

    <span class="hljs-comment">//这些函数均不接受任何参数，并且都返回类的引用。</span>
    Screen&amp; home() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"home"</span> &lt;&lt; endl; }
    Screen&amp; left() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"left"</span> &lt;&lt; endl; }
    Screen&amp; right() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"right"</span> &lt;&lt; endl; }
    Screen&amp; up() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"up"</span> &lt;&lt; endl; }
    Screen&amp; down() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"down"</span> &lt;&lt; endl; }

    <span class="hljs-keyword">using</span> Action = Screen&amp; (Screen::*)();<span class="hljs-comment">//声明成员函数指针。</span>
    <span class="hljs-comment">//定义枚举类型，默认从零开始。</span>
    <span class="hljs-keyword">enum</span> Directions
    {
        HOME, LEFT, RIGHT, UP, DOWN
    };

    Screen&amp; move(Directions cm)
    {
        <span class="hljs-comment">//运行this对象中索引值为cm的元素，Menu[cm]指向一个成员函数。</span>
        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>-&gt;*Menu[cm])();
    }

 <span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> contents;<span class="hljs-comment">//私有成员无法访问，因此声明为公有或者定义一个函数。</span>

    <span class="hljs-keyword">static</span> Action Menu[];<span class="hljs-comment">//定义函数表。</span>
};

<span class="hljs-comment">//初始化函数表。</span>
Screen::Action Screen::Menu[] = 
{
    &amp;Screen::home,
    &amp;Screen::left,
    &amp;Screen::right,
    &amp;Screen::up,
    &amp;Screen::down
};

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-comment">//数据成员指针：</span>
    Screen myScreen(<span class="hljs-string">"abc"</span>, <span class="hljs-number">1</span>), *pScreen = &amp;myScreen;
    <span class="hljs-keyword">auto</span> pdata1 = &amp;Screen::cursor;<span class="hljs-comment">//初始化一个数据成员指针。</span>
    <span class="hljs-keyword">auto</span> s1 = pScreen-&gt;*pdata1;<span class="hljs-comment">//使用数据成员指针（-&gt;*）。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; s1 &lt;&lt; endl;

    <span class="hljs-keyword">auto</span> pdata2 = Screen::data();
    <span class="hljs-keyword">auto</span> s2 = myScreen.*pdata2;
    <span class="hljs-built_in">cout</span> &lt;&lt; s2 &lt;&lt; endl;


    <span class="hljs-comment">//成员函数指针：</span>
    <span class="hljs-keyword">auto</span> pdata3 = &amp;Screen::get_cursor;<span class="hljs-comment">//初始化成员函数指针。</span>
    <span class="hljs-keyword">auto</span> s3 = (pScreen-&gt;*pdata3)();<span class="hljs-comment">//使用成员函数指针。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; s3 &lt;&lt; endl;

    myScreen.move(Screen::HOME);
    myScreen.move(Screen::LEFT);


    <span class="hljs-comment">//将成员函数用作可调用对象：</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> svec = {<span class="hljs-string">"ABC"</span>,<span class="hljs-string">"EDF"</span>};
    <span class="hljs-keyword">auto</span> f = mem_fn(&amp;<span class="hljs-built_in">string</span>::empty);<span class="hljs-comment">//使用mem_fn让编译器负责推断成员的类型。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; f(*svec.begin()) &lt;&lt; endl;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201203146974?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="5"><strong>五、union：一种节省空间的类</strong></font></p>

<p>  <font size="4" color="red">union是一种特殊的类，可以包含多个数据成员，但是在任意时刻只能有一个数据成员可以有值，其他成员属于未定义的状态，分配给union的内存只要能存储它的最大数据成员即可。</font></p>

<p>  <font size="4" color="blue">union中不能含有引用类型的成员，但不可继承、不含有虚函数。</font></p>

<p>  <font size="4">union的名字就相当于一个类型名，可以使用一对花括号显式初始化。 <br>
  <font size="4">匿名的union，没有名字，其中的成员可以直接访问，匿名union不能包含受保护成员和私有成员，也不能包含成员函数。</font></font></p>

<p>  <font size="4" color="green">我们通常将含有类类型成员的union内嵌在另一个类之中，将其定义为匿名union，将自身类类型成员的控制权转移给该类。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;    </span>
<span class="hljs-preprocessor">#include &lt;string&gt;    </span>
<span class="hljs-preprocessor">#include &lt;utility&gt;   </span>

<span class="hljs-keyword">class</span> Token 
{    
    <span class="hljs-keyword">enum</span> { INT, CHAR, DBL, STR} tok;    

    <span class="hljs-keyword">union</span> 
    {    
        <span class="hljs-keyword">char</span> cval;    
        <span class="hljs-keyword">int</span> ival;    
        <span class="hljs-keyword">double</span> dval;    
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> sval;        
    };    

    <span class="hljs-keyword">void</span> copyUnion(<span class="hljs-keyword">const</span> Token &amp;t)
    {    
        <span class="hljs-keyword">switch</span> (t.tok) 
        {    
          <span class="hljs-keyword">case</span> INT: ival = t.ival;    
            <span class="hljs-keyword">break</span>;    
          <span class="hljs-keyword">case</span> CHAR:cval = t.cval;    
            <span class="hljs-keyword">break</span>;    
          <span class="hljs-keyword">case</span> DBL:dval = t.dval;    
            <span class="hljs-keyword">break</span>;    
          <span class="hljs-keyword">case</span> STR:<span class="hljs-keyword">new</span>(&amp;sval) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(t.sval);    
            <span class="hljs-keyword">break</span>;    
        }    
    }    

    <span class="hljs-keyword">void</span> moveUnion(Token &amp;&amp;t) 
    {
        <span class="hljs-keyword">switch</span> (t.tok) 
        {    
          <span class="hljs-keyword">case</span> INT:    
            ival = <span class="hljs-built_in">std</span>::move(t.ival);    
            <span class="hljs-keyword">break</span>;    
          <span class="hljs-keyword">case</span> CHAR:    
            cval = <span class="hljs-built_in">std</span>::move(t.cval);    
            <span class="hljs-keyword">break</span>;    
          <span class="hljs-keyword">case</span> DBL:    
            dval = <span class="hljs-built_in">std</span>::move(t.dval);    
            <span class="hljs-keyword">break</span>;    
          <span class="hljs-keyword">case</span> STR:    
            <span class="hljs-keyword">new</span>(&amp;sval) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(<span class="hljs-built_in">std</span>::move(t.sval));    
            <span class="hljs-keyword">break</span>;    
        }    
    }    

    <span class="hljs-keyword">void</span> <span class="hljs-built_in">free</span>() 
    {    
        <span class="hljs-keyword">if</span> (tok == STR)    
            sval.<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::~<span class="hljs-built_in">string</span>();    
    }    
<span class="hljs-keyword">public</span>:
    Token() :tok(INT), ival{ <span class="hljs-number">0</span> } {};    
    Token(<span class="hljs-keyword">const</span> Token &amp;t) :tok(t.tok) { copyUnion(t); }    
    Token(Token &amp;&amp;t) :tok(<span class="hljs-built_in">std</span>::move(t.tok)) 
    {
        moveUnion(<span class="hljs-built_in">std</span>::move(t));    
    }    
    Token &amp;<span class="hljs-keyword">operator</span>=(Token &amp;&amp;t)
    {   
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;t)
        {    
            <span class="hljs-built_in">free</span>();    
            moveUnion(<span class="hljs-built_in">std</span>::move(t));    
            tok = <span class="hljs-built_in">std</span>::move(t.tok);    
        }    
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    
    }    

    Token &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Token &amp;t) <span class="hljs-comment">//赋值运算符处理三种情况：左右都是string、左右都不是、只有一个是。</span>
    {    
        <span class="hljs-keyword">if</span> (tok == STR &amp;&amp; t.tok != STR) sval.<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::~<span class="hljs-built_in">string</span>();    
        <span class="hljs-keyword">if</span> (tok == STR &amp;&amp; t.tok == STR)    
            sval = t.sval;     
        <span class="hljs-keyword">else</span>    
            copyUnion(t);    
        tok = t.tok;    
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    
    }    

    ~Token() 
    {    
        <span class="hljs-keyword">if</span> (tok == STR) <span class="hljs-comment">//当前是string类型，要调用string的析构函数。</span>
            sval.<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>::~<span class="hljs-built_in">string</span>();
    }    

    Token &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s) 
    {    
        <span class="hljs-built_in">free</span>();    
        <span class="hljs-keyword">new</span>(&amp;sval) <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(s);<span class="hljs-comment">//使用定位new表达式构造一个string。</span>
        tok = STR;    
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    
    }    

    Token &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">char</span> c) 
    {    
        <span class="hljs-built_in">free</span>();    
        cval = c;    
        tok = CHAR;    
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    
    }    

    Token &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">int</span> i) 
    {    
        <span class="hljs-built_in">free</span>();    
        ival = i;    
        tok = INT;    
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    
    }    

    Token &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">double</span> d) 
    {    
        <span class="hljs-built_in">free</span>();    
        dval = d;    
        tok = DBL;    
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    
    }    

    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> Token &amp;t) 
    {    
        <span class="hljs-keyword">switch</span> (t.tok) 
        {    
            <span class="hljs-keyword">case</span> Token::INT: os &lt;&lt; t.ival; <span class="hljs-keyword">break</span>;    
            <span class="hljs-keyword">case</span> Token::CHAR: os &lt;&lt; t.cval; <span class="hljs-keyword">break</span>;    
            <span class="hljs-keyword">case</span> Token::DBL: os &lt;&lt; t.dval; <span class="hljs-keyword">break</span>;    
            <span class="hljs-keyword">case</span> Token::STR: os &lt;&lt; t.sval; <span class="hljs-keyword">break</span>;    
        }    
        <span class="hljs-keyword">return</span> os;    
    }    

};    

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">"string"</span>;    
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">12</span>;    
    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'c'</span>;    
    <span class="hljs-keyword">double</span> d = <span class="hljs-number">1.28</span>;    
    Token t;    
    t = i;    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">"\n"</span>;    
    t = c;    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">"\n"</span>;    
    t = d;    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">"\n"</span>;    
    t = s;    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">"\n"</span>;    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201203616814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/02/01 20:37:48 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79233070">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79233070                    </div>
                    <div>
                        阅读：24                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]用于大型程序的工具]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79232477</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79232477</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/02/01 19:41:14</pubDate>
                <description>
                    <![CDATA[
                    <p><font size="5"><strong>一、异常处理</strong></font></p>

<p><font size="4"><strong>1、抛出异常</strong></font></p>

<p>  <font size="4">C++通过抛出一个表达式来引发一个异常，throw之后的代码将不会被执行，程序控制权将从throw转移到与之匹配的catch模块（即捕获）（若try语句块还有嵌套，将继续在外层中寻找，称为栈展开），执行完这个catch语句之后，将转移到try块关联的最后一个catch子句之后的点，并从这里继续执行，若找不到与之匹配的catch语句，程序将调用标准库的terminate函数终止程序。 <br>
  <font size="4">栈展开的过程中对象会被自动销毁（所在块中创建的对象），若是类类型，该对象的析构函数将会自动执行。 <br>
<font size="4" color="green">【Note】： <br>
1）一个异常如果没有被捕获，则它将终止当前的程序。 <br>
2）析构函数总会执行，但是函数中负责释放资源的代码可能会被跳过（异常发生在负责释放资源的代码之前），但是类分配的对象无论函数正常结束还是遭遇异常，通过析构函数其资源都能够被正常释放（由于是自动执行的，所以析构函数中不应该抛出异常）。</font></font></font></p>

<p>  <font size="4">throw抛出的表达式类型必须具有完全类型（如若是一个类，必须有完整的定义，不能仅仅只有声明）。 <br>
  <font size="4">throw的抛出表达式若是一个指向局部对象的指针，那么肯定是错误的，因为其指向的内存会被释放，就类似于函数不能返回局部对象的指针一样（该块catch语句之前已经退出，对象已经被销毁）。 <br>
  <font size="4">throw抛出的表达式是其静态编译的类型，也就是静态类型，所以不会发生动态绑定，若throw表达式解引用一个基类（基类的类型）指针，该指针指向的是派生类对象，则抛出的对象会被切除其派生类的部分。</font></font></font></p>

<p><font size="4"><strong>2、捕获异常</strong></font></p>

<p><font size="4" color="green">【Note】： <br>
1）catch子句中的异常声明看起来像是函数的形参列表，但是这个类型必须是完全类型，不能是右值引用。若其参数类型是非引用，则会传入一份异常对象的副本，若是引用，则是该对象的别名。 <br>
2）若干个catch语句的类型之间存在这继承关系，应该将继承链的最低端的类放在前面 <br>
3）捕获所有异常的处理代码：catch（…）可以与任何类型的异常匹配，左一该语句必须放在catch列表的最后位置</font></p>

<p>  <font size="4">catch语句通过重新抛出的操作将异常传递给另外一个catch，只需要在其体内加 throw；通常情况下是因为catch语句需要改变其参数的内容，并想继续传播。</font></p>

<p><font size="4"><strong>3、函数try语句块与构造函数</strong></font></p>

<p>  <font size="4">由于构造函数在其进入函数体之前进行初始化（执行初始化列表），所以此时的try语句块还未生效，所以构造函数体内的catch语句无法处理构造函数初始值列表抛出的异常，这是就需要构造函数try语句块的形式，即将初始值列表置于try语句块中（try语句块出现在：冒号之后以及函数体的花括号之前）。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  
Blob&lt;T&gt;::Blob() <span class="hljs-keyword">try</span>:data(<span class="hljs-built_in">std</span>::make_shared&lt;<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>&gt;()) {  
}  
<span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::bad_alloc &amp;e) {  
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="hljs-built_in">std</span>::endl;  
}  </code></pre>

<p><font size="4"><strong>4、noexcep异常说明（C++11）</strong></font></p>

<p>  <font size="4">noexcep异常说明可以用来指定某个函数不会抛出异常（C++11新特性），声明和定义时皆需要出现在函数之后，但在final、override、=0之前。 <br>
  <font size="4" color="blue">noexcept用于两种情况：</font> <br>
<font size="4"> <br>
 - 确认函数不会抛出异常 。 <br>
 - 我们不知道如何处理异常。 <br>
  <font size="4">异常说明还可以有实参，为bool类型，为true时，则函数不会抛出异常，为false时会抛出异常。 <br>
  <font size="4" color="red">noexcept还可以作为运算符来使用，当其不跟在函数参数列表之后时，返回值是一个bool的常量表达式，为true时，表明传入参数会抛出异常。</font> <br>
  <font size="4">exception表示的含义是某处出错，但错误细节未知，what是一个虚函数，所以引用捕获时会发生动态绑定。</font></font></font></font></p>

<p><font size="4"><strong>5、本节demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;exception&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> MyError
{
<span class="hljs-keyword">public</span>:
    MyError(<span class="hljs-built_in">string</span> err):error(err) { }
    <span class="hljs-built_in">string</span> what(){ <span class="hljs-keyword">return</span> error; }
    ~MyError() <span class="hljs-keyword">throw</span>(){}
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> error;
};

<span class="hljs-keyword">void</span> funCall(){
    <span class="hljs-keyword">throw</span> MyError(<span class="hljs-string">"zhainankl"</span>);
}

<span class="hljs-keyword">int</span> main(){
    <span class="hljs-keyword">try</span>
    {
        funCall();
    }
    <span class="hljs-keyword">catch</span>(MyError &amp;e)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"MyError e:"</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; e.what() &lt;&lt; endl;
    }
    <span class="hljs-keyword">catch</span>(...)
    {
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"..."</span>&lt;&lt;endl;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201190634598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="5"><strong>二、命名空间</strong></font></p>

<p>  <font size="4">传统意义上，可以将全局定义的实体名字定义的很长以避免<font size="4" color="red">命名空间污染</font>，这样的名字通常将其名字所属的库作为前缀，但比较费时费力。命名空间可以更好的防止名字冲突，且避免全局名字的固有限制。</font></p>

<p><font size="4"><strong>1、命名空间定义</strong></font></p>

<p>  <font size="4">namespace后加命名空间的名字，加上一对花括号就是一个完整的命名空间<font size="4" color="red">（注意花括号后无需加分号）</font>，只要能出现于全局作用域中的声明就能置于命名空间内，主要包括：类、变量（初始化操作）、函数（）声明和定义、模版、命名空间，命名空间不能定义与函数和类的内部。 <br>
  <font size="4">在一个命名空间内，不允许存在同名成员，其名字可以被空间内的其他成员直接访问（包括内嵌的作用域），位于命名空间之外的代码必须指明所用名字所属的命名空间。命名空间可以不连续，可以随时打开进行添加操作，另外可以将声明和定义分离开来。 <br>
<font size="4" color="green">【Note】： <br>
1）定义包含多个不相关类型的命名空间应该使用单独的文件分别表示每个类型，我们可以将一个库定义在几个不同的文件中，不同的类、变量、函数分别放在不同的文件中。注意不要将#include放在命名空间的内部。 <br>
2）可以在命名空间的内部和外部定义成员，但是外部定义必须加上前缀指出所属的命名空间。虽然其定义可以放在外部，但是必须定义在所属空间的外层空间，在另一个不相关文件中定义是不被允许的。 <br>
3）模版特例化必须定义在原始模版所属的命名空间中，只要在内部声明，可以在外部定义。</font></font></font></p>

<p>  <font size="4">命名空间可以嵌套，访问时需加多重限定符。 <br>
  <font size="4">namespace之后不加名字，为未命名的命名空间，其中的变量拥有静态的生命周期，程序结束时才被销毁，但是不可以跨文件进行定义，其中的成员可以直接使用。当然，未命名的命名空间也可以嵌套在其他命名空间中，此时可以通过外层的命名空间名加以访问。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">// 第一个命名空间</span>
<span class="hljs-keyword">namespace</span> first_space
{
   <span class="hljs-keyword">void</span> func()
   {
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside first_space"</span> &lt;&lt; endl;
   }
}
<span class="hljs-comment">// 第二个命名空间</span>
<span class="hljs-keyword">namespace</span> second_space
{
   <span class="hljs-keyword">void</span> func()
   {
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside second_space"</span> &lt;&lt; endl;
   }
}

<span class="hljs-comment">// 第一个命名空间。</span>
<span class="hljs-keyword">namespace</span> first_space2
{
   <span class="hljs-keyword">void</span> func()
   {
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside first_space"</span> &lt;&lt; endl;
   }
   <span class="hljs-comment">// 第二个命名空间。</span>
   <span class="hljs-keyword">namespace</span> second_space<span class="hljs-comment">//命名空间嵌套。</span>
   {
      <span class="hljs-keyword">void</span> func()
      {
         <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside second_space"</span> &lt;&lt; endl;
      }
   }
}</code></pre>

<p><font size="4"><strong>2、使用命名空间成员</strong></font></p>

<p>  <font size="4">命名空间别名，namespace MM = mathLib::MatrixLib，就可以用MM来代替了。一个命名空间可以由多个别名，所有别名等价。 <br>
  <font size="4" color="red">using声明：</font>一次只能引入命名空间的一个成员，其有效范围从using声明开始，到using声明所在的作用域结束为止。例如：using std::cout。 <br>
  <font size="4" color="red">using指示：</font>与using声明类似，也可以使用其简写模式，例如：using namespace XX，将XX命名空间的所有成员变成可见，作用域和using声明一致。using指示一般被看作是出现在最近的外层作用域中，若有同名冲突成员，应加限定符予以区分。 <br>
  <font size="4" color="red">要避免using指示。</font></font></p>

<p><font size="4"><strong>3、本节demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//using指示。</span>

<span class="hljs-comment">// 第一个命名空间</span>
<span class="hljs-keyword">namespace</span> first_space
{
   <span class="hljs-keyword">void</span> func()
   {
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside first_space"</span> &lt;&lt; endl;
   }
}
<span class="hljs-comment">// 第二个命名空间</span>
<span class="hljs-keyword">namespace</span> second_space
{
   <span class="hljs-keyword">void</span> func()
   {
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside second_space"</span> &lt;&lt; endl;
   }
}

<span class="hljs-comment">// 第一个命名空间。</span>
<span class="hljs-keyword">namespace</span> first_space2
{
   <span class="hljs-keyword">void</span> func()
   {
      <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside first_space"</span> &lt;&lt; endl;
   }
   <span class="hljs-comment">// 第二个命名空间。</span>
   <span class="hljs-keyword">namespace</span> second_space<span class="hljs-comment">//命名空间嵌套。</span>
   {
      <span class="hljs-keyword">void</span> func()
      {
         <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Inside second_space"</span> &lt;&lt; endl;
      }
   }
}

<span class="hljs-keyword">using</span>  first_space2::second_space::func;<span class="hljs-comment">//using声明。</span>
<span class="hljs-keyword">int</span> main ()
{

   <span class="hljs-comment">// 调用第一个命名空间中的函数。</span>
   first_space::func();

   <span class="hljs-comment">// 调用第二个命名空间中的函数。</span>
   second_space::func(); 

   func();

   system(<span class="hljs-string">"pause"</span>);
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201192109672?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="5"><strong>3、多重继承与虚继承</strong></font></p>

<p><font size="4"><strong>1、多重继承</strong></font></p>

<p>  <font size="4" color="blue">多重继承是指从多个基类中产生派生类的情况，多重继承的派生类继承了所有父类的属性。</font> <br>
  <font size="4" color="red">构造一个派生类对象时将会同时构造并初始化它所有的基类子对象，如若不是显示初始化，则其会使用基类的默认构造函数进行初始化，基类的构造顺序与派生类列标准基类出现的顺序一致。</font> <br>
  <font size="4">C++11新标准，派生类可以从其基类中继承构造函数，但是若从所个基类中继承了相同的构造函数（形参列表完全相同的情况），就会发生错误，此时该<font size="4" color="green">派生类应该为它自己定义一个形参列表相同的构造函数。</font> <br>
  <font size="4" color="red">析构函数执行的顺序与构造函数相反，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。</font></font></p>

<p><font size="4"><strong>2、类型转换与多个基类</strong></font></p>

<p>  <font size="4">可以令某个可访问基类的指针或引用直接指向一个派生类对象，但该指针只能访问其对应的基类部分或者基类的基类部分。 <br>
  <font size="4">当一个类拥有多个基类时，有可能从多个类中继承了同名成员的情况，此时需要加上前缀限定符，避免二义性最好的办法是在派生类中为该成员定义一个新的版本。</font></font></p>

<p><font size="4"><strong>3、多重继承demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;  </span>
<span class="hljs-preprocessor">#include &lt;string&gt;  </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  
<span class="hljs-keyword">class</span> Worker
{
<span class="hljs-keyword">public</span>:
    Worker(<span class="hljs-built_in">string</span> code = <span class="hljs-string">"wk"</span>)
    {
        m_strCode = code;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Worker()"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> ~Worker()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~Worker()"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">void</span> carry()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; m_strCode &lt;&lt; endl;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Worker-carry()"</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">string</span> m_strCode;
};

<span class="hljs-keyword">class</span> Farmer
{
<span class="hljs-keyword">public</span>:
    Farmer(<span class="hljs-built_in">string</span> name = <span class="hljs-string">"fa"</span>)
    {
        m_strName = name;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Farmer()"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> ~Farmer()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~Farmer()"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">void</span> sow()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; m_strName &lt;&lt; endl;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Farmer-sow()"</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">string</span> m_strName;

};

<span class="hljs-keyword">class</span> MigrantWorker  : <span class="hljs-keyword">public</span> Farmer, <span class="hljs-keyword">public</span> Worker<span class="hljs-comment">//构造函数执行的顺序和声明的顺序一致。</span>
{
<span class="hljs-keyword">public</span>:
    MigrantWorker(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> code): Worker(code), Farmer(name)<span class="hljs-comment">//列表初始化，向下构造。</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"MigrantWorker"</span> &lt;&lt; endl;
    }
    ~MigrantWorker()<span class="hljs-comment">//向上析构。</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~MigrantWorker()"</span> &lt;&lt; endl;
    }

};

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    MigrantWorker *p = <span class="hljs-keyword">new</span> MigrantWorker(<span class="hljs-string">"jack"</span>,<span class="hljs-string">"100"</span>);
    p-&gt;carry();
    p-&gt;sow();
    <span class="hljs-keyword">delete</span> p;
    p =  <span class="hljs-keyword">nullptr</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201193028448?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="4"><strong>4、虚继承</strong></font></p>

<p>  <font size="4" color="red">虚继承的目的是令某个类做出声明，承诺愿意共享它的基类，共享的基类子对象称为及虚基类，在此情况下，无论虚基类在集成体系中出现多少次，派生类中都只包含唯一一个共享的虚基类对象。</font></p>

<p>  <font size="4" color="blue">虚继承主要解决的是菱形继承问题。对于菱形继承，使用虚继承的好处在于避免重复拷贝最上层的父类。</font></p>

<p><font size="4" color="green">【Note】： <br>
1）虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。 <br>
2）虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</font> <br>
  <font size="4">只要我们能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。 <br>
  <font size="4">首先用最底层派生类的构造函数的初始值初始化该对象的虚基类子部分，虚基类优先构造，析构函数执行顺序与构造函数相反。</font></font></p>

<p><font size="4"><strong>5、虚继承demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;  </span>
<span class="hljs-preprocessor">#include &lt;string&gt;  </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  
<span class="hljs-comment">//对于菱形继承，使用虚继承的好处在于避免重复拷贝最上层的父类。</span>
<span class="hljs-keyword">class</span> Person
{
<span class="hljs-keyword">public</span>:
    Person(<span class="hljs-built_in">string</span> color = <span class="hljs-string">"blue"</span>)
    {
        m_strColor = color;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Person()"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> ~Person()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~Person()"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">void</span> printColor()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; m_strColor &lt;&lt; endl;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Person-printColor()"</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">string</span> m_strColor;
};

<span class="hljs-keyword">class</span> Worker : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Person<span class="hljs-comment">//虚继承。</span>
{
<span class="hljs-keyword">public</span>:
    Worker(<span class="hljs-built_in">string</span> code = <span class="hljs-string">"wk"</span>, <span class="hljs-built_in">string</span> color = <span class="hljs-string">"blue"</span>) : Person(color)
    {
        m_strCode = code;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Worker()"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> ~Worker()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~Worker()"</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">string</span> m_strCode;
};

<span class="hljs-keyword">class</span> Farmer : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Person<span class="hljs-comment">//虚继承。</span>
{
<span class="hljs-keyword">public</span>:
    Farmer(<span class="hljs-built_in">string</span> name = <span class="hljs-string">"fa"</span>, <span class="hljs-built_in">string</span> color = <span class="hljs-string">"blue"</span>) : Person(color)
    {
        m_strName = name;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Farmer()"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">virtual</span> ~Farmer()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~Farmer()"</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">string</span> m_strName;

};

<span class="hljs-keyword">class</span> MigrantWorker  : <span class="hljs-keyword">public</span> Farmer, <span class="hljs-keyword">public</span> Worker
{
<span class="hljs-keyword">public</span>:
    MigrantWorker(<span class="hljs-built_in">string</span> name, <span class="hljs-built_in">string</span> code, <span class="hljs-built_in">string</span> color): 
                  Worker(code, color), Farmer(name, color)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"MigrantWorker"</span> &lt;&lt; endl;
    }
    ~MigrantWorker()
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~MigrantWorker()"</span> &lt;&lt; endl;
    }

};

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    MigrantWorker *p = <span class="hljs-keyword">new</span> MigrantWorker(<span class="hljs-string">"jack"</span>,<span class="hljs-string">"100"</span>, <span class="hljs-string">"yellow"</span>);
    p-&gt;Farmer::printColor();<span class="hljs-comment">//使用前缀限定符避免发生二义性。</span>
    p-&gt;Worker::printColor();
    <span class="hljs-keyword">delete</span> p;
    p =  <span class="hljs-keyword">nullptr</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201194015043?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/02/01 19:41:14 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79232477">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79232477                    </div>
                    <div>
                        阅读：31                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]标准库特殊设施]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79231317</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79231317</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/02/01 17:31:01</pubDate>
                <description>
                    <![CDATA[
                    <p><font size="5"><strong>一、tuple类型</strong></font></p>

<p>  <font size="4">tuple是类似pair的模板。每个pair的成员类型都不同，但每个pair都恰好有两个成员。不同tuple类型的成员类型也不相同，但一个tuple可以有任意数量的成员。每个确定的tuple类型的成员数目是固定的，但一个tuple类型的成员数目可以与另一个tuple类型不同。 <br>
  <font size="4" color="red">当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，tuple是非常有用的。</font> <br>
tuple支持的操作： <br>
<img src="http://img.blog.csdn.net/20180201163014796?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

tuple&lt;<span class="hljs-keyword">int</span>, <span class="hljs-built_in">string</span>&gt; foo()<span class="hljs-comment">//函数foo返回tuple类型。</span>
{
    <span class="hljs-keyword">return</span> make_tuple(<span class="hljs-number">2014</span>, <span class="hljs-string">"tuple"</span>);<span class="hljs-comment">//用make_tuple来构造一个tuple。 </span>
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{

    <span class="hljs-comment">/******************
    *定义和初始化tuple。
    *******************/</span>

    tuple&lt;<span class="hljs-built_in">string</span>, <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;</span>, pair&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt;&gt; item(<span class="hljs-string">"abc"</span>, {<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>}, {<span class="hljs-string">"ABC"</span>, <span class="hljs-number">3</span>});
    <span class="hljs-comment">//用get访问tuple数据成员，返回第三个成员pair类型的第一个元素。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; get&lt;<span class="hljs-number">2</span>&gt;(item).first &lt;&lt; endl; 

    <span class="hljs-comment">//访问tuple成员：</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; 
    <span class="hljs-keyword">int</span> b[<span class="hljs-number">3</span>];                        
    <span class="hljs-keyword">auto</span> item2 = make_tuple(a,b);<span class="hljs-comment">// tuple &lt; int, int* &gt;</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; get&lt;<span class="hljs-number">0</span>&gt;(item2) &lt;&lt; endl;  

    <span class="hljs-comment">//关系和相等运算符：</span>
    <span class="hljs-comment">//逐个比较元素，元素的数量和类型必须一致。</span>
    tuple&lt;size_t, size_t&gt; item3_1(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);
    tuple&lt;size_t, size_t&gt; item3_2(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; (item3_1 &lt; item3_2) &lt;&lt; endl;

    <span class="hljs-comment">/********************
    *使用tuple返回多个值。
    *********************/</span>

    <span class="hljs-keyword">int</span> a2;  
    <span class="hljs-built_in">string</span> b2;  
    <span class="hljs-comment">//通过std::tie解包tuple。</span>
    tie(a2, b2) = foo(); 
    <span class="hljs-built_in">cout</span> &lt;&lt; a2 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; b2 &lt;&lt; endl;

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201164322005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="5"><strong>二、bitset类型</strong></font></p>

<p>  <font size="4">初始化bitset的方法： <br>
<img src="http://img.blog.csdn.net/20180201165315704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">//非类型模板参数。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">unsigned</span> N&gt;
<span class="hljs-keyword">class</span> bits
{
<span class="hljs-keyword">public</span>:
    bits() = <span class="hljs-keyword">default</span>;
    bits(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s) : bit(s) { }
    ~bits() =<span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> updata(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> b)
    {
        bit.<span class="hljs-built_in">set</span>(s, b);
    }

    <span class="hljs-comment">//为了让实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> M&gt;
    <span class="hljs-keyword">friend</span> size_t text(<span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;lb, <span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;rb);  
    <span class="hljs-comment">//重载输出操作符。</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> M&gt;  
    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;b);  

<span class="hljs-keyword">private</span>:
    <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span> bit;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> M&gt;
size_t text(<span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;lb, <span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;rb)
{
    <span class="hljs-keyword">auto</span> temp = lb.bit ^ rb.bit;<span class="hljs-comment">//使用亦或操作。</span>
    <span class="hljs-keyword">return</span> temp.count();<span class="hljs-comment">//计算同一位置上数字不同的有多少个。</span>
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> M&gt;  
<span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;b)  
{  
    os &lt;&lt; b.bit;  
    <span class="hljs-keyword">return</span> os;  
}  

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;4&gt;</span> bit1(<span class="hljs-number">10</span>);
    <span class="hljs-comment">//比初始值大则高位补零，小则高位被丢弃。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; bit1 &lt;&lt; endl;

    <span class="hljs-comment">/***********************
    *使用string初始化bitset。
    ************************/</span>

    <span class="hljs-comment">//字符串下标最小的字符对应高位。</span>
    <span class="hljs-built_in">string</span> str(<span class="hljs-string">"11010011"</span>);
    <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;10&gt;</span> bit2_1(str);
    <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;10&gt;</span> bit2_2(str, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//从str[1]开始的三个字符。</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;10&gt;</span> bit2_3(str, str.size()-<span class="hljs-number">2</span>);<span class="hljs-comment">//使用最后两个字符。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; bit2_1 &lt;&lt; endl &lt;&lt; bit2_2 &lt;&lt; endl &lt;&lt; bit2_3 &lt;&lt; endl;

    <span class="hljs-comment">/***********
    *bitset操作。
    ************/</span>
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;
    <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;10&gt;</span> bit3(a);
    <span class="hljs-built_in">cout</span> &lt;&lt; bit3 &lt;&lt; endl;
    <span class="hljs-comment">//计算位数和置位的位数（1的个数）。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; bit3.size() &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; bit3.count() &lt;&lt; endl;
    bit3.<span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//把最低位设为1。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; bit3 &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; bit3.to_ulong() &lt;&lt; endl;<span class="hljs-comment">//提取bitset的值。</span>


    bits&lt;<span class="hljs-number">10</span>&gt; bit4_1(<span class="hljs-string">"1010101101"</span>);
    bits&lt;<span class="hljs-number">10</span>&gt; bit4_2(<span class="hljs-string">"1110001111"</span>);
    bit4_2.updata(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//更新低位的值。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; text(bit4_1, bit4_2) &lt;&lt; endl;


    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201165934410?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p>  <font size="4" color="red">bitset的应用：</font> <br>
  <font size="4" color="green">（1）海量数据排序：</font> <br>
  <font size="4">某区有7位电话号码若干（千万级别），要求对其排序，占用内存要求在1MB左右。大概算一下，8位电话号码也就是0000000-9999999，数值一共不到1千万吧，用unsigned即可。那么加载进内存越为4*10000000字节，约等于40MB，如果我们用排序只能用归并排序了，至少也40次了吧，先不说次数多少，就磁盘IO来说就慢的不行了。 <br>
  <font size="4">此时可以考虑bitset了，既然电话号码是连续的且不重复的，我们可以用bitset的bit下标来表示电话号码，比如1234567，就是bit[1234567]。那么好办了， <br>
  <font size="4">首先计算一下bitset需要的大概40MB/32，也就是1MB左右，复合情况，我们可以直接遍历一遍，存在的号码S我们设置b[S]位为1，不存在则为0。那么输出排序直接遍历bitset即可。节省空间且速度快。 <br>
  <font size="4" color="green">（2）海量数据找不重复数：</font> <br>
  <font size="4">2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。这次用两个位表示一个数，00表示未出现过，01表示出现了1次，11表示出现重复了。遍历即可。</font></font></font></font></p>

<p><font size="5"><strong>三、 正则表达式</strong></font></p>

<p>  <font size="4" color="red">正则表达式是一种描述字符序列的方法，是一种极其强大的计算工具。</font> <br>
  <font size="4">正则表达式库组件： <br>
<img src="http://img.blog.csdn.net/20180201170834812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></p>

<p><font size="4"><strong>1、使用正则表达式库</strong></font></p>

<p>  <font size="4" color="green">一个正则表达式的语法是否正确是在运行时解析的。</font></p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/*****************
*使用正则表达式库。
******************/</span>

<span class="hljs-comment">//[^]表示非。</span>
string pattern1_1(<span class="hljs-string">"[^c]ei"</span>);
<span class="hljs-comment">//前后匹配任意大小写的零个或多个字母。</span>
pattern1_1 = <span class="hljs-string">"[[:alpha:]]*"</span> + pattern1_1 + <span class="hljs-string">"[[:alpha:]]*"</span>;
regex r1_1(pattern1_1);<span class="hljs-comment">//创建用于查找模式的regex。</span>
smatch result1_1;
string test_string1_1 = <span class="hljs-string">"receipt freid theif receive"</span>;
<span class="hljs-comment">//寻找第一个与正则表达式匹配的子序列，找到就停止。</span>
<span class="hljs-keyword">if</span>(regex_search(test_string1_1, result1_1, r1_1))
    cout &lt;&lt; result1_1.str() &lt;&lt; endl;

<span class="hljs-comment">/*
*$表示锚定行尾，只匹配$之前的内容。
*.表示匹配其后的任意字符。
*\\.表示去掉特殊含义，
*regex::icase指定regex对象的选项，表示在匹配过程中忽略大小写。
*正则表达式类型必须与输入类型匹配。smatch与string匹配，cmatch与char匹配。
*/</span>
<span class="hljs-keyword">try</span>
{
    regex r1_2(<span class="hljs-string">"([[:alpha:]]*)(\\.)([[:alpha:]]*)"</span>, regex::icase);
    smatch result1_2;
    string test_string1_2 = <span class="hljs-string">"abc.cpp"</span>;
    <span class="hljs-keyword">if</span>(regex_search(test_string1_2, result1_2, r1_2))
        cout &lt;&lt; result1_2.str(<span class="hljs-number">3</span>) &lt;&lt; endl;<span class="hljs-comment">//使用子表达式，打印第三个子表达式。</span>
}
<span class="hljs-keyword">catch</span> (regex_error e)
{
    <span class="hljs-comment">//what()描述错误类型，code()表示错误编码。</span>
    cout &lt;&lt; e.what() &lt;&lt; <span class="hljs-string">"\ncode: "</span> &lt;&lt; e.code() &lt;&lt; endl;
}</code></pre>

<p><font size="4"><strong>2、匹配与regex迭代器类型。</strong></font></p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**********************
*匹配与regex迭代器类型。
***********************/</span>

string pattern2(<span class="hljs-string">"[^c]ei"</span>);
pattern2 = <span class="hljs-string">"[[:alpha:]]*"</span> + pattern2 + <span class="hljs-string">"[[:alpha:]]*"</span>;
regex r2(pattern2, regex::icase);<span class="hljs-comment">//创建用于查找模式的regex。</span>
string test_string2 = <span class="hljs-string">"receipt freid abcdef theif receive"</span>;
<span class="hljs-comment">//sregex_iterator将迭代器定位到第一个匹配的位置。</span>
<span class="hljs-keyword">for</span> (sregex_iterator it2(test_string2.begin(), test_string2.end(), r2), 
                        end_it; it2 != end_it; ++it2)
<span class="hljs-comment">//打印出匹配单词的上下文。</span>
{
    auto pos = it2-&gt;prefix().length();<span class="hljs-comment">//前缀的大小。</span>
    pos = pos &gt; <span class="hljs-number">10</span> ? pos - <span class="hljs-number">6</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">//最多需要6个字符。</span>
    cout &lt;&lt; it2-&gt;prefix().str().substr(pos) &lt;&lt; <span class="hljs-comment">//前缀的最后一部分。</span>
         <span class="hljs-string">"\n\t\t&gt;&gt;&gt;"</span> &lt;&lt; it2-&gt;str() &lt;&lt; <span class="hljs-string">" &lt;&lt;&lt;\n"</span> &lt;&lt; <span class="hljs-comment">//匹配的单词。</span>
         it2-&gt;suffix().str().substr(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>) &lt;&lt; endl; <span class="hljs-comment">//后缀的第一部分。</span>
}</code></pre>

<p><font size="4"><strong>3、使用子表达式</strong></font></p>

<p>  <font size="4" color="red">子表达式通常用于数据验证。</font></p>

<p>  <font size="4" color="red">正则表达式的一些特性：</font> <br>
<font size="4"> <br>
 - \d{n}：表示一个n个数字的序列。 <br>
 - [-. ]：表示字符集合匹配这些字符中任意一个。 <br>
 - ?：表示组件是可选的。 <br>
 - \(：双斜线去掉C++中的特殊字符。 <br>
 - (\d{3})：每个字表达式用一对括号包围。</font></p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/*************
*使用子表达式。
**************/</span>

string phone = <span class="hljs-string">"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})"</span>;
regex r3(phone);
smatch result3;
string s3;
<span class="hljs-keyword">while</span> (getline(cin, s3))
{
    <span class="hljs-keyword">for</span> (sregex_iterator it3(s3.begin(), s3.end(), r3), 
         end_it; it3 != end_it; ++it3)
    {
        <span class="hljs-keyword">if</span>(valid(*it3))
            cout &lt;&lt; <span class="hljs-string">"valid: "</span> &lt;&lt; it3-&gt;str() &lt;&lt; endl;
        <span class="hljs-keyword">else</span>
            cout &lt;&lt; <span class="hljs-string">"not valid: "</span> &lt;&lt; it3-&gt;str() &lt;&lt; endl;
    }
}</code></pre>

<p><font size="4"><strong>4、使用regex_replace</strong></font></p>



<pre class="prettyprint"><code class=" hljs java">bool valid(<span class="hljs-keyword">const</span> smatch &amp;m)
{
    <span class="hljs-comment">//如果区号前有一个左括号。</span>
    <span class="hljs-keyword">if</span>(m[<span class="hljs-number">1</span>].matched)<span class="hljs-comment">//则区号后必须有右括号，之后紧跟剩余号码或者一个空格。</span>
        <span class="hljs-keyword">return</span> m[<span class="hljs-number">3</span>].matched &amp;&amp; (m[<span class="hljs-number">4</span>].matched == <span class="hljs-number">0</span> || m[<span class="hljs-number">4</span>].str() == <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">else</span><span class="hljs-comment">//否则区号后不能有右括号，另外两个分隔符必须匹配。</span>
        <span class="hljs-keyword">return</span> !m[<span class="hljs-number">3</span>].matched &amp;&amp; m[<span class="hljs-number">4</span>].str() == m[<span class="hljs-number">6</span>].str();
}

<span class="hljs-javadoc">/******************
*使用regex_replace。
*******************/</span>
string phone2 = <span class="hljs-string">"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})"</span>;
regex r4(phone2);
string s4 = <span class="hljs-string">"(908) 555-1800 862.555.0123"</span>;
string fmt = <span class="hljs-string">"$2.$5.$7 "</span>;
cout &lt;&lt; regex_replace(s4, r4, fmt, std::regex_constants::format_no_copy) &lt;&lt; endl;</code></pre>

<p><font size="4"><strong>5、本节demo：</strong></font></p>



<pre class="prettyprint"><code class=" hljs java">#include &lt;iostream&gt;
#include &lt;regex&gt;
using namespace std;

bool valid(<span class="hljs-keyword">const</span> smatch &amp;m)
{
    <span class="hljs-comment">//如果区号前有一个左括号。</span>
    <span class="hljs-keyword">if</span>(m[<span class="hljs-number">1</span>].matched)<span class="hljs-comment">//则区号后必须有右括号，之后紧跟剩余号码或者一个空格。</span>
        <span class="hljs-keyword">return</span> m[<span class="hljs-number">3</span>].matched &amp;&amp; (m[<span class="hljs-number">4</span>].matched == <span class="hljs-number">0</span> || m[<span class="hljs-number">4</span>].str() == <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">else</span><span class="hljs-comment">//否则区号后不能有右括号，另外两个分隔符必须匹配。</span>
        <span class="hljs-keyword">return</span> !m[<span class="hljs-number">3</span>].matched &amp;&amp; m[<span class="hljs-number">4</span>].str() == m[<span class="hljs-number">6</span>].str();
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{

    <span class="hljs-javadoc">/*****************
    *使用正则表达式库。
    ******************/</span>

    <span class="hljs-comment">//[^]表示非。</span>
    string pattern1_1(<span class="hljs-string">"[^c]ei"</span>);
    <span class="hljs-comment">//前后匹配任意大小写的零个或多个字母。</span>
    pattern1_1 = <span class="hljs-string">"[[:alpha:]]*"</span> + pattern1_1 + <span class="hljs-string">"[[:alpha:]]*"</span>;
    regex r1_1(pattern1_1);<span class="hljs-comment">//创建用于查找模式的regex。</span>
    smatch result1_1;
    string test_string1_1 = <span class="hljs-string">"receipt freid theif receive"</span>;
    <span class="hljs-comment">//寻找第一个与正则表达式匹配的子序列，找到就停止。</span>
    <span class="hljs-keyword">if</span>(regex_search(test_string1_1, result1_1, r1_1))
        cout &lt;&lt; result1_1.str() &lt;&lt; endl;

    <span class="hljs-comment">/*
    *$表示锚定行尾，只匹配$之前的内容。
    *.表示匹配其后的任意字符。
    *\\.表示去掉特殊含义，
    *regex::icase指定regex对象的选项，表示在匹配过程中忽略大小写。
    *正则表达式类型必须与输入类型匹配。smatch与string匹配，cmatch与char匹配。
    */</span>
    <span class="hljs-keyword">try</span>
    {
        regex r1_2(<span class="hljs-string">"([[:alpha:]]*)(\\.)([[:alpha:]]*)"</span>, regex::icase);
        smatch result1_2;
        string test_string1_2 = <span class="hljs-string">"abc.cpp"</span>;
        <span class="hljs-keyword">if</span>(regex_search(test_string1_2, result1_2, r1_2))
            cout &lt;&lt; result1_2.str(<span class="hljs-number">3</span>) &lt;&lt; endl;<span class="hljs-comment">//使用子表达式，打印第三个子表达式。</span>
    }
    <span class="hljs-keyword">catch</span> (regex_error e)
    {
        <span class="hljs-comment">//what()描述错误类型，code()表示错误编码。</span>
        cout &lt;&lt; e.what() &lt;&lt; <span class="hljs-string">"\ncode: "</span> &lt;&lt; e.code() &lt;&lt; endl;
    }

    <span class="hljs-javadoc">/**********************
    *匹配与regex迭代器类型。
    ***********************/</span>

    string pattern2(<span class="hljs-string">"[^c]ei"</span>);
    pattern2 = <span class="hljs-string">"[[:alpha:]]*"</span> + pattern2 + <span class="hljs-string">"[[:alpha:]]*"</span>;
    regex r2(pattern2, regex::icase);<span class="hljs-comment">//创建用于查找模式的regex。</span>
    string test_string2 = <span class="hljs-string">"receipt freid abcdef theif receive"</span>;
    <span class="hljs-comment">//sregex_iterator将迭代器定位到第一个匹配的位置。</span>
    <span class="hljs-keyword">for</span> (sregex_iterator it2(test_string2.begin(), test_string2.end(), r2), 
                            end_it; it2 != end_it; ++it2)
    <span class="hljs-comment">//打印出匹配单词的上下文。</span>
    {
        auto pos = it2-&gt;prefix().length();<span class="hljs-comment">//前缀的大小。</span>
        pos = pos &gt; <span class="hljs-number">10</span> ? pos - <span class="hljs-number">6</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">//最多需要6个字符。</span>
        cout &lt;&lt; it2-&gt;prefix().str().substr(pos) &lt;&lt; <span class="hljs-comment">//前缀的最后一部分。</span>
             <span class="hljs-string">"\n\t\t&gt;&gt;&gt;"</span> &lt;&lt; it2-&gt;str() &lt;&lt; <span class="hljs-string">" &lt;&lt;&lt;\n"</span> &lt;&lt; <span class="hljs-comment">//匹配的单词。</span>
             it2-&gt;suffix().str().substr(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>) &lt;&lt; endl; <span class="hljs-comment">//后缀的第一部分。</span>
    }

    <span class="hljs-javadoc">/*************
    *使用子表达式。
    **************/</span>

    string phone = <span class="hljs-string">"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})"</span>;
    regex r3(phone);
    smatch result3;
    string s3;
    <span class="hljs-keyword">while</span> (getline(cin, s3))
    {
        <span class="hljs-keyword">for</span> (sregex_iterator it3(s3.begin(), s3.end(), r3), 
             end_it; it3 != end_it; ++it3)
        {
            <span class="hljs-keyword">if</span>(valid(*it3))
                cout &lt;&lt; <span class="hljs-string">"valid: "</span> &lt;&lt; it3-&gt;str() &lt;&lt; endl;
            <span class="hljs-keyword">else</span>
                cout &lt;&lt; <span class="hljs-string">"not valid: "</span> &lt;&lt; it3-&gt;str() &lt;&lt; endl;
        }
    }

    <span class="hljs-javadoc">/******************
    *使用regex_replace。
    *******************/</span>
    string phone2 = <span class="hljs-string">"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})"</span>;
    regex r4(phone2);
    string s4 = <span class="hljs-string">"(908) 555-1800 862.555.0123"</span>;
    string fmt = <span class="hljs-string">"$2.$5.$7 "</span>;
    cout &lt;&lt; regex_replace(s4, r4, fmt, std::regex_constants::format_no_copy) &lt;&lt; endl;

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201172244015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="5"><strong>四、 随机数</strong></font></p>

<p><font size="4"><strong>1、随机数简介：</strong></font></p>

<p>  <font size="4">随机数库的组成： <br>
引擎类型：生成随机unsigned整数序列 <br>
分布类型：使用引擎返回服从特定概率分布的随机数。 <br>
  <font size="4">随机数引擎操作： <br>
<img src="http://img.blog.csdn.net/20180201172533218?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
  <font size="4">分布类型的操作： <br>
<img src="http://img.blog.csdn.net/20180201172657283?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;random&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span>&gt;</span> bad_randvec()
{
    <span class="hljs-comment">//将引擎和分布对象都定义为static，从而避免每次都生成相同的序列。</span>
    <span class="hljs-keyword">static</span> default_random_engine e;
    <span class="hljs-keyword">static</span> uniform_int_distribution&lt;<span class="hljs-keyword">unsigned</span>&gt; u(<span class="hljs-number">0</span>, <span class="hljs-number">9</span>);
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span>&gt;</span> ret;
    <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)
    {
        ret.push_back(u(e));
    }
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-comment">//引擎生成一个数值序列。</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span>&gt;</span> v1(bad_randvec());
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span>&gt;</span> v2(bad_randvec());
    <span class="hljs-built_in">cout</span> &lt;&lt; ((v1 == v2) ? <span class="hljs-string">"equal"</span> : <span class="hljs-string">"not equal"</span> ) &lt;&lt; endl;


    <span class="hljs-comment">//设置随机数发生器种子。</span>
    default_random_engine e2;
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> vec2{<span class="hljs-string">"Hei Tao"</span>, <span class="hljs-string">"Hong Tao"</span>, <span class="hljs-string">"Mei Hua"</span>,<span class="hljs-string">"Fang Kuai"</span>};
    uniform_int_distribution&lt;<span class="hljs-keyword">int</span>&gt; u2(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; vec2[u2(e2)] &lt;&lt; endl;
    }

    <span class="hljs-comment">//其他随机数分布。</span>
    default_random_engine e3;
    normal_distribution&lt;<span class="hljs-keyword">double</span>&gt; n(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//定义正态分布对象。</span>
    <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; n(e3) &lt;&lt; <span class="hljs-string">" "</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;

    <span class="hljs-built_in">string</span> resp;
    default_random_engine e4;<span class="hljs-comment">//引擎应该在循环外定义。</span>
    bernoulli_distribution b4(<span class="hljs-number">.55</span>);<span class="hljs-comment">//程序有55%的概率先行。</span>
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-keyword">bool</span> first = b4(e4);
        <span class="hljs-built_in">cout</span> &lt;&lt; (first ? <span class="hljs-string">"we go first"</span> : <span class="hljs-string">"you go first"</span>) &lt;&lt; endl;
    } <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; resp &amp;&amp; resp[<span class="hljs-number">0</span>] == <span class="hljs-string">'y'</span>);

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201172813644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="4"><strong>2、random_shuffle()方法：</strong></font></p>

<p>  <font size="4">产生指定范围内的随机元素集的最佳方法是创建一个顺序序列（也就是向量或者内置数组），在这个顺序序列中含有指定范围的所有值。填充完向量之后，用random_shuffle()算法打乱元素排列序。 <br>
  <font size="4">random_shuffle()定义在标准的头文件中。因为所有的STL算法都是在名字空间std::中声明的，所以你要注意正确地声明数据类型。 <br>
 <font size="4"> random_shuffle()有两个参数，第一个参数是指向序列首元素的迭代器，第二个参数则指向序列最后一个元素的下一个位置。下列代码段用random_shuffle()算法打乱了先前填充到向量中的元素： </font></font></font></p>

<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-keyword">include</span> &lt;algorithm&gt;  
using <span class="hljs-symbol">std:</span><span class="hljs-symbol">:random_shuffle</span>;  
random_shuffle(vi.<span class="hljs-keyword">begin</span>(), vi.<span class="hljs-keyword">end</span>()); <span class="hljs-regexp">/* 打乱元素 */</span>  </code></pre>

<p>  <font size="4">例子： </font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include "stdafx.h"  </span>
<span class="hljs-preprocessor">#include &lt;iostream&gt;  </span>
<span class="hljs-preprocessor">#include &lt;vector&gt;  </span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;  </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  

<span class="hljs-keyword">int</span> _tmain(<span class="hljs-keyword">int</span> argc, _TCHAR* argv[])  
{  
     <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> str;  
     str.push_back(<span class="hljs-string">"hello"</span>);  
     str.push_back(<span class="hljs-string">"world"</span>);  
     str.push_back(<span class="hljs-string">"welcome"</span>);  
     str.push_back(<span class="hljs-string">"to"</span>);  
     str.push_back(<span class="hljs-string">"Beijing"</span>);  

     <span class="hljs-built_in">std</span>::random_shuffle(str.begin(),str.end());<span class="hljs-comment">//迭代器  </span>

     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; str.size(); j++)  
     {  
         <span class="hljs-built_in">cout</span>&lt;&lt;str[j].c_str()&lt;&lt;<span class="hljs-string">" "</span>;  
     }  
     <span class="hljs-built_in">cout</span>&lt;&lt;endl;  

    system(<span class="hljs-string">"pause"</span>);  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  </code></pre>

<p><font size="5"><strong>五、IO库再探</strong></font></p>

<p>  <font size="4">操作符用于两大类输出控制：控制数值的输出形式以及控制补白的数量和位置。大多数改变格式状态的操纵符都是设置/复原成对的；一个操纵符用来将格式状态设置为一个新值，而另一个用来将其复原，恢复为正常的默认格式。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;iomanip&gt;</span>
<span class="hljs-preprocessor">#include &lt;cmath&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{

    <span class="hljs-comment">/***************
    *格式化输入输出。
    ****************/</span>

    <span class="hljs-comment">//用boolalpha控制bool值的输出。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">true</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; <span class="hljs-keyword">false</span> &lt;&lt; boolalpha &lt;&lt; <span class="hljs-string">"\n"</span> &lt;&lt; <span class="hljs-keyword">true</span> &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; <span class="hljs-keyword">false</span> &lt;&lt; endl;

    <span class="hljs-comment">//控制整型值的输出：hex(16)、oct(8)、dec(2)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; showbase;<span class="hljs-comment">//显示进制符。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">20</span> &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; hex &lt;&lt; <span class="hljs-number">20</span> &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; oct &lt;&lt; <span class="hljs-number">20</span> &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; dec &lt;&lt; <span class="hljs-number">20</span> &lt;&lt; endl;

    <span class="hljs-comment">//控制精度、浮点数计数法、打印小数、输出补白(位宽)</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; setprecision(<span class="hljs-number">3</span>);<span class="hljs-comment">//设置精度。</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"precision: "</span> &lt;&lt; <span class="hljs-built_in">cout</span>.precision() &lt;&lt; <span class="hljs-string">", value: "</span> &lt;&lt; <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; scientific &lt;&lt; <span class="hljs-number">10</span> * <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">//科学计数法。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; defaultfloat &lt;&lt; <span class="hljs-number">10</span> * <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">//默认操纵符。</span>

    <span class="hljs-built_in">cout</span> &lt;&lt; setprecision(<span class="hljs-number">3</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; showpoint &lt;&lt; <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">//强制显示小数点。</span>

    <span class="hljs-keyword">int</span> i = <span class="hljs-number">16</span>;
    <span class="hljs-keyword">double</span> d = <span class="hljs-number">3.1415926</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; setw(<span class="hljs-number">12</span>) &lt;&lt; i &lt;&lt; <span class="hljs-string">"next col"</span> &lt;&lt; <span class="hljs-string">"\n"</span>
         &lt;&lt; <span class="hljs-string">"d: "</span> &lt;&lt; setw(<span class="hljs-number">12</span>) &lt;&lt; d &lt;&lt; <span class="hljs-string">"next col"</span> &lt;&lt; <span class="hljs-string">"\n"</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; left;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; setw(<span class="hljs-number">12</span>) &lt;&lt; i &lt;&lt; <span class="hljs-string">"next col"</span> &lt;&lt; <span class="hljs-string">"\n"</span>
         &lt;&lt; <span class="hljs-string">"d: "</span> &lt;&lt; setw(<span class="hljs-number">12</span>) &lt;&lt; d &lt;&lt; <span class="hljs-string">"next col"</span> &lt;&lt; <span class="hljs-string">"\n"</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; right;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; setw(<span class="hljs-number">12</span>) &lt;&lt; i &lt;&lt; <span class="hljs-string">"next col"</span> &lt;&lt; <span class="hljs-string">"\n"</span>
         &lt;&lt; <span class="hljs-string">"d: "</span> &lt;&lt; setw(<span class="hljs-number">12</span>) &lt;&lt; d &lt;&lt; <span class="hljs-string">"next col"</span> &lt;&lt; <span class="hljs-string">"\n"</span>;

    <span class="hljs-built_in">cout</span> &lt;&lt; setfill(<span class="hljs-string">'#'</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"i: "</span> &lt;&lt; setw(<span class="hljs-number">12</span>) &lt;&lt; i &lt;&lt; <span class="hljs-string">"next col"</span> &lt;&lt; <span class="hljs-string">"\n"</span>
         &lt;&lt; <span class="hljs-string">"d: "</span> &lt;&lt; setw(<span class="hljs-number">12</span>) &lt;&lt; d &lt;&lt; <span class="hljs-string">"next col"</span> &lt;&lt; <span class="hljs-string">"\n"</span> &lt;&lt; setfill(<span class="hljs-string">' '</span>);<span class="hljs-comment">//恢复正常的补白字符。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201172946423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/02/01 17:31:01 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79231317">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79231317                    </div>
                    <div>
                        阅读：45                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]模板与泛型编程]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79229853</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79229853</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/02/01 16:08:54</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4">面对对象编程OOP和泛型编程都能处理在编写程序时不知道类型的情况，而OOP能处理类型在程序运行之前都未知的情况，<font color="red">在泛型编程中，在编译时就能获知类型了。</font> <br>
  <font size="4">模版是C++泛型编程的基础，<font size="4" color="green">一个模版就是一个类或函数的蓝图或者说是公式</font>：例如在使用vector这样的泛型类型，或者是find函数这样的泛型类型，<font size="4" color="blue">我们可以将蓝图转换为特定的类或者是函数，这种转换发生在编译时。</font></font></font></p>

<p><font size="5"><strong>一、定义模板</strong></font></p>

<p><font size="4"><strong>1、函数模板</strong></font></p>

<p>  <font size="4">一个函数模版就是一个公式，可用来生成指定类型的函数版本。<font color="cyan">模版定义从template开始，后跟一个模版参数列表，用两个小尖括号包起来，参数列表不能为空。</font> <br>
  <font size="4">我们可以为函数定义一个模板，而不是为每一个类型定义一个函数。例如比较函数：</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">//T表示一个类型，而T的实际类型在编译时根据实际情况决定。</span>
<span class="hljs-keyword">int</span> compare(<span class="hljs-keyword">const</span> T&amp;v1, <span class="hljs-keyword">const</span> T&amp;v2)
{
    <span class="hljs-keyword">if</span>(v1 &lt; v2) 
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(v1 &gt; v2)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> i1 = <span class="hljs-number">10</span>, i2 = <span class="hljs-number">20</span>;
    <span class="hljs-keyword">double</span> d1 = <span class="hljs-number">20.1</span>, d2 = <span class="hljs-number">20.01</span>;
    <span class="hljs-keyword">unsigned</span> u1 = <span class="hljs-number">10</span>, u2 = <span class="hljs-number">10</span>;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; compare(i1, i2) &lt;&lt; <span class="hljs-built_in">std</span>::endl;<span class="hljs-comment">//实例化。</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; compare(d1, d2) &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; compare(u1, u2) &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}</code></pre>

<p>  <font size="4">当我们调用template时，编译器会使用实参的类型来确定绑定到模版参数T上的类型，之后<font size="4" color="red">编译器利用推断出的模版参数来实例化一个特定版本的函数</font>，这个过程被称之为实例化。</font></p>

<p><font size="4"><strong>（1）模板类型参数、非类型模板参数</strong></font></p>

<p>  <font size="4" color="green">编译器遇到一个模版的定义时，并不会产生代码，只有当我们实例化出模版的一个特定版本的时候，编译器才会产生代码。</font> <br>
  <font size="4">可以将模版的类型参数看作是类型说明符，类型参数可以用来指定函数的返回类型、函数的参数类型以及在函数体内用于变量的声明和类型转换，<font size="4" color="red">在类型参数之前必须加上typename或者class这两个关键字</font>，这两个关键字含义相同，可以互换使用，可以定义多个类型参数。使用typename更好一点，因为我们还可以使用内置类型(非类)作为模版的类型参数。 <br>
  <font size="4">保证传递给模版的实参支持模版的所有操作，以及这些操作在模版中正确工作，非常重要。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#ifndef TEMPLATE_H</span>
<span class="hljs-preprocessor">#define TEMPLATE_H</span>

<span class="hljs-comment">//使用多个类型参数。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">bool</span> my_find(<span class="hljs-keyword">const</span> T &amp;v1, <span class="hljs-keyword">const</span> T &amp;v2, <span class="hljs-keyword">const</span> U &amp;val)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = v1; i != v2; ++i)
    {
        <span class="hljs-keyword">if</span>(*i == val)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}
<span class="hljs-preprocessor">#endif TEMPLATE_H</span></code></pre>

<p>  <font size="4">非类型模版参数，可以使用一个非类型参数（一个值或者指针和引用）来指定非类型参数，编译器会使用字面常量的大小代替非类型参数，若是字符串还会加一。 <br>
  <font size="4" color="blue">非类型模板参数的模板实参必须是常量表达式。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#ifndef BEGIN_END_H</span>
<span class="hljs-preprocessor">#define BEGIN_END_H</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">unsigned</span> N&gt; T* begin(<span class="hljs-keyword">const</span> T (&amp;arr)[N])
{<span class="hljs-comment">// error C2234: “arr”: 引用数组是非法的,(&amp;arr即可)</span>
    <span class="hljs-keyword">return</span> arr;
}

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">unsigned</span> N&gt; T* end(<span class="hljs-keyword">const</span> T(&amp;arr)[N])
{
    <span class="hljs-keyword">return</span> arr+N;
}

<span class="hljs-preprocessor">#endif BEGIN_END_H</span></code></pre>

<p>  <font size="4">inline 和constexpr也可以修饰函数模板，放在返回值前面。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//inline放在模板列表之后，返回类型之前。</span>
<span class="hljs-comment">//打印任意大小和类型的数组的所有元素。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> my_print(<span class="hljs-keyword">const</span> T &amp;arr)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> i : arr)
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
}

<span class="hljs-comment">//返回数组大小。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">unsigned</span> N&gt; 
<span class="hljs-keyword">constexpr</span> size_t arr_size(<span class="hljs-keyword">const</span> T (&amp;arr)[N])  
{  
    <span class="hljs-keyword">return</span> N;  
}</code></pre>

<p><font size="4"><strong>（2）编写类型无关的代码、模板编译、大多数编译错误在实例化期间报告</strong></font></p>

<p><font size="4" color="green">【Note】:  <br>
1）模板中的函数参数是const的引用（保证函数可以用于不能拷贝的类型）。 <br>
2）函数体条件中判断仅仅使用&lt;比较（大多数都定义了&lt;比较的类型）。有的时候大部分都会定义！=运算符。所以模板程序应该尽量减少对实参类型的要求。</font> <br>
  <font size="4">模板编译和普通的编译不同，它是在使用实例化时编译器才生成代码，为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此和非模板代码不同，<font size="4" color="red">模板的头文件通常既包括声明又包括定义。</font> <br>
<font size="4" color="green">【Note】:  <br>
1）模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。 <br>
2）模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。</font> <br>
  <font size="4">保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。</font></font></p>

<p><font size="4"><strong>（3）本节demo：</strong></font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">//使用多个类型参数。</span>
<span class="hljs-comment">//定义标准库find函数。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
<span class="hljs-keyword">bool</span> my_find(<span class="hljs-keyword">const</span> T &amp;v1, <span class="hljs-keyword">const</span> T &amp;v2, <span class="hljs-keyword">const</span> U &amp;val)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = v1; i != v2; ++i)
    {
        <span class="hljs-keyword">if</span>(*i == val)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
}

<span class="hljs-comment">//inline放在模板列表之后，返回类型之前。</span>
<span class="hljs-comment">//打印任意大小和类型的数组的所有元素。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> my_print(<span class="hljs-keyword">const</span> T &amp;arr)
{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> i : arr)
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; endl;
}

<span class="hljs-comment">//定义标准库的begin和end。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">unsigned</span> N&gt;
T * begin(<span class="hljs-keyword">const</span> T (&amp;arr)[N])
{
    <span class="hljs-keyword">return</span> arr;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">unsigned</span> N&gt;
T * end(<span class="hljs-keyword">const</span> T (&amp;arr)[N])
{
    <span class="hljs-keyword">return</span> arr + N;
}

<span class="hljs-comment">//返回数组大小。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">unsigned</span> N&gt; 
<span class="hljs-keyword">constexpr</span> size_t arr_size(<span class="hljs-keyword">const</span> T (&amp;arr)[N])  
{  
    <span class="hljs-keyword">return</span> N;  
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> vec{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};
    <span class="hljs-stl_container"><span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> lst{<span class="hljs-string">"ab"</span>, <span class="hljs-string">"cd"</span>, <span class="hljs-string">"ef"</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; my_find(begin(vec), end(vec), <span class="hljs-number">2</span>) &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; my_find(begin(lst), end(lst), <span class="hljs-string">"ab"</span>) &lt;&lt; endl;
    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">3</span>] = {<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>};
    my_print(arr);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = begin(arr); i != end(arr); ++i)
        <span class="hljs-built_in">cout</span> &lt;&lt; *i &lt;&lt; <span class="hljs-string">" "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; endl &lt;&lt; arr_size(arr) &lt;&lt; endl ;
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201124247466?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="4"><strong>2、类模板</strong></font></p>

<p>  <font size="4">类模板是生成类的模板（这些类具有相同的功能只是类型不同）。它和函数模板的不同是<font size="4" color="red">它不能向函数模板一样推断出类型是什么，而是要自己指定类型是什么</font>。比如vector就是一个模板类，T可以是任何类型int ,double ,string或者是自己定义的类类型。<font size="4" color="blue">为了使用类模板，我们必须在模板名后的尖括号中提供额外信息，用来代替实参。</font></font></p>

<p><font size="4"><strong>（1）定义类模板、实例化类模板</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//类模板：</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> Blob
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//类模板的成员模板。</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; <span class="hljs-keyword">void</span> output(T thistype, T1 othertype); 
    <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">typename</span> <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>::size_type;
    <span class="hljs-comment">//构造函数。</span>
    Blob();
    <span class="hljs-comment">//列表初始化。</span>
    Blob(initializer_list&lt;T&gt; il):data(make_shared&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>&gt;(il)) { }
    size_type size() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> data-&gt;size(); }
    <span class="hljs-keyword">bool</span> empty() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> data-&gt;empty(); }
    <span class="hljs-comment">//添加和删除元素。</span>
    <span class="hljs-keyword">void</span> push_back(<span class="hljs-keyword">const</span> T &amp;t) { data-&gt;push_back(t); }
    <span class="hljs-keyword">void</span> push_back(T &amp;&amp;t) { data-&gt;push_back(<span class="hljs-built_in">std</span>::move(t)); }
    <span class="hljs-keyword">void</span> pop_back(<span class="hljs-keyword">const</span> T &amp;t) { data-&gt;pop_back(t); }
    <span class="hljs-keyword">void</span> pop_back(T &amp;&amp;t) { data-&gt;pop_back(<span class="hljs-built_in">std</span>::move(t)); }
    <span class="hljs-comment">//元素访问。</span>
    T &amp;back();
    T &amp;<span class="hljs-keyword">operator</span>[](size_type i);
    ~Blob(){}
<span class="hljs-keyword">private</span>:
    T *elements;  
    T *first_free;  
    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>&gt; data;
    <span class="hljs-comment">//若data[i]无效，则抛出异常。</span>
    <span class="hljs-keyword">void</span> check(size_type i, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;msg) <span class="hljs-keyword">const</span>;
};</code></pre>

<p><font size="4" color="green">【Note】:  <br>
1）一个类模版的每个实例都会形成一个独立的类，与其他实例化的类之间并没有特殊的访问权限。 <br>
2）无论何时使用模版都必须提供模版实参。</font> <br>
  <font size="4">实例化时，编译器会重写类模版，将模版参数替换为给定的模版实参。 <br>
  <font size="4">在一个类模版中使用另一种模版，通常不会将一个实际的类型（如：int）当作其模版实参，而将模版自己的参数当作被使用模版的实参，比如在一个模版类中使用的vector和shared_ptr都是类模版，我们在使用时，会将T作为模版实参传递给他们。</font></font></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//类模板的名字不是类型名。</span>
Blob&lt;<span class="hljs-keyword">int</span>&gt; a1{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<span class="hljs-comment">//数据类型是int，使用时才被实例化。</span></code></pre>

<p><font size="4"><strong>（2）类模板的成员函数及实例化、在类代码内简化模板类名的使用、在类模板外使用类模板名</strong></font></p>

<p>  <font size="4">我们可以在类模版的内部或者外部对类模版的成员函数进行定义，定义在类模版内的成员函数被隐式的声明为inline函数。 <br>
  <font size="4">由于类模版的每个实例都有自己版本的成员函数，因此类模版的成员函数具有和模版相同的模版参数，因此，<font size="4" color="blue">在定义类模版之外的成员函数必须以关键词template开始，</font>后接类模版实参列表（在其返回类型之后还需要加类名和&lt;&gt;参数列表）。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> Blob
{
<span class="hljs-keyword">public</span>:
    Blob();
    <span class="hljs-keyword">void</span> check(size_t,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>&gt; data;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; Blob&lt;T&gt;::Blob():data(make_shared(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>)){}<span class="hljs-comment">//类外定义构造函数，类模版的构造函数，无需返回类型，其他和普通成员函数一样。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
<span class="hljs-keyword">void</span> Blob&lt;T&gt;::check(size_t i,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; msg)<span class="hljs-comment">//类外定义成员函数</span>
{
    <span class="hljs-keyword">if</span> (i &gt; data-&gt;size())
    {
        <span class="hljs-keyword">throw</span> out_of_range(msg);
    }
}</code></pre>

<p><font size="4" color="green">【Note】:  <br>
1）类模版的成员函数实例化：只有在程序使用它时才会被实例化，即使其类模版已经被实例化。</font> <br>
  <font size="4">当我们使用一个类模板类型必须提供模板参数，但有一个例外，在类模版自己的作用域中（即类内），我们可以直接使用模版名而不提供实参（不需要&lt;&gt;这个东西了）而在类外则需要指定模版参数（返回值是模版的类型）</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> blobptr
{
    <span class="hljs-keyword">public</span>:
        blobptr():curr(<span class="hljs-number">0</span>){ }
        blobptr(blob&lt;T&gt; &amp;a, <span class="hljs-built_in">std</span>::size_t sz = <span class="hljs-number">0</span>):
            wptr(a.data), curr(sz) { }
        T&amp; <span class="hljs-keyword">operator</span>*()<span class="hljs-keyword">const</span>
        {
            <span class="hljs-keyword">auto</span> p = check(curr, <span class="hljs-string">"* error"</span>);
            <span class="hljs-keyword">return</span> (*p)[curr];
        }
        blobptr&amp; <span class="hljs-keyword">operator</span>++();<span class="hljs-comment">//返回blobptr&amp;而不是blobptr&lt;T&gt;&amp;。</span>
        blobptr&amp; <span class="hljs-keyword">operator</span>--();
    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>&gt;
            check(<span class="hljs-built_in">std</span>::size_t i, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;msg);
        <span class="hljs-built_in">std</span>::size_t curr;
        <span class="hljs-built_in">std</span>::weak_ptr&lt;<span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>&gt;wptr;
};

<span class="hljs-comment">//类外则需要指定模版参数。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  
blobptr&lt;T&gt;&amp; blobptr&lt;T&gt;::<span class="hljs-keyword">operator</span>++()  
{  
    blobptr ret = *<span class="hljs-keyword">this</span>;  
    ++*<span class="hljs-keyword">this</span>;  
    <span class="hljs-keyword">return</span> ret;  
}  

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  
blobptr&lt;T&gt;&amp; blobptr&lt;T&gt;::<span class="hljs-keyword">operator</span>--()  
{  
    blobptr ret = *<span class="hljs-keyword">this</span>;  
    --*<span class="hljs-keyword">this</span>;  
    <span class="hljs-keyword">return</span> ret;  
} </code></pre>

<p><font size="4"><strong>（3）模板类和友元、令自己的实例化类型作为友元(c++11)</strong></font></p>

<p>  <font size="4">当一个类模版包含一个非模版友元，则友元被授权可以访问所有的模版实例，如果友元自身是模版，类可以授权给所有友元模版实例，也可以只授予给定实例。 <br>
  <font size="4" color="red">类模板与另一个（类或函数）模板间的友好关系最常见的是一对一友好关系。 <br>
  <font size="4" color="red">如想要所有实例称为友元，友元声明中必须使用与类模版不同的模版参数。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//非类型模板参数。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">unsigned</span> N&gt;
<span class="hljs-keyword">class</span> bits
{
<span class="hljs-keyword">public</span>:
    bits() = <span class="hljs-keyword">default</span>;
    bits(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s) : bit(s) { }
    ~bits() =<span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> updata(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> b)
    {
        bit.<span class="hljs-built_in">set</span>(s, b);
    }

    <span class="hljs-comment">//为了让实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> M&gt;
    <span class="hljs-keyword">friend</span> size_t text(<span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;lb, <span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;rb);  
    <span class="hljs-comment">//重载输出操作符。</span>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> M&gt;  
    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> bits&lt;M&gt; &amp;b);  

<span class="hljs-keyword">private</span>:
    <span class="hljs-stl_container"><span class="hljs-built_in">bitset</span>&lt;N&gt;</span> bit;
};</code></pre>

<p>  <font size="4">一个模板类也可以指定另外一个模板类为友元或者另外一个模板类的特定实例。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> C
{

};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> B
{
    <span class="hljs-comment">//friend class C&lt;int&gt;;                 //特定类为友元</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> C;  <span class="hljs-comment">//模板类为友元</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> C;  <span class="hljs-comment">//error:本模板类参数列表已经包含T了，友元不可再次包含T,需要换参数,否则会报错显示应藏参数</span>
};

<span class="hljs-keyword">int</span> main()
{
    ...
}</code></pre>

<p>  <font size="4">令自己的实例化类型作为友元【C++11】:</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> X&gt; 
<span class="hljs-keyword">class</span> C
{
    <span class="hljs-keyword">friend</span> T;
};

<span class="hljs-keyword">int</span> main()
{}</code></pre>

<p>  <font size="4">那么我们实例化的时候，实例化类型是A，A就是模板类的友元，A可以是类类型，或者是内置类型。 </font></p>

<p><font size="4"><strong>（4）类模板别名(c++11)、类模板的static成员</strong></font> <br>
  <font size="4">旧标准中，我们只能使用typedef 为特定模板类型定义类型别名。c++11标准中，我们可以为模板类定义模板类型别名，而且多个参数时可以指定参数是T或者是特定类型。</font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Z&gt;
<span class="hljs-keyword">class</span> C
{

};

<span class="hljs-comment">//template参数列表指定参数的个数，但是我们能指定一个或多个特定类型比如TEP2的int</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> X, <span class="hljs-keyword">typename</span> Z&gt; <span class="hljs-keyword">using</span> TEP = C&lt;T, X, Z&gt;;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> X&gt; <span class="hljs-keyword">using</span> TEP2 = C&lt;T, X, <span class="hljs-keyword">int</span>&gt;;

<span class="hljs-keyword">int</span> main()
{
    C&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; c;
    TEP&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; t;
    TEP2&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; t2;
}</code></pre>

<p>  <font size="4">当类模板包含static成员时（数据或者是函数）,每个类模板的实例都有一个static成员，而且定义类模板的static成员时，前面必须加template &lt;参数列表&gt;。 <br>
  <font size="4" color="blue">在相同的实例中共享static成员，因此元素的值可能发生变化，但是在不同的对象中不互相共享。类模版的static成员有且仅有一个定义。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> C
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> fun(T &amp;a);

    <span class="hljs-keyword">private</span>:
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> C&lt;T&gt;::fun(T &amp;a)
{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}

<span class="hljs-comment">//别忘记了int。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">int</span> C&lt;T&gt;::i = <span class="hljs-number">0</span>;

<span class="hljs-keyword">int</span> main()
{
    C&lt;<span class="hljs-keyword">int</span>&gt;c;
}</code></pre>

<p><font size="4"><strong>3、模板参数</strong></font></p>

<p>  <font size="4">T没有任何的实际意义，只是类型的一个替代。</font></p>

<p><font size="4"><strong>（1）模板参数与作用域、模板声明、使用类的类型成员</strong></font></p>

<p>  <font size="4">模版参数的作用于范围在其声明之后，模版的定义或声明结束之前，且其会隐藏外层作用域中相同的名字(在外层使用了typedef T之后，在类中T的含义还是模版参数的含义)，且模版参数名不可才参数列表中重复。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> A;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> B&gt;
<span class="hljs-keyword">void</span> f(A,a,B,b)
{
    A tmp = a;<span class="hljs-comment">//tmp的类型为A的类型而不是double。</span>
    <span class="hljs-keyword">double</span> B;<span class="hljs-comment">//错误：重声明模板参数B</span>
}</code></pre>

<p>  <font size="4">声明与定义中的模版参数的名字可以不相同。一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。 <br>
  <font size="4">我们处理模板的时候，必须让编译器知道名字是否表示一个类型。</font></font></p>

<pre class="prettyprint"><code class=" hljs bash">T::size_<span class="hljs-built_in">type</span> *p;    //error   typename T::size_<span class="hljs-built_in">type</span> *p </code></pre>

<p>  <font size="4">我们不知道T是一个名字还是模板的参数列表里的类型，c++编译器默认为名字。所以如果我们像上面想表示为一个类型的话必须显式的指定，在前面添加关键字typename。</font></p>

<p><font size="4"><strong>（2）默认模板实参、模板默认实参与类模板</strong></font> <br>
  <font size="4">C++11新标准允许默认模版实参（可以为函数提供，早起只能为类模版提供默认模版实参）。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;functional&gt;</span>

<span class="hljs-comment">//X默认实参是std::less&lt;T&gt;这个函数对象</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> X = <span class="hljs-built_in">std</span>::less&lt;T&gt;&gt;
<span class="hljs-keyword">int</span> compare(<span class="hljs-keyword">const</span> T &amp;v1, <span class="hljs-keyword">const</span> T &amp;v2, X x = X())
{
    <span class="hljs-keyword">if</span>(x(v1, v2))
    {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; v2 &lt;&lt; <span class="hljs-built_in">std</span>::endl;
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">if</span>(x(v2, v1))
    {
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; v1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; v2 &lt;&lt; <span class="hljs-built_in">std</span>::endl;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-comment">//传参数函数对象std::greater</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; compare(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-built_in">std</span>::greater&lt;<span class="hljs-keyword">int</span>&gt;()) &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-comment">//使用默认参数  std::less</span>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; compare(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-built_in">std</span>::endl;
}</code></pre>

<p>  <font size="4">在我们为类模版的所有参数都提供了默认参数后，加一对空尖括号即可。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">int</span>&gt; 
<span class="hljs-keyword">class</span> C
{
    <span class="hljs-keyword">public</span>:
        C(T v = <span class="hljs-number">0</span>):
            val(v) { }

    <span class="hljs-keyword">private</span>:
        T val;
};

<span class="hljs-keyword">int</span> main()
{
    C&lt;&gt; c;            <span class="hljs-comment">//使用默认int</span>
    C&lt;<span class="hljs-keyword">double</span>&gt; c2;     <span class="hljs-comment">//覆盖默认int改用double</span>
}</code></pre>

<p><font size="4"><strong>4、成员模板</strong></font></p>

<p>  <font size="4">一个类无论是类模版还是普通类，都可以将其成员函数定义为模版，称之为成员模版，但是成员模版不能是虚函数。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//普通（非模板）类的成员模板：</span>
<span class="hljs-keyword">class</span> Debugdelete  
{  
<span class="hljs-keyword">public</span>:  
    Debugdelete(ostream &amp;s = <span class="hljs-built_in">cerr</span>):os(s){}<span class="hljs-comment">//构造函数。</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T *p) <span class="hljs-keyword">const</span><span class="hljs-comment">//const表示该函数不会修改类的成员数据。</span>
    {  
        os&lt;&lt;<span class="hljs-string">"deleting..."</span>&lt;&lt;endl;<span class="hljs-comment">//额外信息，我们的删除器可以做用于任何版本类型。</span>
        <span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//接受一个指针作为参数，并且删除该指针。</span>
    }  
<span class="hljs-keyword">private</span>:  
    ostream &amp;os;<span class="hljs-comment">//私有成员为一个输出流。</span>
};

<span class="hljs-keyword">double</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>;<span class="hljs-comment">//新分配一个double对象。</span>
Debugdelete d;<span class="hljs-comment">//创建一个删除器对象。</span>
d(p);<span class="hljs-comment">//调用定义的模版函数operator ()，对p进行释放。</span>
<span class="hljs-comment">//可以对类型的删除器进行重载我们自己定义的版本，在尖括号中给出删除器的类型，</span>
<span class="hljs-comment">//并提供一个这个类型的对象给它的构造函数即可。</span>
unique_ptr&lt;<span class="hljs-keyword">int</span>,Debugdelete&gt; m(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>,Debugdelete());
<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; n(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>,Debugdelete());


<span class="hljs-comment">//类模板的成员模板</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  
<span class="hljs-keyword">class</span> C  
{  
    <span class="hljs-keyword">public</span>:  
        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt;C(X b, X e);  

    <span class="hljs-keyword">private</span>:  
        <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>ivec;  
};  
<span class="hljs-comment">//同时为类模板和成员模板提供模板参数列表。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;       <span class="hljs-comment">//类的参数列表  </span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt;       <span class="hljs-comment">//构造函数的参数列表  </span>
C&lt;T&gt;::C(X b, X e)  
{  
  ...
}  </code></pre>

<p>  <font size="4">实例化一个类模板的成员函数模板，类模板必须明确指出类型，函数模板根据参数推断出类型，如上面main函数里面的实例。</font></p>

<p><font size="4"><strong>5、控制实例化、效率与灵活性</strong></font></p>

<p>  <font size="4">对于模版使用时才会被实例化，会产生一个问题：相同的实例可能会出现在多个对象文件中，这时候每个文件都会有一份实例化的副本，这无疑造成了很大的额外开销，所以在C++11新标准下，我们可以使用<font size="4" color="green">显示实例化</font>以避免这样的开销，所有的模版参数会被替换为模版实参：</font></p>

<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> Blob&lt;<span class="hljs-built_in">string</span>&gt;;        <span class="hljs-comment">//实例化class声明</span>
<span class="hljs-keyword">template</span> <span class="hljs-keyword">int</span> compare(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;);    <span class="hljs-comment">//实例化compare函数定义</span></code></pre>

<p>  <font size="4">当编译器遇到extern模版声明时，不会在本文件中生成实例化代码。将一个实例化声明为extern，就表示承诺在程序其他位置有该实例化的一个非extern定义，只能有一个定义！ <br>
<font size="4" color="green">【Note】:  <br>
1）对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</font> <br>
  <font size="4">一个类模版的实例化定义会实例化该模版的所有成员，包括内联函数成员，因为我们也不知道程序会使用那些成员函数，所以我们必须将其全部实例化，这就要求在实例化定义中，所用类型必须能作用于模版的所有成员函数。</font></font></p>

<p>  <font size="4"><font size="4" color="red">shared_ptr删除器：在运行时绑定的删除器</font>。在一个shared_ptr的生存期中，我们可以随时改变其删除器的类型。 <br>
  <font size="4"><font size="4" color="red">unique_ptr删除器：在编译时绑定的删除器</font>。unique_ptr的删除器是unique_ptr的一部分。unique_ptr有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型，在编译时绑定，所以没有运行开销</font></font></p>

<p><font size="4"><strong>6、类模板和成员模板demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bIts/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">//成员模板：</span>
<span class="hljs-keyword">class</span> Debugdelete  
{  
<span class="hljs-keyword">public</span>:  
    Debugdelete(ostream &amp;s = <span class="hljs-built_in">cerr</span>):os(s){}<span class="hljs-comment">//构造函数。</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T *p) <span class="hljs-keyword">const</span><span class="hljs-comment">//const表示该函数不会修改类的成员数据。</span>
    {  
        os&lt;&lt;<span class="hljs-string">"deleting..."</span>&lt;&lt;endl;<span class="hljs-comment">//额外信息，我们的删除器可以做用于任何版本类型。</span>
        <span class="hljs-keyword">delete</span> p;<span class="hljs-comment">//接受一个指针作为参数，并且删除该指针。</span>
    }  
<span class="hljs-keyword">private</span>:  
    ostream &amp;os;<span class="hljs-comment">//私有成员为一个输出流。</span>
};

<span class="hljs-comment">//类模板：</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">class</span> Blob
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">//类模板的成员模板。</span>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt; <span class="hljs-keyword">void</span> output(T thistype, T1 othertype); 
    <span class="hljs-keyword">using</span> size_type = <span class="hljs-keyword">typename</span> <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>::size_type;
    <span class="hljs-comment">//构造函数。</span>
    Blob();
    <span class="hljs-comment">//列表初始化。</span>
    Blob(initializer_list&lt;T&gt; il):data(make_shared&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>&gt;(il)) { }
    size_type size() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> data-&gt;size(); }
    <span class="hljs-keyword">bool</span> empty() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> data-&gt;empty(); }
    <span class="hljs-comment">//添加和删除元素。</span>
    <span class="hljs-keyword">void</span> push_back(<span class="hljs-keyword">const</span> T &amp;t) { data-&gt;push_back(t); }
    <span class="hljs-keyword">void</span> push_back(T &amp;&amp;t) { data-&gt;push_back(<span class="hljs-built_in">std</span>::move(t)); }
    <span class="hljs-keyword">void</span> pop_back(<span class="hljs-keyword">const</span> T &amp;t) { data-&gt;pop_back(t); }
    <span class="hljs-keyword">void</span> pop_back(T &amp;&amp;t) { data-&gt;pop_back(<span class="hljs-built_in">std</span>::move(t)); }
    <span class="hljs-comment">//元素访问。</span>
    T &amp;back();
    T &amp;<span class="hljs-keyword">operator</span>[](size_type i);
    ~Blob(){}
<span class="hljs-keyword">private</span>:
    T *elements;  
    T *first_free;  
    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;T&gt;</span>&gt; data;
    <span class="hljs-comment">//若data[i]无效，则抛出异常。</span>
    <span class="hljs-keyword">void</span> check(size_type i, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;msg) <span class="hljs-keyword">const</span>;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> Blob&lt;T&gt;::check(size_type i, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;msg) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">if</span> (i &gt;= data-&gt;size())
        <span class="hljs-keyword">throw</span> out_of_range(msg);
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
T &amp;Blob&lt;T&gt;::back()
{
    check(<span class="hljs-number">0</span>,<span class="hljs-string">"back on empty Blob"</span>);
    <span class="hljs-keyword">return</span> data-&gt;back();
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
T &amp;Blob&lt;T&gt;::<span class="hljs-keyword">operator</span>[](size_type i)
{
    <span class="hljs-comment">//如果i太大，抛出异常。</span>
    check(i,<span class="hljs-string">"out of range"</span>);
    <span class="hljs-keyword">return</span> (*data)[i];
}

<span class="hljs-comment">//类模板的模板参数列表在成员模板参数列表之前。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1&gt;  
<span class="hljs-keyword">void</span> Blob&lt;T&gt;::output(T thistype, T1 othertype)  
{  
    <span class="hljs-built_in">cout</span>&lt;&lt; <span class="hljs-string">"thistype is "</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(thistype).name()
        &lt;&lt;<span class="hljs-string">", othertype is "</span> &lt;&lt; <span class="hljs-keyword">typeid</span>(othertype).name() &lt;&lt; endl;  
}  

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{

    <span class="hljs-comment">//类模板。</span>
    Blob&lt;<span class="hljs-keyword">int</span>&gt; a1{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};<span class="hljs-comment">//数据类型是int，使用时才被实例化。</span>
    a1.push_back(<span class="hljs-number">4</span>);
    <span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i != a1.size(); ++i)
        <span class="hljs-built_in">cout</span> &lt;&lt; a1[i] &lt;&lt; <span class="hljs-string">" "</span>;
    Blob&lt;<span class="hljs-built_in">string</span>&gt; str{<span class="hljs-string">"ab"</span>, <span class="hljs-string">"cd"</span>, <span class="hljs-string">"ef"</span>};
    <span class="hljs-built_in">cout</span> &lt;&lt; endl &lt;&lt; str[<span class="hljs-number">1</span>] &lt;&lt; endl;
    a1.output(<span class="hljs-number">10</span>,<span class="hljs-keyword">true</span>);

    <span class="hljs-comment">//成员模板：</span>
    <span class="hljs-keyword">double</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>;<span class="hljs-comment">//新分配一个double对象。</span>
    Debugdelete d;<span class="hljs-comment">//创建一个删除器对象。</span>
    d(p);<span class="hljs-comment">//调用定义的模版函数operator ()，对p进行释放。</span>
    <span class="hljs-comment">//可以对类型的删除器进行重载我们自己定义的版本，在尖括号中给出删除器的类型，</span>
    <span class="hljs-comment">//并提供一个这个类型的对象给它的构造函数即可。</span>
    unique_ptr&lt;<span class="hljs-keyword">int</span>,Debugdelete&gt; m(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>,Debugdelete());
    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; n(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>,Debugdelete());
    <span class="hljs-built_in">cin</span>.get();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180201145433818?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="5"><strong>二、模板实参推断</strong></font></p>

<p>  <font size="4" color="blue">从函数实参到模版实参的过程被称为模版实参推断，在这个过程中，可能会发生类型转换。</font></p>

<p><font size="4"><strong>1、类型转换与模板实参推断</strong></font></p>

<p>  <font size="4">在模版推断的过程中，编译器根据函数调用的实参类型来寻找模版实参，用这些模版实参生成的函数版本与给定的函数调用匹配。 <br>
  <font size="4">只有两种情况会发生类型转换： <br>
<font size="4"> <br>
 - 非const对象的引用或者指针到const对象的引用或者指针（const到非const是不合法的）（顶层const会被忽略）。 <br>
 - 若函数参数不是引用的类型，则可以进行函数或者数组的指针类型转换，我们可以用函数实参或者数组实参转化为对应指针。 <br>
<font size="4" color="green">【Note】:  <br>
1）将实参传递给代模板类型的参数时，能够自动类型转换的只有const转换及数组或函数到指针的转换。如果想要传递不同的参数，则我们必须自己定义那种不同的模板类型。 <br>
2）如果函数模板的参数不是模板则可以正常进行转换。 <br>
3）算术类型转换不能支持模版函数的类型转换，若我们想要两个不同类型的参数，定义两个不同的模版参数即可。</font></font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">/***********************
*类型转换与模板类型参数。
************************/</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
T fobj(T a, T b)
{
    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; b &lt;&lt; endl;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
T fref(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)
{
    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; b &lt;&lt; endl;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> A, <span class="hljs-keyword">typename</span> B&gt;
<span class="hljs-keyword">void</span> fcpe(<span class="hljs-keyword">const</span> A &amp;a, <span class="hljs-keyword">const</span> B &amp;b)
{
    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; b &lt;&lt; endl;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
ostream &amp;fprt(ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t)
{
    os &lt;&lt; t &lt;&lt; endl;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
T fcn(T a, <span class="hljs-keyword">int</span> b)
{
    <span class="hljs-built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; b &lt;&lt; endl;
}

<span class="hljs-built_in">string</span> s1(<span class="hljs-string">"a string"</span>);
<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> s2(<span class="hljs-string">"anthor string"</span>);
fobj(s1, s2);
fref(s1, s2);<span class="hljs-comment">//将s1转换为const是允许的。</span>
<span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>], b[<span class="hljs-number">10</span>];
fobj(a, b);<span class="hljs-comment">//数组名转换为指针，打印地址。</span>
fcpe(<span class="hljs-number">0.1</span>, <span class="hljs-number">10</span>);<span class="hljs-comment">//第一个为float，第二个为int被提升为float。</span>
fprt(<span class="hljs-built_in">cout</span>, <span class="hljs-number">10</span>);<span class="hljs-comment">//严格匹配。</span>
<span class="hljs-keyword">char</span> c = <span class="hljs-string">'b'</span>;
fcn(c, <span class="hljs-string">'c'</span>);<span class="hljs-comment">//char提升为int。字符c表示的ASCII码。</span></code></pre>

<p><font size="4"><strong>2、函数模板显式实参</strong></font></p>

<p>  <font size="4">在某些情况下，编译器无法推断出模板实参的类型。在其他一些情况下，我们希望允许用户控制模板实例化。通常有两个原因： <br>
<font size="4" color="blue"> <br>
 - 模版实参作为函数的返回类型，传入的函数实参不能推断出函数的返回类型。 <br>
 - 我们希望可以参数指定类型，进行类型转换。</font></font></p>

<p>  <font size="4"><font size="4" color="red">显式模版实参</font>，位于函数名后，参数列表之前，注意其函数模版实参是按从左至右顺序进行匹配的，之后尾部的参数可以忽略（忽略的前提是可以通过传入的实参进行推断），所以不要将最后的参数作为返回类型，否则需要将所有的模版实参进行显式的初始化：</font></p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**************
*函数模板显示实参。
***************/</span>
template &lt;typename T1, typename T2, typename T3&gt;
T1 sum(T2 t2, T3 t3)
{
    T1 p = t2 + t3;
    <span class="hljs-keyword">return</span> p;
}

<span class="hljs-keyword">long</span> lng = <span class="hljs-number">1000000</span>;
auto val2 = sum&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(<span class="hljs-number">1</span>,lng);<span class="hljs-comment">//指定显式模板实参。</span>
cout &lt;&lt; val2 &lt;&lt; endl;</code></pre>

<p><font size="4"><strong>3、尾置返回类型与类型转换</strong></font></p>

<p>  <font size="4" color="red">一些情况下，要求显式指定模板实参会给用户添加额外负担，且不会带来什么好处。此时我们可以使用尾置返回类型。</font></p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/***********************
*尾置返回类型与类型转换。
************************/</span>
template &lt;typename T&gt;
auto sum2(<span class="hljs-keyword">const</span> T &amp;a,<span class="hljs-keyword">const</span> T &amp;b) -&gt;decltype(a+b)<span class="hljs-comment">//将函数的返回类型指定为a+b的类型。</span>
{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-keyword">int</span> a3 = <span class="hljs-number">566669</span>;
<span class="hljs-keyword">int</span> b3 = <span class="hljs-number">59</span>;
cout &lt;&lt; sum2(a3, b3) &lt;&lt; endl;<span class="hljs-comment">//处理足够大小的数相加。</span></code></pre>

<p><font size="4"><strong>4、函数指针和实参推断</strong></font></p>

<p>  <font size="4">我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时。编译器会用指针的类型来推断模板。</font></p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/*******************
*函数指针和实参推断。
********************/</span>
template &lt;typename T&gt;
<span class="hljs-keyword">int</span> compare(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)
{
    <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span> ;
}

<span class="hljs-keyword">int</span> (*p)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;) = compare;
cout &lt;&lt; p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">//p是指向函数的指针,使用指针来推断模板实参为int。</span></code></pre>

<p><font size="4" color="green">【Note】:  <br>
1）当参数是一个函数模板实例的地址时，程序上下文必须满则：对每个模板参数能唯一确定其类型或值。</font></p>

<p><font size="4"><strong>5、模板实参推断和引用</strong></font></p>

<p><font size="4"><strong>（1）从左值引用函数参数推断类型</strong></font></p>

<p>  <font size="4">当一个函数类型参数是普通的左值引用时，规定只能传递给它一个左值（一个变量或一个引用的表达式），实参可以是const类型也可以不是。 <br>
  <font size="4">如果实参是const类型，T将会被推断是const类型。如果函数类型参数是const&amp;T时，我们可以传递任何类型的实参，一个对象，一个临时对象或者字面值常量。</font></font></p>

<p><font size="4"><strong>（2）从右值引用函数参数推断类型</strong></font></p>

<p>  <font size="4">我们可以传递一个右值，推断规则类似左值引用。左值不能绑定在右值引用上，但是有两个例外规则。 <br>
<font size="4"> <br>
 - 当我们将一个左值传递给函数的右值引用参数时，编译器推断模板类型参数为实参的左值引用类型。注意是引用。比如传递给模板函数参数T &amp;&amp;一个int i,推断出来的类型就是int &amp;。 <br>
 - 如果我们间接创建一个引用的引用就会形成引用折叠，引用折叠在大部分情况下会形成一个普通的左值引用，但是在右值引用的引用情况下会生成右值引用。 <br>
  <font size="4" color="red">X&amp;  &amp;, X&amp;  &amp;&amp;和X&amp;&amp;  &amp;都折叠成X&amp;</font> <br>
  <font size="4" color="red">X&amp;&amp;  &amp;&amp;折叠成X&amp;&amp;</font> <br>
<font size="4" color="green">【Note】:  <br>
1）引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。 <br>
2）若模版函数参数为右值引用，则可以绑定一个左值，且如果传入实参是左值的话，编译器推断出的模版实参类型将是一个左值的引用，且函数参数将会被实例化一个普通的左值引用类型。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/*******************
*模板实参推断和引用。
********************/</span>
<span class="hljs-comment">//当模版参数类型是一个左值引用时(T&amp;)，只能传递给它一个左值（一个变量、一个返回引用类型的表达式），</span>
<span class="hljs-comment">//实参可以是const类型，如果实参是const，T将会被推断为const类型。</span>
template &lt;typename T&gt;
<span class="hljs-keyword">void</span> f4(T &amp;t)
{
    cout &lt;&lt; t &lt;&lt; endl;
}

template &lt;typename T&gt;
<span class="hljs-keyword">void</span> f4(T &amp;&amp;t)
{
    cout &lt;&lt; t &lt;&lt; endl;
}

f4(b3);<span class="hljs-comment">//实参是左值。</span>
f4(<span class="hljs-string">"f4"</span>);<span class="hljs-comment">//实参是右值。</span>
f4(b3);<span class="hljs-comment">//函数参数是指向模板类型实参的右值引用，则可以被绑定到左值上。---引用折叠。</span></code></pre>

<p><font size="4"><strong>6、 理解std::move</strong></font></p>

<p>  <font size="4">标准库move函数是使用右值引用模版的一个很好的例子，我们不能将一个右值的引用绑定到一个左值上，但是通过move函数就可以完成该操作，move可接收左值也可以接收右值。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">/**************
*理解std::move。
***************/</span>
<span class="hljs-comment">//通过引用折叠，T &amp;&amp;可以与任意类型的实参匹配，左值和右值皆可。</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;move(T &amp;&amp;t)
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);
}

<span class="hljs-built_in">string</span> s5 = <span class="hljs-built_in">std</span>::move(<span class="hljs-built_in">string</span>(<span class="hljs-string">"Hi"</span>));</code></pre>

<p><font size="4"><strong>7、 转发</strong></font></p>

<p>  <font size="4">某些函数需要将一个或多个实参连同类型传递给其他的函数，这种情况下我们需要保证实参的类型。 <br>
  <font size="4">如果一个函数参数是指向模版类型参数的右值引用（T&amp;&amp;）,则它对应的实参的const属性和右值/左值属性将得到保持，但此方法不能用于接受右值引用的函数。 <br>
  <font size="4">当用于一个指向模版参数类型的右值引用参数时（T&amp;&amp;），forward()会保持实参类型的每个细节，头文件为utility，后必须加显式模版参数。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/*****
*转发。
******/</span>
template &lt;typename F, typename IT1, typename IT2&gt;  
<span class="hljs-keyword">void</span> flip(F f, IT1 &amp;&amp;t1, IT2 &amp;&amp;t2)<span class="hljs-comment">//参数为右值引用，且使用forward传递参数，可以保证参数的每个细节不变。</span>
{  
    f(std::forward&lt;IT2&gt;(t2), std::forward&lt;IT1&gt;(t1));
}  

<span class="hljs-keyword">void</span> f(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> &amp;b)
{
    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ++b &lt;&lt; endl;
}

<span class="hljs-keyword">int</span> i6 = <span class="hljs-number">5</span>;  
flip(f, i6, <span class="hljs-number">42</span>);</code></pre>

<p><font size="4"><strong>8、 本节demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs java">#include &lt;bIts/stdc++.h&gt;
using namespace std;

<span class="hljs-javadoc">/***********************
*类型转换与模板类型参数。
************************/</span>
template &lt;typename T&gt;
T fobj(T a, T b)
{
    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; b &lt;&lt; endl;
}

template &lt;typename T&gt;
T fref(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)
{
    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; b &lt;&lt; endl;
}

template &lt;typename A, typename B&gt;
<span class="hljs-keyword">void</span> fcpe(<span class="hljs-keyword">const</span> A &amp;a, <span class="hljs-keyword">const</span> B &amp;b)
{
    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span>;
    cout &lt;&lt; b &lt;&lt; endl;
}

template &lt;typename T&gt;
ostream &amp;fprt(ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t)
{
    os &lt;&lt; t &lt;&lt; endl;
}

template &lt;typename T&gt;
T fcn(T a, <span class="hljs-keyword">int</span> b)
{
    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">", "</span> &lt;&lt; b &lt;&lt; endl;
}

<span class="hljs-javadoc">/*****************
*函数模板显示实参。
******************/</span>
template &lt;typename T1, typename T2, typename T3&gt;
T1 sum(T2 t2, T3 t3)
{
    T1 p = t2 + t3;
    <span class="hljs-keyword">return</span> p;
}

<span class="hljs-javadoc">/***********************
*尾置返回类型与类型转换。
************************/</span>
template &lt;typename T&gt;
auto sum2(<span class="hljs-keyword">const</span> T &amp;a,<span class="hljs-keyword">const</span> T &amp;b) -&gt;decltype(a+b)<span class="hljs-comment">//将函数的返回类型指定为a+b的类型。</span>
{
    <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-javadoc">/*******************
*函数指针和实参推断。
********************/</span>
template &lt;typename T&gt;
<span class="hljs-keyword">int</span> compare(<span class="hljs-keyword">const</span> T &amp;a, <span class="hljs-keyword">const</span> T &amp;b)
{
    <span class="hljs-keyword">return</span> a &lt; b ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span> ;
}

<span class="hljs-javadoc">/*******************
*模板实参推断和引用。
********************/</span>
<span class="hljs-comment">//当模版参数类型是一个左值引用时(T&amp;)，只能传递给它一个左值（一个变量、一个返回引用类型的表达式），</span>
<span class="hljs-comment">//实参可以是const类型，如果实参是const，T将会被推断为const类型。</span>
template &lt;typename T&gt;
<span class="hljs-keyword">void</span> f4(T &amp;t)
{
    cout &lt;&lt; t &lt;&lt; endl;
}

template &lt;typename T&gt;
<span class="hljs-keyword">void</span> f4(T &amp;&amp;t)
{
    cout &lt;&lt; t &lt;&lt; endl;
}

<span class="hljs-javadoc">/**************
*理解std::move。
***************/</span>
<span class="hljs-comment">//通过引用折叠，T &amp;&amp;可以与任意类型的实参匹配，左值和右值皆可。</span>
template &lt;typename T&gt;
typename remove_reference&lt;T&gt;::type &amp;&amp;move(T &amp;&amp;t)
{
    <span class="hljs-keyword">return</span> static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);
}

<span class="hljs-javadoc">/*****
*转发。
******/</span>
template &lt;typename F, typename IT1, typename IT2&gt;  
<span class="hljs-keyword">void</span> flip(F f, IT1 &amp;&amp;t1, IT2 &amp;&amp;t2)<span class="hljs-comment">//参数为右值引用，且使用forward传递参数，可以保证参数的每个细节不变。</span>
{  
    f(std::forward&lt;IT2&gt;(t2), std::forward&lt;IT1&gt;(t1));
}  

<span class="hljs-keyword">void</span> f(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> &amp;b)
{
    cout &lt;&lt; a &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; ++b &lt;&lt; endl;
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{

    <span class="hljs-javadoc">/***********************
    *类型转换与模板类型参数。
    ************************/</span>
    string s1(<span class="hljs-string">"a string"</span>);
    <span class="hljs-keyword">const</span> string s2(<span class="hljs-string">"anthor string"</span>);
    fobj(s1, s2);
    fref(s1, s2);<span class="hljs-comment">//将s1转换为const是允许的。</span>
    <span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>], b[<span class="hljs-number">10</span>];
    fobj(a, b);<span class="hljs-comment">//数组名转换为指针，打印地址。</span>
    fcpe(<span class="hljs-number">0.1</span>, <span class="hljs-number">10</span>);<span class="hljs-comment">//第一个为float，第二个为int被提升为float。</span>
    fprt(cout, <span class="hljs-number">10</span>);<span class="hljs-comment">//严格匹配。</span>
    <span class="hljs-keyword">char</span> c = <span class="hljs-string">'b'</span>;
    fcn(c, <span class="hljs-string">'c'</span>);<span class="hljs-comment">//char提升为int。字符c表示的ASCII码。</span>

    <span class="hljs-javadoc">/*****************
    *函数模板显示实参。
    ******************/</span>
    <span class="hljs-keyword">long</span> lng = <span class="hljs-number">1000000</span>;
    auto val2 = sum&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;(<span class="hljs-number">1</span>,lng);<span class="hljs-comment">//显式模板实参。</span>
    cout &lt;&lt; val2 &lt;&lt; endl;

    <span class="hljs-javadoc">/***********************
    *尾置返回类型与类型转换。
    ************************/</span>
    <span class="hljs-keyword">int</span> a3 = <span class="hljs-number">566669</span>;
    <span class="hljs-keyword">int</span> b3 = <span class="hljs-number">59</span>;
    cout &lt;&lt; sum2(a3, b3) &lt;&lt; endl;<span class="hljs-comment">//处理足够大小的数相加。</span>

    <span class="hljs-javadoc">/*******************
    *函数指针和实参推断。
    ********************/</span>
    <span class="hljs-keyword">int</span> (*p)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;) = compare;
    cout &lt;&lt; p(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<span class="hljs-comment">//p是指向函数的指针,使用指针来推断模板实参为int。</span>

    <span class="hljs-javadoc">/*******************
    *模板实参推断和引用。
    ********************/</span>
    f4(b3);<span class="hljs-comment">//实参是左值。</span>
    f4(<span class="hljs-string">"f4"</span>);<span class="hljs-comment">//实参是右值。</span>
    f4(b3);<span class="hljs-comment">//函数参数是指向模板类型实参的右值引用，则可以被绑定到左值上。---引用折叠。</span>

    <span class="hljs-javadoc">/**************
    *理解std::move。
    ***************/</span>
    <span class="hljs-comment">//string s5 = std::move(string("Hi"));</span>

    <span class="hljs-javadoc">/*****
    *转发。
    ******/</span>
    <span class="hljs-keyword">int</span> i6 = <span class="hljs-number">5</span>;  
    flip(f, i6, <span class="hljs-number">42</span>);

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="5"><strong>三、重载与模板</strong></font></p>

<p>  <font size="4"> 函数模版可以被另一个模版或者普通非模版函数重载：相同名字函数，具有不同数量或者类型的参数。 <br>
  <font size="4">若模版被重载，则函数的匹配会发生变化： <br>
<font size="4" color="red"> <br>
 - 匹配过程中，候选函数包括所有的模版实参推断成功的模版实例。 <br>
 - 可行函数按类型转换来排序，需要类型转换的排在不需要转换的后面。 <br>
 - 若有多个函数提供同样的匹配：若是非模版函数，选择非模版函数。若没有非模版函数，则那个模版的特例高，选哪个，否则的话，此调用会产生歧义。 <br>
<font size="4" color="green">【Note】:  <br>
1）若多个模版皆为精确匹配，正常情况下无法区分，但是更特例化的的模版排在前面，比如const T&amp;和T*p，T *p更加特例化。 <br>
2）对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。 <br>
3）在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</font></font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;list&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-comment">//所有模版的声明都需要在函数定义前声明。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> f(T t)  
{  
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"f:T t："</span>&lt;&lt;t&lt;&lt;endl;  
}  

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> g(T *t)  
{  
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"g:T *t："</span>&lt;&lt;t&lt;&lt;endl;  
}  

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> g(T t)  
{  
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"g:T t："</span>&lt;&lt;t&lt;&lt;endl;  
}  

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">void</span> f(<span class="hljs-keyword">const</span> T *t)  
{  
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"f:const T*："</span>&lt;&lt;t&lt;&lt;endl;  
}  

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)
{
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>,*p = &amp;i;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>, *p2 = &amp;ci;

    g(<span class="hljs-number">42</span>);<span class="hljs-comment">//调用g(T t)</span>
    g(p);<span class="hljs-comment">//调用g(T *t)</span>
    g(ci);<span class="hljs-comment">//调用g(T t)</span>
    g(p2);<span class="hljs-comment">//调用g(T *t)</span>
    f(<span class="hljs-number">42</span>);<span class="hljs-comment">//调用f(T t)</span>
    f(p);<span class="hljs-comment">//调用f(T t)</span>
    f(ci);<span class="hljs-comment">//调用f(T t)</span>
    f(p2);<span class="hljs-comment">//调用f(const T *t)</span>
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="5"><strong>四、可变参数模板（c++11）</strong></font></p>

<p>  <font size="4" color="blue">可变函数模版就是指一个接受可变数目参数的模版函数或者模版类，可变数目的参数被称为参数包，分为两种：模版参数包，表示零个或多个模版参数，函数参数包，表示零个或多个函数参数。利用一个省略号来表示一个模版参数或者函数参数为一个包。</font> <br>
  <font size="4">当我们需要知道包中有多少元素时，我们可以使用sizeof…()运算符(注意有省略号)，值求出参数的数目。 <br>
  <font size="4">与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译器还会推断包中参数的数目。 </font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... U&gt; 
<span class="hljs-keyword">void</span> Foo(<span class="hljs-keyword">const</span> T &amp;, <span class="hljs-keyword">const</span> U &amp;...dest)  
{  
    <span class="hljs-comment">//U表示一个模版参数包，dest表示一个函数参数包。</span>
    <span class="hljs-comment">//当我们需要知道包中有多少元素时，我们可以使用sizeof...()运算符(注意有省略号)，值求出参数的数目。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>...(U) &lt;&lt; endl;  
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>...(dest) &lt;&lt; endl;  
}  </code></pre>

<p><font size="4"><strong>1、编写可变参数函数模板</strong></font></p>

<p>  <font size="4">以前说过initializer_list定义一个可变数目参数的函数，但是类型是指定的。 <br>
  <font size="4"><font size="4" color="green">当我们不知道参数的数目和参数的类型时</font>，可变参数函数是很有用的。可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身。 <br>
  <font size="4">当定义可变参数版本的函数时，非可变参数版本的声明必须在作用域中，否则，可变参数版本会无限递归。好的做法是都在最开始声明。</font></font></font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">/*********************
*编写可变参数函数模板。
**********************/</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-comment">//非可变参数版本，递归的最后一次调用会选择该版本，因为比较特例化。</span>
<span class="hljs-comment">//必须声明在可变参数模板的定义之前，否则可变参数模板会无限递归。</span>
<span class="hljs-built_in">std</span>::ostream &amp;print(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t)
{    
    <span class="hljs-keyword">return</span> os &lt;&lt; t;    
}    
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;    
<span class="hljs-built_in">std</span>::ostream &amp;print(<span class="hljs-built_in">std</span>::ostream &amp;os,<span class="hljs-keyword">const</span> T &amp;t,<span class="hljs-keyword">const</span> Args&amp;... args)    
{    
    os &lt;&lt; t &lt;&lt; <span class="hljs-string">", "</span>;
    <span class="hljs-keyword">return</span> print(os, args...); 
}    

print(<span class="hljs-built_in">cout</span>, <span class="hljs-number">42</span>) &lt;&lt; endl;
print(<span class="hljs-built_in">cout</span>, <span class="hljs-number">42</span>, a) &lt;&lt; endl;
print(<span class="hljs-built_in">cout</span>, <span class="hljs-number">42</span>, a, q, <span class="hljs-string">"hello"</span>, <span class="hljs-string">'w'</span>) &lt;&lt; endl;</code></pre>

<p><font size="4"><strong>2、包扩展</strong></font></p>

<p>  <font size="4">对于一个参数包，我们还可以对其进行参数扩展，即将一个包分解为其构成元素，我们通过在模式的右边放一个省略号…来出发扩展操作。 <br>
  <font size="4" color="red">我们还可以对作为参数的函数进行扩展，但注意省略号的位置，不是对函数参数的扩展。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-comment">//打印我们不能处理的类型。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(<span class="hljs-keyword">const</span> T &amp;s)    
{    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> ret;    
    ret &lt;&lt; s;    
    <span class="hljs-keyword">return</span> ret.str();<span class="hljs-comment">//返回ret绑定的string的一个副本。</span>
} 

<span class="hljs-comment">//打印指针的值，后跟指针指向的对象。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(T *p)    
{    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> ret;    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"point:"</span> &lt;&lt; p;<span class="hljs-comment">//打印指针本身的值。 </span>
    <span class="hljs-keyword">if</span> (p)    
        ret &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; debug_rep(*p);    
    <span class="hljs-keyword">else</span>    
        ret &lt;&lt; <span class="hljs-string">"point is NULL!"</span>;    
    <span class="hljs-keyword">return</span> ret.str();    
} 

<span class="hljs-comment">//打印双引号包围的string。</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s)    
{    
    <span class="hljs-keyword">return</span> <span class="hljs-string">'"'</span> + s + <span class="hljs-string">'"'</span>;    
}    

<span class="hljs-comment">//将字符指针转换为string，并调用string版本的debug_rep。</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(<span class="hljs-keyword">char</span> *p)    
{    
    <span class="hljs-keyword">return</span> debug_rep(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(p));    
}    

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)    
{    
    <span class="hljs-keyword">return</span> debug_rep(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(p));    
}    

<span class="hljs-comment">//包扩展：参数包中每个元素调用debug_rep。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;    
<span class="hljs-built_in">std</span>::ostream &amp;errorMsg(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> Args... args)    
{    
    <span class="hljs-keyword">return</span> print(os, debug_rep(args)...);    
}    

<span class="hljs-built_in">string</span> str = <span class="hljs-string">"c++"</span>;    
errorMsg(<span class="hljs-built_in">cout</span>, str, <span class="hljs-string">"primer"</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8.6</span>, <span class="hljs-string">'5'</span>); </code></pre>

<p><font size="4"><strong>3、本节demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... U&gt; 
<span class="hljs-keyword">void</span> Foo(<span class="hljs-keyword">const</span> T &amp;, <span class="hljs-keyword">const</span> U &amp;...dest)  
{  
    <span class="hljs-comment">//U表示一个模版参数包，dest表示一个函数参数包。</span>
    <span class="hljs-comment">//当我们需要知道包中有多少元素时，我们可以使用sizeof...()运算符(注意有省略号)，值求出参数的数目。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>...(U) &lt;&lt; endl;  
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>...(dest) &lt;&lt; endl;  
}  

<span class="hljs-comment">/*********************
*编写可变参数函数模板。
**********************/</span>

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-comment">//非可变参数版本，递归的最后一次调用会选择该版本，因为比较特例化。</span>
<span class="hljs-comment">//必须声明在可变参数模板的定义之前，否则可变参数模板会无限递归。</span>
<span class="hljs-built_in">std</span>::ostream &amp;print(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t)
{    
    <span class="hljs-keyword">return</span> os &lt;&lt; t;    
}    
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;    
<span class="hljs-built_in">std</span>::ostream &amp;print(<span class="hljs-built_in">std</span>::ostream &amp;os,<span class="hljs-keyword">const</span> T &amp;t,<span class="hljs-keyword">const</span> Args&amp;... args)    
{    
    os &lt;&lt; t &lt;&lt; <span class="hljs-string">", "</span>;
    <span class="hljs-keyword">return</span> print(os, args...); 
}    

<span class="hljs-comment">//打印我们不能处理的类型。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(<span class="hljs-keyword">const</span> T &amp;s)    
{    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> ret;    
    ret &lt;&lt; s;    
    <span class="hljs-keyword">return</span> ret.str();<span class="hljs-comment">//返回ret绑定的string的一个副本。</span>
} 

<span class="hljs-comment">//打印指针的值，后跟指针指向的对象。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(T *p)    
{    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span> ret;    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"point:"</span> &lt;&lt; p;<span class="hljs-comment">//打印指针本身的值。 </span>
    <span class="hljs-keyword">if</span> (p)    
        ret &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; debug_rep(*p);    
    <span class="hljs-keyword">else</span>    
        ret &lt;&lt; <span class="hljs-string">"point is NULL!"</span>;    
    <span class="hljs-keyword">return</span> ret.str();    
} 

<span class="hljs-comment">//打印双引号包围的string。</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s)    
{    
    <span class="hljs-keyword">return</span> <span class="hljs-string">'"'</span> + s + <span class="hljs-string">'"'</span>;    
}    

<span class="hljs-comment">//将字符指针转换为string，并调用string版本的debug_rep。</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(<span class="hljs-keyword">char</span> *p)    
{    
    <span class="hljs-keyword">return</span> debug_rep(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(p));    
}    

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> debug_rep(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)    
{    
    <span class="hljs-keyword">return</span> debug_rep(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(p));    
}    

<span class="hljs-comment">//包扩展：参数包中每个元素调用debug_rep。</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;    
<span class="hljs-built_in">std</span>::ostream &amp;errorMsg(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> Args... args)    
{    
    <span class="hljs-keyword">return</span> print(os, debug_rep(args)...);    
}    

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)  
{  
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;  
    <span class="hljs-built_in">string</span> q = <span class="hljs-string">"54"</span>;  
    <span class="hljs-keyword">double</span> a = <span class="hljs-number">3.14</span>;  
    Foo(i, q, <span class="hljs-number">45</span>, a);  
    Foo(i, q, <span class="hljs-number">45</span>);  
    Foo(i, q);  
    Foo(i);

    <span class="hljs-comment">/*********************
    *编写可变参数函数模板。
    **********************/</span>
    print(<span class="hljs-built_in">cout</span>, <span class="hljs-number">42</span>) &lt;&lt; endl;
    print(<span class="hljs-built_in">cout</span>, <span class="hljs-number">42</span>, a) &lt;&lt; endl;
    print(<span class="hljs-built_in">cout</span>, <span class="hljs-number">42</span>, a, q, <span class="hljs-string">"hello"</span>, <span class="hljs-string">'w'</span>) &lt;&lt; endl;

    <span class="hljs-comment">/*******
    *包扩展。
    ********/</span>
    <span class="hljs-built_in">string</span> str = <span class="hljs-string">"c++"</span>;    
    errorMsg(<span class="hljs-built_in">cout</span>, str, <span class="hljs-string">"primer"</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8.6</span>, <span class="hljs-string">'5'</span>);    

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  </code></pre>

<p><img src="http://img.blog.csdn.net/20180201155126268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="5"><strong>五、模板特例化</strong></font></p>

<p>  <font size="4"><font size="4" color="red">当我们不能（或者不希望）使用模版版本时，我们可以定义类模版或者函数模版的一个特例化版本</font>：比如说函数模版中的处理不适用于未定义&lt;运算符（指针类型）的情况，我们就可以特例化一个版本已使用特殊情况。一个特例化版本就是模版的一个独立的定义，在其中一个或者多个参数被特定为指定的类型 <br>
  <font size="4" color="blue">在为函数模版特例化时，必须为函数模版的每个模版参数提供实参，尖括号中的模版参数去掉，但是必须提供实参。 <br>
<font size="4" color="green">【Note】:  <br>
1）特例化的本质是实例化一个模版，而非重载，因此特例化不影响函数的重载，它不是一个非模版的独立函数。 <br>
2）模版及其特例化版本应该定义在一个头文件中，所有同名的模版的声明应该放在前面，然后是这些特例化的声明。 <br>
3）类模版也可以进行特例化，需要在原模版定义所在的命名空间中特例化。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;   </span>
<span class="hljs-keyword">class</span> Sales_data    
{    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo;    
    <span class="hljs-keyword">unsigned</span> units_sold;    
    <span class="hljs-keyword">double</span> revenue;    
    <span class="hljs-keyword">double</span> avg_price()<span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> units_sold ? revenue / units_sold : <span class="hljs-number">0</span>; }    
<span class="hljs-keyword">public</span>:    
    Sales_data(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s=<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(), <span class="hljs-keyword">unsigned</span> n = <span class="hljs-number">0</span>, <span class="hljs-keyword">double</span> p = <span class="hljs-number">0</span>) :bookNo(s), units_sold(n), revenue(p) {}    
    Sales_data(<span class="hljs-built_in">std</span>::istream &amp;is);    
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> isbn()<span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> bookNo; }    
    Sales_data &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> Sales_data &amp;s);    
    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::hash&lt;Sales_data&gt;;    
    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;s);    
    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(<span class="hljs-built_in">std</span>::istream &amp;is, Sales_data &amp;s);    
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Sales_data &amp;ls, <span class="hljs-keyword">const</span> Sales_data &amp;rs);    
    <span class="hljs-keyword">friend</span> Sales_data <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Sales_data &amp;ls, <span class="hljs-keyword">const</span> Sales_data &amp;rs);    
    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::ostream &amp;print(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;s);    
    <span class="hljs-keyword">friend</span> <span class="hljs-built_in">std</span>::istream &amp;read(<span class="hljs-built_in">std</span>::istream &amp;is, Sales_data &amp;s);    
};    
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Sales_data &amp;ls, <span class="hljs-keyword">const</span> Sales_data &amp;rs);    
Sales_data add(<span class="hljs-keyword">const</span> Sales_data &amp;ls, <span class="hljs-keyword">const</span> Sales_data &amp;rs);    

<span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>    
{    
    <span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">//特例化一个版本，模板参数为Sales_data。</span>
    <span class="hljs-keyword">struct</span> hash&lt;Sales_data&gt;    
    {    
        <span class="hljs-comment">//用来散列一个无序容器的类型必须定义以下类型。</span>
        <span class="hljs-keyword">typedef</span> size_t result_type;    
        <span class="hljs-keyword">typedef</span> Sales_data argument_type;    
        size_t <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> Sales_data &amp;s)<span class="hljs-keyword">const</span> {   
            <span class="hljs-comment">//对哈希值进行异或运算。 </span>
            <span class="hljs-keyword">return</span> hash&lt;<span class="hljs-built_in">string</span>&gt;()(s.bookNo) ^ hash&lt;<span class="hljs-keyword">unsigned</span>&gt;()(s.units_sold) ^ hash&lt;<span class="hljs-keyword">double</span>&gt;()(s.revenue);    
        }    
    };    
}    

Sales_data::Sales_data(<span class="hljs-built_in">std</span>::istream &amp;is)    
{    
    is &gt;&gt; *<span class="hljs-keyword">this</span>;    
}    

Sales_data &amp;Sales_data::<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> Sales_data &amp;s)    
{    
    units_sold += s.units_sold;    
    revenue += s.revenue;    
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;    
}    

<span class="hljs-built_in">std</span>::ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;s)    
{    
    os &lt;&lt; s.isbn() &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; s.units_sold &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; s.revenue &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; s.avg_price();    
    <span class="hljs-keyword">return</span> os;    
}    

<span class="hljs-built_in">std</span>::istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(<span class="hljs-built_in">std</span>::istream &amp;is, Sales_data &amp;s)    
{    
    <span class="hljs-keyword">double</span> price;    
    is &gt;&gt; s.bookNo &gt;&gt; s.units_sold &gt;&gt; price;    
    <span class="hljs-keyword">if</span> (is)    
        s.revenue = s.units_sold*price;    
    <span class="hljs-keyword">else</span>    
        s = Sales_data();    
    <span class="hljs-keyword">return</span> is;    
}    

<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Sales_data &amp;ls, <span class="hljs-keyword">const</span> Sales_data &amp;rs)    
{    
    <span class="hljs-keyword">return</span> ls.bookNo == rs.bookNo&amp;&amp;ls.units_sold == rs.units_sold&amp;&amp;ls.revenue == rs.revenue;    
}    
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Sales_data &amp;ls, <span class="hljs-keyword">const</span> Sales_data &amp;rs)    
{    
    <span class="hljs-keyword">return</span> !(ls == rs);    
}    

Sales_data <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Sales_data &amp;ls, <span class="hljs-keyword">const</span> Sales_data &amp;rs)    
{    
    Sales_data temp = ls;    
    temp += rs;    
    <span class="hljs-keyword">return</span> temp;    
}    

Sales_data add(<span class="hljs-keyword">const</span> Sales_data &amp;ls, <span class="hljs-keyword">const</span> Sales_data &amp;rs)    
{    
    Sales_data temp = ls;    
    temp += rs;    
    <span class="hljs-keyword">return</span> temp;    
}    

<span class="hljs-built_in">std</span>::ostream &amp;print(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> Sales_data &amp;s)    
{    
    os &lt;&lt; s.isbn() &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; s.units_sold &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; s.revenue &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; s.avg_price();    
    <span class="hljs-keyword">return</span> os;    
}    

<span class="hljs-built_in">std</span>::istream &amp;read(<span class="hljs-built_in">std</span>::istream &amp;is, Sales_data &amp;s)    
{    
    <span class="hljs-keyword">double</span> price;    
    is &gt;&gt; s.bookNo &gt;&gt; s.units_sold &gt;&gt; price;    
    s.revenue = s.units_sold*price;    
    <span class="hljs-keyword">return</span> is;    
}    

<span class="hljs-keyword">int</span> main()    
{    
    <span class="hljs-built_in">std</span>::<span class="hljs-stl_container"><span class="hljs-built_in">unordered_multiset</span>&lt;Sales_data&gt;</span> mset;    
    Sales_data sd(<span class="hljs-string">"Bible"</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0.98</span>);    

    mset.emplace(sd);    
    mset.emplace(<span class="hljs-string">"C++ Primer"</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9.99</span>);    

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;item : mset)    
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"the hash code of "</span> &lt;&lt; item.isbn()    
        &lt;&lt; <span class="hljs-string">":\n0x"</span> &lt;&lt; <span class="hljs-built_in">std</span>::hex &lt;&lt; <span class="hljs-built_in">std</span>::hash&lt;Sales_data&gt;()(item)    
        &lt;&lt; <span class="hljs-string">"\n"</span>;    
    system(<span class="hljs-string">"pause"</span>);    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    
}    </code></pre>

<p><img src="http://img.blog.csdn.net/20180201155833664?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/02/01 16:08:54 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79229853">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79229853                    </div>
                    <div>
                        阅读：110                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]面向对象程序设计]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79183326</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79183326</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/01/27 21:17:05</pubDate>
                <description>
                    <![CDATA[
                    <p><font size="5"><strong>一、对象数组与对象指针</strong></font> <br>
  <font size="4">学习完智能指针后我们就可以用智能指针new一个对象或者进行动态分配：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> Coordinate
{
<span class="hljs-keyword">public</span>:
    Coordinate() = <span class="hljs-keyword">default</span>;
    Coordinate(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y):m_ix(x) ,m_iy(y)
    { 
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Coordinate"</span> &lt;&lt; endl; 
    }
    ~Coordinate() 
    { 
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~Coordinate"</span> &lt;&lt; endl; 
    }
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> print() { <span class="hljs-keyword">return</span> m_ix + m_iy; }
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> setvalue(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1) { m_ix = x1 ;m_iy = y1 ; } 
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_ix = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> m_iy = <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-comment">//使用智能指针。</span>
    <span class="hljs-comment">//对象指针：</span>
    unique_ptr&lt;Coordinate&gt; p1(<span class="hljs-keyword">new</span> Coordinate(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>));
    <span class="hljs-built_in">cout</span> &lt;&lt; p1-&gt;print() &lt;&lt; endl;

    <span class="hljs-comment">//对象数组：</span>
    unique_ptr&lt;Coordinate []&gt; p2(<span class="hljs-keyword">new</span> Coordinate[<span class="hljs-number">3</span>]);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)
    {
        p2[i].setvalue(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);
        <span class="hljs-built_in">cout</span> &lt;&lt; p2[i].print() &lt;&lt; endl;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="5"><strong>二、OOP概述</strong></font> <br>
  <font size="4" color="red">面向对象程序设计的核心思想是：数据抽象（类），继承和动态绑定。使用继承：可以定义相似的类型并对其相似关系建模。使用动态绑定：可以在一定成都上忽略相似类型的区别，而以统一的方式使用他们的对象。</font></p>

<p><font size="4"><strong>1、继承</strong></font> <br>
  <font size="4">通过继承联系在一起的类构成一种层次关系，根部是一个<font size="4" color="green">基类，其他类直接或间接继从基类继承而来。</font> <br>
  <font size="4">继承得到的类叫做派生类。<font size="4" color="blue">基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</font> <br>
  <font size="4" color="red">某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为虚函数。</font></font></font></p>

<p>  <font size="4" color="green">【Note】： <br>
1）派生类必须通过派生类列表（首先是一个冒号，后面紧跟以逗号分隔的基类列表）来指明是那个基类的派生类以及访问权限。 <br>
2）派生类必须在其内部对所有重新定义的虚函数进行声明。</font></p>

<p>  <font size="4"><strong>什么不能被继承：</strong><font size="4"> <br>
 - 构造函数（C++11使用using声明可“继承”）； <br>
 - 析构函数； <br>
 - 私有成员函数； <br>
 - 赋值操作符； <br>
 - 友元函数。</font></font></p>

<p><font size="4"><strong>2、动态绑定</strong></font> <br>
  <font size="4">有时我们需要定义一个函数来处理基类和派生类，比如输出函数，根据实际传入的参数来决定到底输出那个类的数据。函数的运行版本由实参决定，既在运行时选择函数的版本，所以动态绑定有时被称为运行时绑定。 <br>
  <font size="4" color="green">【Note】： <br>
1）在c++中，我们使用基类的引用或指针调用一个虚函数时会发生动态绑定。</font></font></p>

<p><font size="5"><strong>三、 定义基类和派生类</strong></font></p>

<p><font size="4"><strong>1、定义基类</strong></font> <br>
  <font size="4" color="red">基类通常都应该定义一个虚构函数，即使虚构函数不执行任何实际操作也是如此。</font> <br>
  <font size="4">派生类可以继承基类的成员，派生类需要对这些操作提供自己的新定义以<font size="4" color="blue">覆盖（override）</font>从基类继承而来的就定义。 <br>
  <font size="4">任何构造函数之外的<font size="4" color="red">非静态函数</font>都可以是虚函数，<font size="4" color="green">关键字virtual</font>只能出现在类内部的声明语句之前而不能用于类外部的函数定义。 <br>
  <font size="4">c++是静态类型的语言，其解析过程发生在编译期间，但对于虚函数是在运行期间动态绑定。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cs">class Quote
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">Quote</span>() = <span class="hljs-keyword">default</span>;
    Quote(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> &amp;book, <span class="hljs-keyword">double</span> sales_price):bookNo(book), price(sales_price){}
    <span class="hljs-keyword">string</span> isbn() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> bookNo; }
    <span class="hljs-comment">//返回给定数量的书籍的销售总额。</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> net_price(size_t n) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> n * price;
    }
    <span class="hljs-comment">//对析构函数进行动态绑定。</span>
    <span class="hljs-keyword">virtual</span> ~Quote() = <span class="hljs-keyword">default</span>;
    <span class="hljs-comment">//该虚函数返回当前对象的一份动态分配的拷贝，左值和右值引用限定符。</span>
    <span class="hljs-keyword">virtual</span> Quote *clone() <span class="hljs-keyword">const</span> &amp; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Quote(*<span class="hljs-keyword">this</span>); }
    <span class="hljs-keyword">virtual</span> Quote *clone()  &amp;&amp; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Quote(std::move(*<span class="hljs-keyword">this</span>)); }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">string</span> bookNo;
<span class="hljs-keyword">protected</span>:
    <span class="hljs-keyword">double</span> price = <span class="hljs-number">0.0</span>;
};</code></pre>

<p><font size="4"><strong>2、定义派生类</strong></font></p>

<pre class="prettyprint"><code class=" hljs cs">class Bulk_quote : <span class="hljs-keyword">public</span> Quote
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">Bulk_quote</span>() = <span class="hljs-keyword">default</span>;
    <span class="hljs-comment">//覆盖基类的函数版本以实现基于大量购买的折扣政策。</span>
    Bulk_quote(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span>&amp; book, <span class="hljs-keyword">double</span> p, size_t qty, <span class="hljs-keyword">double</span> disc):
                Quote(book,p), min_qty(qty), discount(disc){}<span class="hljs-comment">//首先初始化基类，然后初始化派生类的成员。</span>
    <span class="hljs-keyword">double</span> net_price(size_t) <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span>;
    Bulk_quote *clone() <span class="hljs-keyword">const</span> &amp; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bulk_quote(*<span class="hljs-keyword">this</span>); }
    Bulk_quote *clone()  &amp;&amp; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bulk_quote(std::move(*<span class="hljs-keyword">this</span>)); }
<span class="hljs-keyword">private</span>:
    size_t min_qty = <span class="hljs-number">0</span>;<span class="hljs-comment">//最低购买量。</span>
    <span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//折扣率。</span>
};</code></pre>

<p>  <font size="4"> 派生类必须通过使用派生类列表明确指出它是从哪个基类继承而来的。 <br>
  <font size="4">派生类需要对其继承而来的成员函数中需要覆盖的那些进行重新声明。 <br>
  <font size="4">派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。 <br>
  <font size="4" color="red">派生类可以访问基类的public和protected成员。</font></font></font></font></p>

<p><font size="4"><strong>（1）派生类对象及派生类向基类的类型转换</strong></font> <br>
  <font size="4">一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象。在一个对象中，派生类继承基类的部分和派生类的部分不一定是连续存储的。 <br>
  <font size="4">因为派生类对象中包含与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，我们也能将基类的指针或引用绑定到派生类对象的基类部分。这种称为派生类到基类的类型转换，编译器会隐式的执行转换。</font></font></p>

<pre class="prettyprint"><code class=" hljs livecodeserver">Quote <span class="hljs-keyword">item</span><span class="hljs-comment">;//基类对象  </span>
bulk_quote bulk<span class="hljs-comment">;//派生类对象  </span>
Quote *p = &amp;<span class="hljs-keyword">item</span><span class="hljs-comment">;//P为一个指针，指向一个Quote类型对象  </span>
p = &amp;bulk<span class="hljs-comment">;//p指向的是bulk的Quote部分，也就是派生类的基类部分  </span>
Quote &amp;r = bulk<span class="hljs-comment">;//r绑定到bulk的基类部分  </span></code></pre>

<p>  <font size="4" color="green">【Note】： <br>
1）派生类内部继承基类的虚函数我们必须定义而不只能声明。 <br>
2）继承的关键：派生类中有基类的对应组成部分。</font></p>

<p><font size="4"><strong>（2）派生类构造函数</strong></font> <br>
  <font size="4">虽然派生类从基类继承了部分成员，但是并不能直接初始化这些成员。派生类必须使用基类的构造函数类初始化这些成员。 <br>
  <font size="4" color="green">【Note】： <br>
1）每个类控制它自己的成员的初始化过程。 <br>
2）派生类首先初始化基类的部分，然后按照声明的顺序依次初始化派生类部分。 <br>
3）每个类负责定义自己各自的接口，要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。</font></font></p>

<p><font size="4"><strong>（3）继承与静态成员</strong></font> <br>
  <font size="4">如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出多少个派生类，对于<font size="4" color="red">每个静态成员来说都只存在唯一的实例</font>。因为静态成员在全局区（静态区）。</font></p>

<p><font size="4"><strong>（4）被用作基类的类</strong></font> <br>
  <font size="4">如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。一个类是基类，同时它也可以是一个派生类。 <br>
  <font size="4">直接基类：直接继承基类。 <br>
  <font size="4">间接基类：继承基类的派生类。 <br>
最终的派生类将包含它的直接基类的子对象以及每个间接基类的子对象。</font></font></font></p>

<p><font size="4"><strong>（5）防止继承的发生</strong></font> <br>
  <font size="4">有时我们会希望定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。c++11提供了一种防止继承的方法就是在类名后面跟一个<font size="4" color="red">关键字final</font>。</font></p>

<p><font size="4"><strong>3、类型转换与继承</strong></font> <br>
  <font size="4">存在继承关系的类：我们可以将基类的指针或引用绑定到派生类上（是类型匹配绑定的一个例外）。<font size="4" color="blue">含义是当我们使用该指针或引用时，实际我们并不知道绑定对象的真实类型，可能是基类也可能是派生类。</font>智能指针类也支持这样的转换。我们可以在基类的智能指针存储派生类对象。</font></p>

<p><font size="4"><strong>（1）静态类型与动态类型</strong></font> <br>
  <font size="4"> 静态类型是在编译时就已知的,它是变量声明时的类型或表达式生成的类型。 <br>
  <font size="4">动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知道。 <br>
  <font size="4">但是如果表达式既不是指针也不是引用，则它的动态类型永远和静态类型一致。</font></font></font></p>

<p><font size="4"><strong>（2）不存在基类向派生类的隐式转换</strong></font> <br>
  <font size="4">派生类继承基类的所有，但是也可以通过虚函数来重新定义一些成员，在虚函数表中，重新定义就会覆盖（override）掉基类版本，所以基类并不完全是派生类的一部分，所以不存在从基类向派生类的自动类型转换。假如合法我们则可能访问到不存在的成员。 <br>
  <font size="4">如果我们要自己转换可以使用dynamic_cast请求类型转换，该转换的安全检查在运行时执行，如果我们知道某个类型是安全的那么可是使用static_cast来转换。</font></font></p>

<p><font size="4"><strong>（3）在对象之间不存在类型转换</strong></font> <br>
  <font size="4">派生类到基类的类型转换<font size="4" color="red">只针对与引用或者指针的类型</font>，其本类型是不支持的，即对象之间不存在类型转换。 <br>
  <font size="4" color="green">【Note】： <br>
1）当我们用一个派生类的对象给一个基类对象初始化或者赋值时，只有其基类的部分被拷贝、移动或者赋值，它的派生类部分将会被忽略掉。</font></font></p>

<p><font size="4"><strong>（4）关键点：</strong></font><font size="4"> <br>
 - 从派生类像基类类型转换只有对指针或者引用类型有效； <br>
 - 基类到派生类不存在隐式类型转换； <br>
 - 派生类到基类的类型转换也可能会由于访问限制而变得不可行。</font></p>

<p><font size="5"><strong>四、虚函数</strong></font> <br>
  <font size="4" color="red">当我们使用引用或者指针调用一个虚成员函数时才会执行动态绑定，因为我们知道在程序运行时才知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。OOP的核心思想之一多态性就是通过虚函数体现的。</font></p>

<p><font size="4"><strong>1、多态原理探究：</strong> <br>
  <font size="4">多态：同样一个函数在派生类和基类中有不同的形态。 <br>
  <font size="4" color="orange">多态性发生的三个条件：继承关系、虚函数覆盖、父类指针或引用指向子类对象。</font> <br>
  <font size="4">C++使用virtual关键实现多态，多态是设计模式的基础。 <br>
原理如下： <br>
 1. 当类中声明虚函数时，编译器会在类中生成一个<font size="4" color="blue">虚函数表（v table）</font> 在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证真实反应实际的函数。 <br>
 2. 虚函数表是一个存储类成员函数指针的数据结构，虚函数表是由编译器自动生成和维护的。 <br>
 3. virtual成员会被编译器放入虚函数表中，存在虚函数时，每个对象都有一个<font size="4" color="green">指向虚函数表的指针（vptr指针）。</font> <br>
所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表指明了实际所应该调用的函数。 <br>
<img src="http://img.blog.csdn.net/20180127194011691?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
<img src="http://img.blog.csdn.net/20180127194025680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
<img src="http://img.blog.csdn.net/20180127194040891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
<img src="http://img.blog.csdn.net/20180127194057682?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
  <font size="4">多态的理论基础就是函数指针。 <br>
<font size="4"><strong>2、对虚函数的调用可能在运行时才被解析</strong></font> <br>
  <font size="4">基类的引用或指针作为参数时可以传参基类或派生类，当我们使用引用或指针来传参绑定对象然后调用虚函数时实际上是动态绑定，此时我们不知道到底运行时调用的是哪个类型的虚函数，但是我们必须确保每个虚函数在被调用的时候必须可以使用。<font size="4" color="blue">引用或指针的静态类型与动态类型不同这一事实是c++语言支持多态性的根本所在。</font></font></font></font></font></font></p>

<p><font size="4"><strong>3、派生类的虚函数</strong></font> <br>
  <font size="4" color="green">基类中的虚函数在派生类中隐含的也是一个虚函数，当派生类覆盖了某个虚函数时，该函数在基类总的形参必须与派生类中的形参严格匹配。</font></p>

<p><font size="4"><strong>4、final和override说明符</strong></font> <br>
  <font size="4">派生类如果定义了一个与基类虚函数同名函数，但参数列表不相同的话，仍然是合法行为，编译器会认为该函数与基类虚函数是相互独立的，但这往往是把形参列表弄错了的错误，编译器发现不了，所以C++11有一个好东西，<font size="4" color="red">在其后加上override表示其要对基类的函数进行覆盖，若未覆盖，编译器报错，我们可以发现自己的错误。final的作用同上。可以跟在类后面说明不许被继承或者跟在虚函数后面说明不许后继的类继承。</font></font></p>

<p><font size="4"><strong>5、虚函数、默认实参和回避虚函数机制</strong></font> <br>
  <font size="4">如果我们在基类的虚函数中存在默认实参，那么当我们通过引用或指针来调用时使用的是基类的默认实参，即使调用的是派生类的虚函数也是如此。所以在定义默认实参的时候，基类和派生类的默认实参最好一致。 <br>
  <font size="4">在某些情况下我们不需要动态绑定，而是强迫执行虚函数的某个特定版本。通过作用域操作符可以实现这个目的。<font size="4" color="blue">通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数机制。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-comment">//返回给定数量的书籍的销售总额。</span>
<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> net_price(size_t n) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">return</span> n * price;
}

<span class="hljs-keyword">double</span> net_price(size_t) <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span>;</code></pre>

<p><font size="4"><strong>6、是否类的每个成员函数都可以声明为虚函数？</strong></font> <br>
  <font size="4">原则上是可以的，但是不建议使用。因为每声明一个虚函数都会加入到虚函数表中，但是并不是每个虚函数都要调用，所以会影响效率。</font></p>

<p><font size="5"><strong>五、抽象基类</strong></font> <br>
  <font size="4">抽象基类是把某一些具有相似特征的类抽象化，形成一个新的类，比如人。当多个类之间有相似的方法和数据成员时，可以定义一个抽象基类。</font></p>

<p><font size="4"><strong>1、纯虚函数</strong></font> <br>
  <font size="4" color="red">一个纯虚函数无需定义，我们通过在函数体的位置后面加上=0 即可。就可以将一个虚函数变为纯虚函数。其中=0只能出现在类内部的虚函数声明语句处。</font> <br>
  <font size="4">我们也可以为虚函数提供定义，不过函数体必须定义在类的外部，也就是说我们不能在类的内部为一个=0的函数提供函数体。</font></p>

<p><font size="4"><strong>2、含有纯虚函数的类是抽象基类</strong></font> <br>
  <font size="4" color="blue">含有（未经覆盖直接继承）纯虚函数的类是抽象基类，</font><font size="4">抽象基类负责定义接口，而后续的其他类可以覆盖接口，我们不能直接创建一个抽象基类的对象。我们可以定义抽象基类的派生类对象，前提是覆盖了纯虚函数的接口。 <br>
  <font size="4" color="red">我们不能创建抽象基类的对象。</font></font></p>

<p><font size="4"><strong>3、派生类构造函数只初始化它的直接基类</strong></font> <br>
  <font size="4">基类quote—–&gt;抽象基类disc_quote—–&gt;派生类bulk_quote。其中–&gt;表示继承关系。 <br>
  <font size="4">那么我们定义bulk_quote的构造函数时只能初始化disc_quote，在由disc_quote的构造函数来初始化quote的成员。 <br>
  <font size="4" color="green">关键概念重构： <br>
  重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中，对于面向对象的应用程序来说，重构是一种很普遍的现象。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>

<span class="hljs-keyword">class</span> quote
{
    <span class="hljs-keyword">public</span>:
        quote() = <span class="hljs-keyword">default</span>;
        quote(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;book, <span class="hljs-keyword">double</span> p):
            bookNo(book), price(p) { }
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> net_price(<span class="hljs-built_in">std</span>::size_t sz)<span class="hljs-keyword">const</span>     <span class="hljs-comment">//虚函数</span>
        { <span class="hljs-keyword">return</span> sz * price; }

    <span class="hljs-keyword">protected</span>:      <span class="hljs-comment">//因为派生类也需要有一份这样的成员所以定义为protected</span>
        <span class="hljs-keyword">double</span> price = <span class="hljs-number">0.0</span>;

    <span class="hljs-keyword">private</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> bookNo = <span class="hljs-string">""</span>;
};

<span class="hljs-keyword">class</span> disc_quote : <span class="hljs-keyword">public</span> quote  <span class="hljs-comment">//抽象基类，抽象出所有折扣的类</span>
{
    <span class="hljs-keyword">public</span>:
        disc_quote() = <span class="hljs-keyword">default</span>;
        <span class="hljs-comment">//构造函数初始化quote类时必须调用quote类的构造函数。</span>
        disc_quote(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;book, <span class="hljs-keyword">double</span> p, <span class="hljs-keyword">double</span> disc, <span class="hljs-built_in">std</span>::size_t num):   
            quote(book, p), discount(disc), limit_num(num) { }
        <span class="hljs-keyword">double</span> net_price(<span class="hljs-built_in">std</span>::size_t sz)<span class="hljs-keyword">const</span> = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">protected</span>:  <span class="hljs-comment">//定义成保护的成员，因为要被派生类继承。且每个派生类都有自己独一无二的成员</span>
        <span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;           <span class="hljs-comment">//表示折扣</span>
        <span class="hljs-built_in">std</span>::size_t limit_num = <span class="hljs-number">0</span>;       <span class="hljs-comment">//表示限定数量</span>
};

<span class="hljs-keyword">class</span> bulk_quote : <span class="hljs-keyword">public</span> disc_quote                        <span class="hljs-comment">//继承抽象基类，有一种具体的折扣策略</span>
{
    <span class="hljs-keyword">public</span>:
        bulk_quote() = <span class="hljs-keyword">default</span>;
        bulk_quote(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;book, <span class="hljs-keyword">double</span> p, <span class="hljs-keyword">double</span> disc, <span class="hljs-built_in">std</span>::size_t num):
            disc_quote(book, p, disc, num) { }
        <span class="hljs-keyword">double</span> net_price(<span class="hljs-built_in">std</span>::size_t sz)<span class="hljs-keyword">const</span> override   <span class="hljs-comment">//不加const错误，不是同一个函数了</span>
        {
            <span class="hljs-keyword">if</span>(sz &gt; limit_num)
                <span class="hljs-keyword">return</span> (sz-limit_num) * price * discount + limit_num * price;
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> sz * price;
        }

    <span class="hljs-keyword">private</span>:
};

<span class="hljs-keyword">int</span> main()
{
    quote q;
    <span class="hljs-comment">//disc_quote disc;       //error</span>
}</code></pre>

<p><font size="5"><strong>六、访问控制和继承</strong></font> <br>
<font size="4"><strong>1、受保护的成员</strong></font> <br>
  <font size="4" color="red">一个类使用protected关键字来说明哪些它希望与派生类 分享但那是不想被其他公共访问使用的成员。</font><font size="4"> <br>
 - 和私有成员类似，受保护的成员对于类的用户来说是不可访问的； <br>
 - 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的； <br>
 - 派生类的成员或友元只能通过派生类来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问权限。 <br>
  <font size="4" color="green">【Note】： <br>
1）派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类对象中的成员不具有特殊的访问权限。</font></font></p>

<p><font size="4"><strong>2、公有，私有和受保护继承</strong></font> <br>
  <font size="4" color="green">公有继承(public)、私有继承(private)、保护继承(protected)是常用的三种继承方式。</font> <br>
（1）公有继承(public) <br>
  <font size="4">公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。 <br>
（2）私有继承(private) <br>
  <font size="4">私有继承的特点是<font size="4" color="blue">基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。</font> <br>
（3）保护继承(protected) <br>
  <font size="4">保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且<font size="4" color="red">只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。</font></font></font></font></p>

<p><font size="4"><strong>3、派生类向基类转换的可访问性</strong></font> <br>
<font size="4"> <br>
 1. 只有当derive类共有的继承base类时，<font size="4" color="red">用户代码</font>才能使用派生类向基类的转换，<font size="4" color="red">如果derive继承base的方式是受保护的或者私有的，则用户代码不能使用该转换。</font> <br>
 2. 不论derive以什么方式继承base类，<font size="4" color="red">derive的成员函数和友元都能使用派生类向基类的转换，</font>派生类向其直接基类的类型转换对于派生类的成员和友元来说是永久可访问的。 <br>
 3. 如果derive继承base的方式是共有的或者受保护的，则<font size="4" color="red">derive的派生类的成员和友元可以使用derive向base的类型转换，反之，如果derive继承base的方式是私有的，则不能使用。</font></font></p>

<p><font size="4"><strong>4、友元与继承</strong></font> <br>
  <font size="4" color="green">友元关系不能传递，友元关系也不能继承。</font> <br>
  <font size="4">基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随便访问基类的成员。当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效，对于原来的那个类来说，其友元的基类或者派生类不具有特殊的访问能力。</font></p>

<p><font size="4"><strong>5、改变个别成员的可访问性</strong></font> <br>
  <font size="4">通过在类的内部使用using 声明语句，我们可以将该基类的直接或间接基类中的任何可访问成员标记出来，using 声明语句中名字的访问权限由它所在的访问说明符来决定。<font size="4"> <br>
 - 如果一条using 声明语句出现在类的private部分，则该名字只能由类的成员和友元来访问。 <br>
 - 如果一条using 声明语句出现在类的protect部分，则该名字能由类的成员和友元和派生类来访问。 <br>
 - 如果一条using 声明语句出现在类的public部分，则该名字能由类的所有用户访问。 <br>
  <font size="4" color="red">派生类只能为它可以访问的名字提供using 声明。</font></font></font></p>

<p><font size="4"><strong>6、默认的继承保护级别</strong></font> <br>
  <font size="4" color="blue"> class默认的成员访问符和默认的派生成员访问符是private。 <br>
  <font size="4" color="blue">struct默认的成员访问符和默认的派生成员访问符是public。 <br>
  <font size="4">这也是C和C++的一个不同点。</font></font></font></p>

<p><font size="5"><strong>七、继承着中的类作用域</strong></font> <br>
  <font size="4">每个类定义自己的作用域，在这个作用域内我们定义类的成员，当存在继承关系时，派生类的作用域嵌套在其基类作用域之内。如果一个名字在自己的作用域内无法解析，那么就会在基类中查找。 <br>
<font size="4"><strong>1、在编译时进行名字查找</strong></font> <br>
  <font size="4">一个对象，引用或指针的静态类型，决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。</font></font></p>

<p><font size="4"><strong>2、名字冲突和继承</strong></font> <br>
  <font size="4">和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（既派生类）的名字将隐藏定义在外层作用域（既基类）的名字。 <br>
  <font size="4" color="green">【Note】： <br>
1）简单来说就是派生类隐藏基类的同名成员。但是即使基类和派生类函数的参数列表不一样，也会被隐藏。 但是我们可以通过作用域符来使用一个被隐藏的基类成员。 <br>
2）除了覆盖掉继承而来的虚函数，派生类最好不要重用其他定义在基类的名字。 <br>
3）现在可以理解为什么基类和派生类的虚函数必须有相同的列表。调用非虚函数时不会发生动态绑定，实际调用的函数由指针的静态类型来决定。</font></font></p>

<p><font size="4"><strong>3、覆盖重载的函数</strong></font> <br>
  <font size="4">如果我们在派生类中定义与基类同名的函数，会覆盖基类中所有同名的函数，<font size="4" color="red">如果我们仅仅想覆盖基类中的部分函数，我们可以使用using 声明，将基类的同名函数作用域。</font> <br>
  <font size="4">全部添加到派生类作用域中，此时派生类作用域中也有了这些函数，我们在定义我们想覆盖的函数的版本就可以了。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">class</span> base
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> fun1() { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"base"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl; <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;}
};

<span class="hljs-keyword">class</span> D1 : <span class="hljs-keyword">public</span> base
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> fun1(<span class="hljs-keyword">int</span> i) { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"D1"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl; <span class="hljs-keyword">return</span> i; }
};

<span class="hljs-keyword">class</span> D2 : <span class="hljs-keyword">public</span> D1
{
    <span class="hljs-keyword">public</span>:
        <span class="hljs-keyword">int</span> fun1(<span class="hljs-keyword">int</span> i) { <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"D2"</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl; <span class="hljs-keyword">return</span> i; }
};

<span class="hljs-keyword">int</span> main()
{
    base b;
    D1 d1;
    D2 d2;
    base *p1 = &amp;b, *p2 = &amp;d1, *p3 = &amp;d2;
    p1-&gt;fun1();
    p2-&gt;fun1(<span class="hljs-number">1</span>);<span class="hljs-comment">//p2-&gt;fun1(1)报错了，参数不对，绑定的指针是base的，也就是说我们希望动态绑定，但是在D1中int fun1(int i)就把基类的fun1( )虚函数覆盖了，此时编译器解析为静态绑定。</span>
    <span class="hljs-comment">//p3-&gt;fun1(1);</span>
}</code></pre>

<p><font size="4"><strong>4、重载、覆盖和隐藏的区别</strong></font> <br>
  <font size="4">重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</font></p>

<pre class="prettyprint"><code class=" hljs cs">class A{
<span class="hljs-keyword">public</span>:
  <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(<span class="hljs-keyword">int</span> i);
  <span class="hljs-keyword">void</span> test(<span class="hljs-keyword">double</span> i);<span class="hljs-comment">//overload</span>
  <span class="hljs-keyword">void</span> test(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">double</span> j);<span class="hljs-comment">//overload</span>
  <span class="hljs-keyword">void</span> test(<span class="hljs-keyword">double</span> i, <span class="hljs-keyword">int</span> j);<span class="hljs-comment">//overload</span>
  <span class="hljs-keyword">int</span> test(<span class="hljs-keyword">int</span> i);         <span class="hljs-comment">//错误，非重载。注意重载不关心函数返回类型。</span>
};</code></pre>

<p>  <font size="4">隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> Base
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">void</span> fun(<span class="hljs-keyword">double</span> ,<span class="hljs-keyword">int</span> ){ <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Base::fun(double ,int )"</span> &lt;&lt; endl; }
};

<span class="hljs-keyword">class</span> Derive : <span class="hljs-keyword">public</span> Base
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">void</span> fun(<span class="hljs-keyword">int</span> ){ <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Derive::fun(int )"</span> &lt;&lt; endl; }
};

<span class="hljs-keyword">int</span> main()
{
    Derive pd;
    pd.fun(<span class="hljs-number">1</span>);<span class="hljs-comment">//Derive::fun(int )</span>
    pb.fun(<span class="hljs-number">0.01</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//error C2660: “Derive::fun”: 函数不接受 2 个参数</span>

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>  <font size="4">覆盖()：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> Base
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> fun(<span class="hljs-keyword">int</span> i){ <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Base::fun(int) : "</span> &lt;&lt; i &lt;&lt; endl;}
};

<span class="hljs-keyword">class</span> Derived : <span class="hljs-keyword">public</span> Base
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> fun(<span class="hljs-keyword">int</span> i){ <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Derived::fun(int) : "</span> &lt;&lt; i &lt;&lt; endl;}
};
<span class="hljs-keyword">int</span> main()
{
    Base b;
    Base * pb = <span class="hljs-keyword">new</span> Derived();
    pb-&gt;fun(<span class="hljs-number">3</span>);<span class="hljs-comment">//Derived::fun(int)</span>

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="5"><strong>八、构造函数与拷贝控制</strong></font> <br>
<font size="4"><strong>1、虚析构函数</strong></font><font size="4"> <br>
 - 继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数。这样我们就能动态分配继承体系中的对象了。<font size="4" color="red">因为动态绑定实现多态，如果我们仅仅定义普通版本的析构函数可能释放的并不是我们想要释放的对象。 <br>
 - 我们通过在基类中将析构函数定义为虚函数以确保执行正确的析构函数版本。只要基类的析构函数是虚函数，就能确保当我们delete基类指针时将运行正确的析构函数版本。</font> <br>
 - 如果一个类需要析构函数那么它也同样需要拷贝和赋值操作，基类的虚析构函数不遵循这个准则，是个例外。 <br>
 - 如果一个类定义了析构函数，即使它通过=default的形式使用了合成版本，编译器也不会为这个类合成移动操作。 <br>
  <font size="4" color="green">综上：如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。所以虚析构函数能够确保delete基类指针时将运行正确的析构函数版本。</font></font></p>

<p><font size="4"><strong>2、合成拷贝控制与继承</strong></font> <br>
  <font size="4"><font size="4" color="blue">基类永远会影响派生类，</font>因为派生类继承基类，如果基类拷贝控制部分操作有问题，那么派生类也会有。比如：基类的拷贝构造定义为删除的，那么派生类也必定为删除的，因为派生类中的拷贝构造必须要调用基类的拷贝构造来初始化基类部分，基类定义为删除的，说明派生类不能构造基类部分，那么派生类也就为删除的了。</font></p>

<p><font size="4"><strong>3、派生类的拷贝控制成员</strong></font> <br>
  <font size="4">派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还要负责初始化派生类对象的基类部分，因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员，类似的派生类赋值运算符也必须为其基类部分的成员赋值。和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。 <br>
  <font size="4" color="green">【Note】： <br>
1）当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</font></font></p>

<p><font size="4"><strong>（1）定义派生类的拷贝或移动构造函数</strong></font> <br>
  <font size="4">在默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果我们向拷贝或移动基类部分，则必须在派生类的构造函数初始值列表显示的使用基类的拷贝或移动构造函数。</font></p>

<p><font size="4"><strong>（2）派生类赋值运算符</strong></font> <br>
  <font size="4">和拷贝和移动构造函数一样，派生类赋值运算符也必须显示的为其基类部分赋值。</font></p>

<p><font size="4"><strong>（3）派生类析构函数</strong></font> <br>
  <font size="4">对象的基类部分是隐式销毁的，和构造函数及赋值运算符不同，派生类析构函数只负责销毁由派生类自己分配的资源。</font></p>

<p><font size="4" color="red"><strong>（4）在构造函数和析构函数中调用虚函数</strong></font> <br>
  <font size="4">简单理解。这个虚函数可能会访问派生类的成员，毕竟，如果它不需要访问派生类的成员的话，则派生类直接使用基类的虚函数版本就可以了，然而，执行基类构造函数的时候，它要用到派生类成员尚未初始化，如果我们允许这样的访问，我们的程序可能会崩溃。 <br>
  <font size="4" color="green">【Note】： <br>
1）如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</font></font></p>

<p><font size="4"><strong>4、继承的构造函数</strong></font> <br>
  <font size="4">在c++11 新标准中，派生类能够重用直接基类定义的构造函数。派生类继承基类构造函数的方式是提供一条注明了基类名的using声明语句。using声明语句将令编译器产生代码，对于基类的每个构造函数，编译器都生成与之对应的派生类构造函数。</font></p>

<pre class="prettyprint"><code class=" hljs cs">class B
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">B</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> &amp;s);<span class="hljs-comment">//构造函数</span>
};
class A:<span class="hljs-keyword">public</span> B{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> B::B;<span class="hljs-comment">//继承了基类的构造函数</span>

};</code></pre>

<p>  <font size="4" color="green">【Note】： <br>
1）通常情况下，using只是令某个名字在当前作用域可见，但是当作用于构造函数时，using声明语句将会使编译器产生代码，派生类继承基类的构造函数，其派生的部分成员将会默认初始化。 <br>
2）不管using出现在哪，基类的私有构造函数在派生类中还是一个私有类型的，其访问级别不会被using改变。 <br>
3）当一个基类的构造函数有默认实参时，这些实参不会被继承，派生类会获得多个继承的构造函数，每个构造函数都将省略掉一个含有默认实参的形参。</font></p>

<p><font size="5"><strong>九、容器与继承</strong></font> <br>
  <font size="4">当我们使用容器存放继承体系中的对象时，通常必须采用简介存储的方式，因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器中。 <br>
  <font size="4" color="green">【Note】： <br>
1）当派生类对象被赋值给基类对象时，其中的派生类部分将被切掉，因此容器和存在继承关系的类型无法兼容。 <br>
2）在容器中放置（智能）指针而非对象。</font> <br>
  <font size="4">当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针，更好的是存放智能指针，和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型。正如我们可以把派生类的指针转换为基类的指针一样，我们也可以把派生类的智能指针转换为基类的智能指针。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> Basket
{
<span class="hljs-keyword">public</span>:
    Basket() = <span class="hljs-keyword">default</span>;
    ~Basket() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">void</span> add_item(<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt; &amp;sale)
    {
        items.insert(sale);
    }
    <span class="hljs-keyword">void</span> add_item(<span class="hljs-keyword">const</span> Quote &amp;sale)
    {
        items.insert(<span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt;(sale.clone()));
    }
    <span class="hljs-keyword">void</span> add_item(Quote &amp;&amp;sale)
    {
        items.insert(<span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt;(<span class="hljs-built_in">std</span>::move(sale).clone()));
    }
    <span class="hljs-keyword">double</span> total_receipt(ostream &amp;) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">//定义static成员函数。</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> compare(<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt; &amp;lhs, 
                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt; &amp;rhs)
    {
        <span class="hljs-keyword">return</span> lhs-&gt;isbn() &lt; rhs-&gt;isbn();
    }   
    <span class="hljs-comment">//定义了一个指向Quote对象的shared_ptr的multiset，自定义比较运算符。</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">multiset</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt;</span>,<span class="hljs-keyword">decltype</span>(compare)*&gt; items{compare};
};</code></pre>

<p><font size="5"><strong>十、本章demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> Quote
{
<span class="hljs-keyword">public</span>:
    Quote() = <span class="hljs-keyword">default</span>;
    Quote(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;book, <span class="hljs-keyword">double</span> sales_price):bookNo(book), price(sales_price){}
    <span class="hljs-built_in">string</span> isbn() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> bookNo; }
    <span class="hljs-comment">//返回给定数量的书籍的销售总额。</span>
    <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> net_price(size_t n) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> n * price;
    }
    <span class="hljs-comment">//对析构函数进行动态绑定。</span>
    <span class="hljs-keyword">virtual</span> ~Quote() = <span class="hljs-keyword">default</span>;
    <span class="hljs-comment">//该虚函数返回当前对象的一份动态分配的拷贝，左值和右值引用限定符。</span>
    <span class="hljs-keyword">virtual</span> Quote *clone() <span class="hljs-keyword">const</span> &amp; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Quote(*<span class="hljs-keyword">this</span>); }
    <span class="hljs-keyword">virtual</span> Quote *clone()  &amp;&amp; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Quote(<span class="hljs-built_in">std</span>::move(*<span class="hljs-keyword">this</span>)); }
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> bookNo;
<span class="hljs-keyword">protected</span>:
    <span class="hljs-keyword">double</span> price = <span class="hljs-number">0.0</span>;
};

<span class="hljs-keyword">double</span> print_total(ostream &amp;os, <span class="hljs-keyword">const</span> Quote &amp;item, size_t n)
{
    <span class="hljs-keyword">double</span> ret = item.net_price(n);<span class="hljs-comment">//通过引用调用虚函数，动态绑定。</span>
    os &lt;&lt; <span class="hljs-string">"ISBN: "</span> &lt;&lt; item.isbn() &lt;&lt; <span class="hljs-string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">" total due : "</span> &lt;&lt; ret &lt;&lt; endl;
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-keyword">class</span> Bulk_quote : <span class="hljs-keyword">public</span> Quote
{
<span class="hljs-keyword">public</span>:
    Bulk_quote() = <span class="hljs-keyword">default</span>;
    <span class="hljs-comment">//覆盖基类的函数版本以实现基于大量购买的折扣政策。</span>
    Bulk_quote(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; book, <span class="hljs-keyword">double</span> p, size_t qty, <span class="hljs-keyword">double</span> disc):
                Quote(book,p), min_qty(qty), discount(disc){}<span class="hljs-comment">//首先初始化基类，然后初始化派生类的成员。</span>
    <span class="hljs-keyword">double</span> net_price(size_t) <span class="hljs-keyword">const</span> override;
    Bulk_quote *clone() <span class="hljs-keyword">const</span> &amp; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bulk_quote(*<span class="hljs-keyword">this</span>); }
    Bulk_quote *clone()  &amp;&amp; { <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bulk_quote(<span class="hljs-built_in">std</span>::move(*<span class="hljs-keyword">this</span>)); }
<span class="hljs-keyword">private</span>:
    size_t min_qty = <span class="hljs-number">0</span>;<span class="hljs-comment">//最低购买量。</span>
    <span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;<span class="hljs-comment">//折扣率。</span>
};

<span class="hljs-keyword">class</span> Basket
{
<span class="hljs-keyword">public</span>:
    Basket() = <span class="hljs-keyword">default</span>;
    ~Basket() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">void</span> add_item(<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt; &amp;sale)
    {
        items.insert(sale);
    }
    <span class="hljs-keyword">void</span> add_item(<span class="hljs-keyword">const</span> Quote &amp;sale)
    {
        items.insert(<span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt;(sale.clone()));
    }
    <span class="hljs-keyword">void</span> add_item(Quote &amp;&amp;sale)
    {
        items.insert(<span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt;(<span class="hljs-built_in">std</span>::move(sale).clone()));
    }
    <span class="hljs-keyword">double</span> total_receipt(ostream &amp;) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">//定义static成员函数。</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> compare(<span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt; &amp;lhs, 
                        <span class="hljs-keyword">const</span> <span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt; &amp;rhs)
    {
        <span class="hljs-keyword">return</span> lhs-&gt;isbn() &lt; rhs-&gt;isbn();
    }   
    <span class="hljs-comment">//定义了一个指向Quote对象的shared_ptr的multiset，自定义比较运算符。</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">multiset</span>&lt;<span class="hljs-built_in">shared_ptr</span>&lt;Quote&gt;</span>,<span class="hljs-keyword">decltype</span>(compare)*&gt; items{compare};
};

<span class="hljs-keyword">double</span> Basket::total_receipt(ostream &amp;os) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0.0</span>;
    <span class="hljs-comment">//iter指向ISBN相同的第一批元素的第一个，upper_bound返回这批元素中的最后一个。</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = items.cbegin();
              iter != items.cend();
              iter = items.upper_bound(*iter))
    {
        <span class="hljs-comment">//*iter是shared_ptr，所以要对其解引用得到Quote对象；items.count()计算同名的书籍有所少个。</span>
        sum += print_total(os, **iter, items.count(*iter));
    }
    os &lt;&lt; <span class="hljs-string">"Total Sale: "</span> &lt;&lt; sum &lt;&lt; endl;
    <span class="hljs-keyword">return</span> sum;
}

<span class="hljs-keyword">double</span> Bulk_quote::net_price(size_t cnt) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">if</span> (cnt &gt;= min_qty)
    {
        <span class="hljs-keyword">return</span> cnt * discount * price;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">return</span> cnt * price;
    }
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    Basket bsk;
    bsk.add_item(make_shared&lt;Quote&gt;(<span class="hljs-string">"AVR"</span>, <span class="hljs-number">60.0</span>));
    bsk.add_item(make_shared&lt;Quote&gt;(<span class="hljs-string">"FPGA"</span>, <span class="hljs-number">70.0</span>));
    bsk.add_item(make_shared&lt;Bulk_quote&gt;(<span class="hljs-string">"DSP"</span>, <span class="hljs-number">50.0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.8</span>));
    bsk.add_item(make_shared&lt;Bulk_quote&gt;(<span class="hljs-string">"DSP"</span>, <span class="hljs-number">50.0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.8</span>));
    bsk.add_item(make_shared&lt;Bulk_quote&gt;(<span class="hljs-string">"DSP"</span>, <span class="hljs-number">50.0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.8</span>));
    bsk.add_item(make_shared&lt;Bulk_quote&gt;(<span class="hljs-string">"DSP"</span>, <span class="hljs-number">50.0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.8</span>));
    bsk.add_item(make_shared&lt;Bulk_quote&gt;(<span class="hljs-string">"DSP"</span>, <span class="hljs-number">50.0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0.8</span>));
    bsk.total_receipt(<span class="hljs-built_in">cout</span>);
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>参考:<a href="http://blog.csdn.net/zx3517288/article/details/48976097" target="_blank">http://blog.csdn.net/zx3517288/article/details/48976097</a> <br>
<a href="http://blog.csdn.net/wwh578867817/article/details/42265401" target="_blank">http://blog.csdn.net/wwh578867817/article/details/42265401</a></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/01/27 21:17:05 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79183326">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79183326                    </div>
                    <div>
                        阅读：52                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]重载运算与类型转换]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79170551</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79170551</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/01/26 11:39:36</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4">内置类型运算都有基本的运算符来支持，而我们想要实现类类型的一些运算，就需要自己重载运算符。</font></p>

<p><font size="5"><strong>一、基本概念</strong></font> <br>
  <font size="4">重载的运算符是具有特殊名字的函数，他们的名字由<font size="4" color="red">关键字operator和后面要定义的运算符号共同组成</font>。和其他函数一样，也有返回类型，参数列表和函数体。 <br>
<font size="4" color="green">【Note】： <br>
1）当一个重载的运算符是成员函数时，this绑定到左侧的对象，成员运算符函数的参数比运算对象的参数少一个。比如+重载成成员函数，那么它的参数只能有一个，默认类对象this本身是一个参数。 <br>
2）不能重载的运算符 ：        ：：     .*      .      ?: <br>
3）不应该被重载的运算符：      逻辑运算符，逗号运算符，取地址运算符。  重载逻辑运算符的时候不支持短路求值和求值顺序的属性，逗号和取地址本身有内置含义。尽量明智地使用运算符重载。 <br>
4）我们重载运算符时最好和内置的形成映射最好，也就是类似程度。比如IO运算符，==运算符（若定义也该定义!=）等等。</font> <br>
  <font size="4">选择作为成员函数还是非成员函数： <br>
<font size="4" color="blue">（1）成员函数：</font> <br>
=，[ ]，( )， -&gt;， <br>
符合赋值+=,-=..  ， <br>
++，–，*(解引用) 改变对象的状态或与给定类型密切相关的运算符。 <br>
<font size="4" color="red">（2）非成员函数：</font> <br>
算数+，-，*，/… <br>
相等性== ，!= <br>
关系 &gt;,&lt;,&gt;=,&lt;=.. <br>
位运算符 ^, |, &amp; <br>
  <font size="4" color="red">可以看一个运算符左右两侧的对象是否可以互换位置，不能互换位置则一般为成员函数，可以互换位置则一般为非成员函数。</font></font></font></p>

<p><font size="5"><strong>二、输入输出运算符</strong></font> <br>
<font size="4"><strong>1、重载输出运算符&lt;&lt;</strong></font> <br>
  <font size="4" color="blue">输出运算符应定义为非成员函数，因为要读写类的非共有数据，所以要定义为友元。且返回值为std::ostream&amp;, 参数为std::ostream&amp;和类对象的引用。 <br>
<font size="4" color="green">【Note】： <br>
1）通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符我们应减少对输出格式的控制。</font></font></p>

<p><font size="4"><strong>2、重载输入运算符&gt;&gt;</strong></font> <br>
  <font size="4">输入运算符和输出运算符格式上类似，也是非成员函数，返回输入流引用（流不能拷贝）。当流含有错误类型的数据时读取操作可能失败，读取数据到文件末尾或遇到其他流错误也会失败。 <br>
<font size="4" color="green">【Note】： <br>
1）参数是输入流引用和类对象和输出运算符不同的是，输入运算符必须处理输入可能失败的情况，而输出运算符不需要。 <br>
2）不需要逐个检查，只在末尾检查即可，当读取操作发生错误时，输入运算符应该负责从错误中恢复。</font> <br>
  <font size="4">一些输入运算符可能需要更多的数据验证工作。</font></font></p>

<pre class="prettyprint"><code class=" hljs cs">friend ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;<span class="hljs-keyword">out</span>, MyString &amp;s);
friend istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;<span class="hljs-keyword">in</span>, MyString &amp;s);

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;<span class="hljs-keyword">out</span>, MyString &amp;s)
{
    <span class="hljs-keyword">out</span> &lt;&lt; s.m_p;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">out</span>; 
}

istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;<span class="hljs-keyword">in</span>, MyString &amp;s)
{
    <span class="hljs-keyword">in</span> &gt;&gt; s.m_p;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">in</span>; 
}</code></pre>

<p><font size="5"><strong>三、算数和关系运算符</strong></font> <br>
  <font size="4">我们把算数和关系运算符<font size="4" color="red">定义成非成员函数以允许对左侧或右侧的运算对象进行转换</font>，一般不需要改变参数状态，所以都是常量引用。 <br>
  <font size="4">如果定义了算数运算符，则他一般也会定义一个对应的复合赋值运算符，最有效的方式是<font size="4" color="red">使用复合赋值来定义算数运算符。</font></font></font></p>

<p><font size="4"><strong>1、相等运算符</strong></font> <br>
  <font size="4">依次比较每个成员是否相等。 <br>
<font size="4" color="green">【Note】： <br>
1）如果类定义了operator==,那么类也应该定义operator!=。 <br>
2）相等运算符和不相等运算符中的一个应该把工作委托给另外一个。 <br>
3）如果某个类逻辑上有相等性的含义，则该类应该定义operator==,这样做可以使得用户更加容易的使用标准库算法（部分标准库算法必须要有==支持）。 <br>
4）shared_ptr 和 unique_ptr 都用get( )返回的指针来比较是否指向同一个对象 <br>
5）weak_ptr 要先使用lock( )获取shared_ptr 然后在用get( )来比较地址从而判定是否指向同一个对象。</font></font></p>

<p><font size="4"><strong>2、关系运算符</strong></font> <br>
  <font size="4">定义了相等运算符的类通常也应该定义关系运算符，因为关联容器和一些算法要用到小于运算符。所以operator&lt;会比较有用。 <br>
<font size="4" color="green">【Note】： <br>
1）如果存在唯一一种逻辑可靠的&lt;定义，则应该为这个类定义&lt;运算符，如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</font> <br>
  <font size="4">不要轻易定义&lt;运算符，如果&lt;和==比较的逻辑相同（也就是比较的成员相同）才定义&lt;运算符。一些情况我们必须定义&lt;运算符，比如类对象需要存在map或set中的时候等等。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MyString &amp;s) <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p);
<span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> MyString &amp;s);

<span class="hljs-keyword">bool</span> MyString::<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">if</span>(p == NULL)
    {
        <span class="hljs-keyword">return</span> m_len ==<span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">return</span> m_len == <span class="hljs-built_in">strlen</span>(p) ? !<span class="hljs-built_in">strcmp</span>(m_p,p) : <span class="hljs-keyword">false</span>;
    }
}

<span class="hljs-keyword">bool</span> MyString::<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MyString &amp;s) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> == s ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;
}

<span class="hljs-comment">//重载大于、小于。</span>
<span class="hljs-keyword">int</span> MyString::<span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(m_p,p);
}

<span class="hljs-keyword">int</span> MyString::<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> MyString &amp;s)
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(m_p,s.m_p);
}</code></pre>

<p><font size="5"><strong>四、赋值运算符</strong></font> <br>
  <font size="4">类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。和拷贝赋值运算符及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，不同之处是无需检查自赋值。销毁原资源，更新资源。 <br>
  <font size="4">复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算符都定义在类的内部。 <br>
  <font size="4">为了与内置类型的复合赋值保持一直，类中的复合赋值运算符也要返回其左侧运算对象的引用。 <br>
<font size="4" color="green">【Note】： <br>
1）我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。 <br>
2）赋值运算符必须定义成类的成员，复合赋值运算符通常也应该这样做，这两类运算符都应该返回对象的引用。</font></font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp">MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p);
MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyString &amp;s);
MyString &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p);
MyString &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> MyString &amp;s);

<span class="hljs-comment">//重载赋值操作符。</span>
MyString &amp;MyString::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)
{
    <span class="hljs-keyword">if</span>(m_p != NULL)
    {
        <span class="hljs-keyword">delete</span> [] m_p;
        m_len = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span>(p == NULL)
    {
        m_len = <span class="hljs-number">0</span>;
        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(m_p,<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        m_len = <span class="hljs-built_in">strlen</span>(p);
        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[m_len+<span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(m_p,p);
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//返回引用。</span>
}

<span class="hljs-comment">//重载赋值操作符。</span>
MyString &amp;MyString::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyString &amp;s)
{
    <span class="hljs-keyword">if</span>(m_p != NULL)
    {
        <span class="hljs-keyword">delete</span> [] m_p;
        m_len = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        m_len = s.m_len;
        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[m_len+<span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(m_p,s.m_p);
    }
}

<span class="hljs-comment">//重载加号运算符。</span>
MyString &amp;MyString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)
{
    <span class="hljs-built_in">strcat</span>(m_p,p);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

MyString &amp;MyString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> MyString &amp;s)
{
    <span class="hljs-built_in">strcat</span>(m_p,s.m_p);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}</code></pre>

<p><font size="5"><strong>五、下标运算符</strong></font> <br>
  <font size="4">表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[ ]。 <br>
<font size="4" color="green">【Note】： <br>
1）下标运算符必须是成员函数。 <br>
2）如果一个类包含下标运算符，则它通常会有两个版本：一个返回普通引用，另一个是类的常量成员并返回常量引用。</font> <br>
  <font size="4">下标运算符通常以所访问元素的引用作为返回值。可以作为左值或右值。 <br>
  <font size="4">我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会修改返回值。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">char</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index) <span class="hljs-keyword">const</span>;

<span class="hljs-comment">//重载下标操作符。</span>
<span class="hljs-keyword">char</span> &amp;MyString::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">return</span> m_p[index];
}</code></pre>

<p><font size="5"><strong>六、递增递减运算符</strong></font> <br>
<font size="4" color="green">【Note】： <br>
1）定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符应该被定义为类的成员。 <br>
2）为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。 <br>
3）为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非一个引用。</font> <br>
  <font size="4">区分前置运算符和后置运算符：后置版本提供一个额外的不被使用的int类型的参数，使用后置运算符时，编译器为这个形参提供一个值为0的实参。这个形参的唯一作用就是区分前置版本和后置版本。对于后置版本来说，在递增或递减之前首先需要记录对象的状态。 <br>
  <font size="4">后置版本里可以调用前置版本。前置版本在递增之前要判断是否到达末尾，前置版本递减要在递减之后判断是否出界。如果我们要通过函数调用的方式调用后置版本，则必须为他整型参数传递一个值，尽管我们不使用这个值。</font></font></p>

<p><font size="5"><strong>七 、成员访问运算符</strong></font> <br>
  <font size="4">解引用运算符检查是否在范围内，然后返回所指元素的一个引用，箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果的地址。 <br>
<font size="4" color="green">【Note】： <br>
1）箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。 <br>
2）重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</font></font></p>

<p><font size="5"><strong>八、函数调用运算符</strong></font> <br>
  <font size="4">如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象，因为这个类同时也能存储状态，所以与普通函数相比更加具有灵活性。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>

<span class="hljs-keyword">struct</span> absInt
{
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> val)<span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> val &lt; <span class="hljs-number">0</span> ? -val : val;
    }
};

<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> val = -<span class="hljs-number">42</span>;
    absInt t;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; t(val) &lt;&lt; <span class="hljs-built_in">std</span>::endl;   <span class="hljs-comment">//t是一个对象而非函数</span>
}</code></pre>

<p><font size="4" color="green">【Note】： <br>
1）函数调用运算符必须是成函数。一个类可以员定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。 </font> <br>
  <font size="4">如果类定义了调用运算符，则该类被称为<font size="4" color="red">函数对象</font>，因为可以调用这种对象，所以我们说这些对象的行为像函数一样。 <br>
  <font size="4">函数对象类除了operator()之外也可以包含其他成员，通常函数对象类包含一些数据成员，这些成员用来<font size="4" color="red">定制调用运算符中的操作。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>

<span class="hljs-keyword">class</span> PrintString
{
    <span class="hljs-keyword">public</span>:
        PrintString(<span class="hljs-built_in">std</span>::ostream &amp;o = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>, <span class="hljs-keyword">char</span> t = <span class="hljs-string">' '</span>):
            os(o), c(t) { }
        <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;s)<span class="hljs-keyword">const</span>   <span class="hljs-comment">//借用辅助工具来完成函数的操作</span>
        {
            os &lt;&lt; s &lt;&lt; c;
        }

    <span class="hljs-keyword">private</span>:                     <span class="hljs-comment">//private成员可以用来保存“辅助”工具</span>
        <span class="hljs-built_in">std</span>::ostream &amp;os;
        <span class="hljs-keyword">char</span> c;
};

<span class="hljs-keyword">int</span> main()
{
    PrintString ps;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s = <span class="hljs-string">"abc"</span>;
    ps(s);
}</code></pre>

<p>  <font size="4" color="blue">函数对象比一般函数灵活就是它可以让另完成函数所需要的辅助成员成为自己的类成员。和lambda类似，函数对象常常作为泛型算法的实参。</font></p>

<p><font size="4"><strong>1、lambda是函数对象</strong></font> <br>
  <font size="4">当定义一个lambda时，编译器生成一个与lambda对应的新的类类型。当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象。 <br>
  <font size="4">其实当我们编写一个lambda后，编译器将该表达式翻译成一个<font size="4" color="red">未命名类的未命名对象，</font>在lambda表达式产生的类中<font size="4" color="red">含有一个重载的函数调用运算符。</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cs">[](<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> &amp;lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> &amp;rhs)
{ <span class="hljs-keyword">return</span> lhs.size() &lt; rhs.size(); }
<span class="hljs-comment">//上述等价于：</span>
class shrotstring
{
        <span class="hljs-keyword">public</span>:
             <span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span>()(<span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> &amp;lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> &amp;rhs)<span class="hljs-keyword">const</span>
             {    <span class="hljs-keyword">return</span> lhs.size() &lt; rhs.size(); }
};</code></pre>

<p>  <font size="4">表示lambda及相应捕获行为的类： <br>
  <font size="4">当一个lambda通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象的确存在，因此，编译器可以直接使用该引用而无需在lambda产生的类中将其存储为数据成员。 <br>
  <font size="4">当一个lambad通过值将变量拷贝到lambda时，lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量来初始化数据成员。 <br>
  <font size="4">lambda产生的类不含默认构造函数，赋值运算符及默认析构函数：它是否含有默认的拷贝/移动构造函数则通常视捕获的数据成员类型而定。</font></font></font></font></p>

<p><font size="4"><strong>2、标准库定义的函数对象</strong></font> <br>
  <font size="4">头文件<code>#include &lt;functional&gt;</code>，标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命令操作的调用运算符。</font></p>

<pre class="prettyprint"><code class=" hljs delphi"><span class="hljs-comment">//算术：</span>
plus&lt;<span class="hljs-keyword">Type</span>&gt;、minus&lt;<span class="hljs-keyword">Type</span>&gt;、multiplies&lt;<span class="hljs-keyword">Type</span>&gt;、divides&lt;<span class="hljs-keyword">Type</span>&gt;
modulus&lt;<span class="hljs-keyword">Type</span>&gt;、negate&lt;<span class="hljs-keyword">Type</span>&gt;
<span class="hljs-comment">//关系：</span>
equal_to&lt;<span class="hljs-keyword">Type</span>&gt;、not_equal_to&lt;<span class="hljs-keyword">Type</span>&gt;、greater&lt;<span class="hljs-keyword">Type</span>&gt;
greater_equal&lt;<span class="hljs-keyword">Type</span>&gt;、less&lt;<span class="hljs-keyword">Type</span>&gt;、less_equal&lt;<span class="hljs-keyword">Type</span>&gt;
<span class="hljs-comment">//逻辑运算符：</span>
logical_and&lt;&lt;#<span class="hljs-keyword">class</span> _Tp#&gt;&gt;、logical_not&lt;&lt;#<span class="hljs-keyword">class</span> _Tp#&gt;&gt;、logical_or&lt;&lt;#<span class="hljs-keyword">class</span> _Tp#&gt;&gt;</code></pre>

<pre class="prettyprint"><code class=" hljs avrasm">//我们也可以在算法中使用标准库函数对象。
sort(svec<span class="hljs-preprocessor">.begin</span>(), svec<span class="hljs-preprocessor">.end</span>(), <span class="hljs-keyword">std</span>::greater&lt;<span class="hljs-keyword">std</span>::string&gt;())<span class="hljs-comment">;  </span>
// 而且标准库规定其函数对象对于指针同样适用。排序的同样是string。
sort(svec<span class="hljs-preprocessor">.begin</span>(), svec<span class="hljs-preprocessor">.end</span>(), <span class="hljs-keyword">std</span>::less&lt;<span class="hljs-keyword">std</span>::string *&gt;())<span class="hljs-comment">;  </span></code></pre>

<p><font size="4"><strong>3、可调用对象与function</strong></font> <br>
  <font size="4">c++中有几种可调用的对象：<font size="4" color="red">函数，函数指针，lambda表达式，bind创建的对象，以及函数对象（重载了函数调用运算符的类）。</font> <br>
  <font size="4">和其他对象一样，可调用的对象也有类型。然而两个不同的可调用对象确有可能享用同一种调用形式。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> add(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) { <span class="hljs-keyword">return</span> a+b; }
<span class="hljs-keyword">auto</span> t = [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) { <span class="hljs-keyword">return</span> a+b; }
<span class="hljs-keyword">class</span> A
{
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)
        {
                 <span class="hljs-keyword">return</span> a+b;
        }
}
....
类型都是 <span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</code></pre>

<p>  <font size="4">但实际操作比如我们想<code>vector&lt;int(*)(int, int)&gt;</code>来保存他们是不行的，只能保存第一个，因为他们毕竟是不同的对象！ </font></p>

<p><font size="4"><strong>标准库function类型：</strong></font> <br>
  <font size="4">我们可以使用一个名为function的新的标准库类型来解决上面的问题。头文件<code>#include &lt;functional&gt;</code></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-comment">//普通函数。</span>
<span class="hljs-keyword">int</span> add(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j){ <span class="hljs-keyword">return</span> i + j; }

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-comment">/*********************
    *标准库定义的函数对象。
    **********************/</span>
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span> svec{<span class="hljs-string">"abc"</span>,<span class="hljs-string">"bcd"</span>};
    sort(begin(svec),end(svec),greater&lt;<span class="hljs-built_in">string</span>&gt;());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> s : svec)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; endl;
    }

    <span class="hljs-comment">/***************
    *标准库function。
    ****************/</span>
    <span class="hljs-comment">//lambda对象类。</span>
    <span class="hljs-keyword">auto</span> mod = [] (<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j){ <span class="hljs-keyword">return</span> i % j; };
    <span class="hljs-comment">//函数对象类。</span>
    <span class="hljs-keyword">struct</span> divide
    {
        <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j){ <span class="hljs-keyword">return</span> i / j; }
    };
    <span class="hljs-stl_container"><span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span> ,<span class="hljs-keyword">int</span>)&gt;</span>&gt; binops = 
    {
        {<span class="hljs-string">"+"</span>,add},
        {<span class="hljs-string">"-"</span>,minus&lt;<span class="hljs-keyword">int</span>&gt;()},
        {<span class="hljs-string">"*"</span>,[] (<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j){ <span class="hljs-keyword">return</span> i*j; }},
        {<span class="hljs-string">"/"</span>,divide()},
        {<span class="hljs-string">"%"</span>,mod}
    };
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;</span> ivec
    {
        binops[<span class="hljs-string">"+"</span>](<span class="hljs-number">4</span>,<span class="hljs-number">2</span>),
        binops[<span class="hljs-string">"-"</span>](<span class="hljs-number">4</span>,<span class="hljs-number">2</span>),
        binops[<span class="hljs-string">"*"</span>](<span class="hljs-number">4</span>,<span class="hljs-number">2</span>),
        binops[<span class="hljs-string">"/"</span>](<span class="hljs-number">4</span>,<span class="hljs-number">2</span>),
        binops[<span class="hljs-string">"%"</span>](<span class="hljs-number">4</span>,<span class="hljs-number">2</span>)
    };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> i : ivec)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; endl;
    }
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4" color="green">【Note】： <br>
1）当我们有函数重载对象时，不能直接将相同的函数名字放入function,必须通过函数指针或者lambda来消除二义性。</font></p>

<p><font size="5"><strong>九、重载，类型转换与运算符</strong></font> <br>
  <font size="4">我们能定义类类型之间的转换，转换构造函数和类型转换运算符共同定义了类类型转换。 <br>
<font size="4"><strong>1、类型转换运算符</strong></font> <br>
  <font size="4" color="red">类的一种特殊的成员函数，负责将一个类类型的值转换成其他类型。</font></font></p>

<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-title">operator</span> <span class="hljs-typedef"><span class="hljs-keyword">type</span><span class="hljs-container">( )</span>const;</span></code></pre>

<pre class="prettyprint"><code class=" hljs cs">class SmallInt
{
    friend ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;<span class="hljs-keyword">out</span>, SmallInt &amp;s);
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">SmallInt</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>):val(i)
    {
        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">255</span>)
            <span class="hljs-keyword">throw</span> out_of_range(<span class="hljs-string">"bad value"</span>);
    }
    SmallInt &amp;<span class="hljs-keyword">operator</span>=(size_t p);
    <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">int</span>() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> val; }
    ~SmallInt(){}
<span class="hljs-keyword">private</span>:
    size_t val;
};</code></pre>

<p>  <font size="4">type表示某种类型。但是该类型必须能作为返回类型。类型转换运算符既没有显示的返回类型，也没有形参，而且必须定义成类的成员函数，类型转换通常不应该改变待转换的对象。 <br>
<font size="4" color="green">【Note】： <br>
1）一个类型转换函数必须是类的成员函数，它不能声明返回类型，也没有形参，类型转换函数通常为const。 <br>
2）向bool的类型转换通常用在条件部分，因此operator bool 一般定义为explicit 的。 <br>
3）应该避免过度的使用类型转换函数。</font></font></p>

<p><font size="4"><strong>（1）、类型转换函数可能产生意外结果</strong></font> <br>
  <font size="4">类通常很少定义类型转换运算符，但是定义像bool类型转换还是比较常见。</font></p>

<p><font size="4"><strong>（2）、c++11 显示类型转换运算符</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> type( ) <span class="hljs-keyword">const</span> { }; 

<span class="hljs-keyword">static_cast</span>&lt;type&gt;(name);</code></pre>

<p>  <font size="4">当类型转换运算符是显式的我们才能只能类型转换。不过必须通过显式的强制类型转换才行。但是存在一个例外：既当如果表达式被用作 条件，则编译器会将显示的类型转换自动应用于它。包括while, if, do, for语句头条件表达式，（!, ||, &amp;&amp;）的运算对象， （? :）条件表达式。 流对象转换bool也是因为标准库定义了流向bool显式类型转化。</font></p>

<p><font size="4"><strong>2、避免有二义性的类型转换。</strong></font> <br>
  <font size="4" color="blue">如果一个类中包含一个或多个类型转换，则必须确保在类类型和目标类型转换之间只存在唯一一种转换方式。否则我们的代码可能会存在二义性。</font> <br>
  <font size="4">通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算数类型的转换。我们无法用强制类型转换来解决二义性，因为强制类型转换也面临着二义性。最好不要创建两个转换源都是算数类型的转换。</font></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">operator</span> <span class="hljs-keyword">int</span>( )<span class="hljs-keyword">const</span>
<span class="hljs-keyword">operator</span> <span class="hljs-keyword">double</span>( )<span class="hljs-keyword">const</span></code></pre>

<p>  <font size="4">当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。 <br>
<font size="4" color="green">【Note】： <br>
1）不要让两个类执行相同的类型转换，比如A转换B的同时B也转换为A。 <br>
2）避免转换目标是内置算数类型的类型转换。 <br>
3）如果我们对一个类既提供了转换目标是算数类型的类型转换，也提供了重载的运算符，则会遇到重载运算符与内置运算符二义性的问题。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> SmallInt
{
    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, SmallInt &amp;s);
<span class="hljs-keyword">public</span>:
    SmallInt(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>):val(i)
    {
        <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">255</span>)
            <span class="hljs-keyword">throw</span> out_of_range(<span class="hljs-string">"bad value"</span>);
    }
    SmallInt &amp;<span class="hljs-keyword">operator</span>=(size_t p);
    <span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">int</span>() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> val; }
    ~SmallInt(){}
<span class="hljs-keyword">private</span>:
    size_t val;
};

SmallInt &amp;SmallInt::<span class="hljs-keyword">operator</span>=(size_t p)
{
    val = p;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, SmallInt &amp;s)
{
    out &lt;&lt; s.val;
    <span class="hljs-keyword">return</span> out; 
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    SmallInt si = <span class="hljs-number">3</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; si &lt;&lt; endl;
    <span class="hljs-keyword">int</span> k = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(si) + <span class="hljs-number">3</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; k;
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="5"><strong>十、重载二元运算符</strong></font> <br>
  <font size="4" color="red">为了满足某些运算符的可交换性，重载二元操作符时应该将其声明为友元函数。</font></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> namespace std;
class Integer 
{
    friend Integer <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>, Integer integer); 
<span class="hljs-keyword">public</span>:
    <span class="hljs-title">Integer</span>();
    Integer(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>);
    Integer <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>);
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>);
    <span class="hljs-keyword">operator</span> <span class="hljs-keyword">int</span>() <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_value;  
};
Integer::Integer() {
    m_value = <span class="hljs-number">0</span>;
}
Integer::Integer(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>) {
    m_value = <span class="hljs-keyword">value</span>;
}

Integer Integer::<span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>) {
    <span class="hljs-keyword">int</span> tmpValue = m_value + <span class="hljs-keyword">value</span>;
    <span class="hljs-keyword">return</span> Integer(tmpValue);
}

<span class="hljs-keyword">void</span> Integer::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>) {
     m_value = <span class="hljs-keyword">value</span>;
}
Integer::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">int</span>() <span class="hljs-keyword">const</span> {
    <span class="hljs-keyword">return</span> m_value;
}

Integer <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>, Integer integer) {
    <span class="hljs-keyword">int</span> tmpValue = integer.m_value + <span class="hljs-keyword">value</span>;
    <span class="hljs-keyword">return</span> Integer(tmpValue);
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    Integer integer = Integer(<span class="hljs-number">10</span>);  
    Integer tmpInteger = <span class="hljs-number">100</span>;   <span class="hljs-comment">//重载=运算符。</span>
    tmpInteger = integer + <span class="hljs-number">1</span>;   <span class="hljs-comment">//重载Integer成员函数+运算符。</span>
    tmpInteger = <span class="hljs-number">1</span> + tmpInteger;<span class="hljs-comment">//重载友元函数+运算符。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="5"><strong>十一、String类的实现：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> MyString
{
    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, MyString &amp;s);
    <span class="hljs-keyword">friend</span> istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;in, MyString &amp;s);
<span class="hljs-keyword">public</span>:
    MyString() = <span class="hljs-keyword">default</span>;
    MyString(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p);
    MyString(<span class="hljs-keyword">const</span> MyString &amp;s);
    ~MyString();
    MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p);
    MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyString &amp;s);
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MyString &amp;s) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p);
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> MyString &amp;s);
    MyString &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p);
    MyString &amp;<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> MyString &amp;s);
    <span class="hljs-comment">// MyString &amp;operator*();</span>
    <span class="hljs-comment">// MyString *operator-&gt;();</span>
    <span class="hljs-keyword">char</span> &amp;<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index) <span class="hljs-keyword">const</span>;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> Size() <span class="hljs-keyword">const</span>{ <span class="hljs-keyword">return</span> m_len; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_len;
    <span class="hljs-keyword">char</span> *m_p;
};

<span class="hljs-keyword">class</span> CheckString
{
<span class="hljs-keyword">public</span>:
    CheckString() = <span class="hljs-keyword">default</span>;
    ~CheckString() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>()(<span class="hljs-keyword">const</span> MyString &amp;s1, <span class="hljs-keyword">const</span> MyString &amp;s2) <span class="hljs-keyword">const</span>
    {
        <span class="hljs-keyword">return</span> s1.Size() &lt; s2.Size();
    }
};


<span class="hljs-comment">//默认构造函数。</span>
MyString::MyString()
{
    m_len = <span class="hljs-number">0</span>;
    m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];
    <span class="hljs-built_in">strcpy</span>(m_p,<span class="hljs-string">""</span>);
}

<span class="hljs-comment">//构造函数。</span>
MyString::MyString(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)
{
    <span class="hljs-keyword">if</span>(p == NULL)
    {
        m_len = <span class="hljs-number">0</span>;
        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(m_p,<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        m_len = <span class="hljs-built_in">strlen</span>(p);
        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[m_len+<span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(m_p,p);  
    }
}

<span class="hljs-comment">//拷贝构造函数。</span>
MyString::MyString(<span class="hljs-keyword">const</span> MyString &amp;s)
{
    m_len = s.m_len;
    m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[m_len+<span class="hljs-number">1</span>];
    <span class="hljs-built_in">strcpy</span>(m_p,s.m_p);  
}

<span class="hljs-comment">//析构函数。</span>
MyString::~MyString()
{
    <span class="hljs-keyword">if</span>(m_p != NULL)
    {
        <span class="hljs-keyword">delete</span> [] m_p;
        m_p = NULL;<span class="hljs-comment">//防止出现野指针。</span>
        m_len = <span class="hljs-number">0</span>;
    }
}

<span class="hljs-comment">//重载赋值操作符。</span>
MyString &amp;MyString::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)
{
    <span class="hljs-keyword">if</span>(m_p != NULL)
    {
        <span class="hljs-keyword">delete</span> [] m_p;
        m_len = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span>(p == NULL)
    {
        m_len = <span class="hljs-number">0</span>;
        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(m_p,<span class="hljs-string">""</span>);
    }
    <span class="hljs-keyword">else</span>
    {
        m_len = <span class="hljs-built_in">strlen</span>(p);
        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[m_len+<span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(m_p,p);
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//返回引用。</span>
}

<span class="hljs-comment">//重载赋值操作符。</span>
MyString &amp;MyString::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyString &amp;s)
{
    <span class="hljs-keyword">if</span>(m_p != NULL)
    {
        <span class="hljs-keyword">delete</span> [] m_p;
        m_len = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        m_len = s.m_len;
        m_p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[m_len+<span class="hljs-number">1</span>];
        <span class="hljs-built_in">strcpy</span>(m_p,s.m_p);
    }
}

<span class="hljs-comment">//重载下标操作符。</span>
<span class="hljs-keyword">char</span> &amp;MyString::<span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">int</span> index) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">return</span> m_p[index];
}

<span class="hljs-comment">//重载输出操作符。</span>
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, MyString &amp;s)
{
    out &lt;&lt; s.m_p;
    <span class="hljs-keyword">return</span> out; 
}

istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;in, MyString &amp;s)
{
    in &gt;&gt; s.m_p;
    <span class="hljs-keyword">return</span> in; 
}

<span class="hljs-comment">//重载等号操作符。</span>
<span class="hljs-keyword">bool</span> MyString::<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">if</span>(p == NULL)
    {
        <span class="hljs-keyword">return</span> m_len ==<span class="hljs-number">0</span> ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">return</span> m_len == <span class="hljs-built_in">strlen</span>(p) ? !<span class="hljs-built_in">strcmp</span>(m_p,p) : <span class="hljs-keyword">false</span>;
    }
}

<span class="hljs-keyword">bool</span> MyString::<span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MyString &amp;s) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span> == s ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;
}

<span class="hljs-comment">//重载大于小于。</span>
<span class="hljs-keyword">int</span> MyString::<span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(m_p,p);
}

<span class="hljs-keyword">int</span> MyString::<span class="hljs-keyword">operator</span>&gt;(<span class="hljs-keyword">const</span> MyString &amp;s)
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(m_p,s.m_p);
}

<span class="hljs-comment">//重载加号运算符。</span>
MyString &amp;MyString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *p)
{
    <span class="hljs-built_in">strcat</span>(m_p,p);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

MyString &amp;MyString::<span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> MyString &amp;s)
{
    <span class="hljs-built_in">strcat</span>(m_p,s.m_p);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-comment">// MyString &amp;operator*()</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//  return *this;</span>
<span class="hljs-comment">// }</span>

<span class="hljs-comment">// MyString *operator-&gt;()</span>
<span class="hljs-comment">// {</span>
<span class="hljs-comment">//  return &amp;this-&gt;operator*();</span>
<span class="hljs-comment">// }</span>

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    MyString s1 = <span class="hljs-string">"s11"</span>;
    MyString s2(<span class="hljs-string">"s22"</span>);
    MyString s3 = s2;
    s3 = <span class="hljs-string">"s33"</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; s2[<span class="hljs-number">0</span>] &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; s3 &lt;&lt; endl;
    <span class="hljs-keyword">if</span>(s3 == <span class="hljs-string">"s33"</span>)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"equal"</span> &lt;&lt;endl;
    }

    <span class="hljs-keyword">if</span>(s2 &gt; s3)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s2&gt;s3"</span> &lt;&lt; endl;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"s2&lt;s3"</span> &lt;&lt; endl;
    }
    s3+=s2;
    <span class="hljs-built_in">cout</span> &lt;&lt; s3 &lt;&lt; endl;
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;MyString&gt;</span> vec{s1,s2,s3};
    stable_sort(begin(vec),end(vec),CheckString());
    <span class="hljs-built_in">cout</span> &lt;&lt; vec[<span class="hljs-number">1</span>];
    <span class="hljs-comment">// for (const auto s : vec)</span>
    <span class="hljs-comment">// {</span>
    <span class="hljs-comment">//  cout &lt;&lt; s &lt;&lt; endl;</span>
    <span class="hljs-comment">// }</span>
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>                    <div>
                        作者：daaikuaichuan 发表于 2018/01/26 11:39:36 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79170551">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79170551                    </div>
                    <div>
                        阅读：42                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]拷贝控制]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79155918</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79155918</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/01/24 21:36:02</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4" color="red">拷贝控制操作包括拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。如果一个类没有定义所有这些拷贝控制成员，编译器会为它定义缺失的操作（尽量明确定义对象拷贝、赋值、移动或者销毁时做什么）。</font></p>

<p><font size="5"><strong>一、拷贝、赋值与销毁</strong></font> <br>
<font size="4"><strong>1、构造函数、默认构造函数和拷贝构造函数</strong></font> <br>
 <font size="4"><strong>（1）构造函数</strong></font> <br>
  <font size="4"> 构造函数与其他函数不同：构造函数和类同名，没有返回类型。 <br>
  <font size="4">构造函数与其他函数相同：构造函数也有形参表(可为void)和函数体。  （参数表为void的构造函数为默认构造函数） <br>
  <font size="4">构造函数构造类对象的顺序是：<font size="4"> <br>
1、内存分配，构造函数调用的时候 隐士\显示的初始化各数据。 <br>
2、执行构造函数的运行。 <br>
 <font size="4"><strong>（2）默认构造函数</strong></font> <br>
  <font size="4" color="blue"> 合成的默认构造函数：当类中没有定义构造函数(注意是构造函数)的时候，编译器自动生成的函数。但是我们不能过分依赖编译器，如果我们的类中有复合类型或者自定义类型成员，我们需要自己定义构造函数。</font> <br>
  <font size="4"> 自定义的默认构造函数：</font></font></font></font></font></p>

<pre class="prettyprint"><code class=" hljs matlab">A(): a(<span class="hljs-number">0</span>) <span class="hljs-cell">{}</span>  
A(int <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>): a(<span class="hljs-built_in">i</span>) <span class="hljs-cell">{}</span>  </code></pre>

<p><font size="4">可能疑问的是第二个构造函数也是默认构造函数么？是的，因为参数中带有默认值。</font></p>

<p><font size="4"><strong>（3）拷贝构造函数</strong></font> <br>
  <font size="4"> 拷贝构造函数：如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，此构造函数是拷贝构造函数。</font></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span>:  
    <span class="hljs-title">Foo</span>();   <span class="hljs-comment">//默认构造函数  </span>
    Foo(<span class="hljs-keyword">const</span> Foo&amp;); <span class="hljs-comment">//拷贝构造函数  </span>
};  </code></pre>

<p>  <font size="4" color="green">拷贝构造函数的第一个参数是必须是自身类类型的引用类型,如果不是引用会无限递归。构造函数是特殊的成员函数，只要创建类类型的新对象，都要执行构造函数。构造函数的工作就是保证每个对象的数据成员具有合适的初始值。</font></p>

<p><font size="4"><strong>（1）合成拷贝构造函数</strong></font> <br>
  <font size="4">合成拷贝构造函数：我们没有为类定义拷贝构造函数，编译器会帮我们定义一个。编译器从给定对象中依次将每个<font color="blue">非static成员</font>拷贝到正在创建的对象中。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。 <br>
使用</font></p>

<p><font size="4"><strong>（2）拷贝初始化和直接初始化</strong></font> <br>
  <font size="4" color="red"> 直接初始化：编译器使用普通的函数匹配，来选择与我们提供的参数最匹配的构造函数。</font> <br>
  <font size="4" color="green">拷贝初始化：将右侧的对象拷贝到正在创建的对象中，通常使用拷贝构造函数来完成，如果需要的话还要进行类型转换。</font> <br>
  <font size="4">调用拷贝构造函数 除了=还有：<font size="4"> <br>
 - 将一个对象作为实参传递给一个非引用类型的形参。 <br>
 - 从一个返回类型为非引用的函数返回一个对象。 <br>
 - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。 <br>
  <font size="4" color="blue">拷贝构造函数不应该是explicit的。</font>每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝狗杂函数会逐元素地拷贝一个数组类型的成员。当初化标准库容器或是调用其insert或push成员时，容器会对其元素进行拷贝初始化，相对的，用emplace成员创建的元素都进行直接初始化。</font></font></p>

<p><font size="4"><strong>（3）参数和返回值</strong></font> <br>
  <font size="4" color="red"> 拷贝构造函数的参数必须是引用：</font> <br>
  <font size="4">为了调用拷贝构造函数，我们必须拷贝实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此循环，所以构造函数被用来初始化非引用类类型参数，解释了为什么拷贝构造函数自己的参数一定是引用类型。 <br>
  <font size="4">返回值被用来初始化调用方的结果。</font></font></p>

<p><font size="4"><strong>2、深拷贝与浅拷贝</strong></font> <br>
  <font size="4">浅拷贝: obj1.memberPtr和obj2.memberPtr可能指向同一块堆内存, 这样obj1如果修改了这块内存, 那么obj2的数据也会被改变（特别是析构的时候）。例如： <br>
<img src="http://img.blog.csdn.net/20180124191649550?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
  <font size="4">深拷贝: 当进行对象拷贝的时候, 不是进行简单的对象赋值, 而是把堆内存中的数据也一一单独再划一块地方赋值存储, 实现对象之间两不影响的效果, 就叫做深拷贝。 <br>
  <font size="4">当类中有指针或者动态分配的内存时，尤其会产生这类问题。例子如下：</font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> Array
{
<span class="hljs-keyword">public</span>:
    Array(<span class="hljs-keyword">int</span> count) 
    { 
        m_iCount = count;
        m_pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m_iCount];<span class="hljs-comment">//申请动态内存。</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_iCount; ++i)
            m_pArr[i] = i;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Array"</span> &lt;&lt; endl; 
    }
    Array(<span class="hljs-keyword">const</span> Array &amp;arr) 
    {       
        m_iCount = arr.m_iCount; 
        <span class="hljs-comment">//浅拷贝：</span>
        <span class="hljs-comment">//m_pArr = arr.m_pArr。m_pArr和arr.m_pArr指向相同的内存地址。</span>
        <span class="hljs-comment">//深拷贝：</span>
        m_pArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m_iCount];<span class="hljs-comment">//重新申请一段内存。</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_iCount; ++i)
            m_pArr[i] = arr.m_pArr[i];<span class="hljs-comment">//这时m_pArr和arr.m_pArr已经指向了不同的内存地址。</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Array &amp;"</span> &lt;&lt; endl;
    }
    ~Array()
    {
        <span class="hljs-keyword">delete</span> [] m_pArr;
        m_pArr = <span class="hljs-keyword">nullptr</span>; 
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"~Array"</span> &lt;&lt; endl; 
    }
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> setCount(<span class="hljs-keyword">int</span> count) { m_iCount = count; }
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> getCount(){ <span class="hljs-keyword">return</span> m_iCount; }
    <span class="hljs-keyword">inline</span> printAddr() { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"m_pArr : "</span> &lt;&lt; m_pArr &lt;&lt; endl; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">int</span> m_iCount;
    <span class="hljs-keyword">int</span> *m_pArr;
};

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    Array arr1(<span class="hljs-number">5</span>);
    Array arr2(arr1);
    arr1.printAddr();
    arr2.printAddr();
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4"><strong>3、拷贝赋值运算符</strong></font></p>

<pre class="prettyprint"><code class=" hljs cs">HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr&amp; t)
{
    i = t.i;
    ps = <span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span>;
    *ps = *(t.ps);
}</code></pre>

<pre class="prettyprint"><code class=" hljs livecodeserver">HasPtr <span class="hljs-operator">a</span>,b;  
<span class="hljs-operator">a</span> = b; <span class="hljs-comment"> //使用Sales_data的拷贝赋值运算符 </span></code></pre>

<p>  <font size="4">和拷贝构造函数一样，如果类未定义拷贝赋值运算符，编译器会合成一个。赋值构造函数必须注意它的函数原型，参数通常是引用类型，返回值通常也是引用类型，否则在传参和返回的时候都会再次调用一次拷贝构造函数。</font></p>

<p><font size="4"><strong>3、析构函数</strong></font> <br>
  <font size="4" color="green">析构函数执行的与构造函数执行的顺序相反，析构函数释放对象所使用的资源，并销毁对象的非static数据成员。 <br>
【Note】： <br>
1）析构函数不接受参数，不能被重载，对于一个类只有唯一一个析构函数。 <br>
2）隐式销毁一个内置指针类型的成员不会delete它所指向的对象。 <br>
3）当指向一个对象的引用或者指针离开作用域时，析构函数不会被执行</font> <br>
  <font size="4" color="red">在以下几种情况下会调用析构函数：</font><font size="4"> <br>
 - 变量在离开其作用域的时候； <br>
 - 当一个对象被销毁时，其成员被销毁； <br>
 - 容器被销毁时； <br>
 - 当对指向它的指针应用delete运算符时被销毁； <br>
 - 对于临时对象，当创建它的完整表达式结束时被销毁。</font></p>

<p><font size="4"><strong>4、一个demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;string&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> Str{
<span class="hljs-keyword">public</span>:
    Str() = <span class="hljs-keyword">default</span>;
    Str(<span class="hljs-built_in">string</span> s) :str(s),pstr(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>()){ <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"构造函数"</span> &lt;&lt; endl;  }
    Str(<span class="hljs-keyword">const</span> Str&amp; s){ 
        str = s.str;
        pstr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*s.pstr);
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"拷贝构造函数"</span> &lt;&lt; endl; 
    }
    Str&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Str&amp; s){
        str = s.str;
        pstr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*s.pstr);
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"拷贝赋值运算符"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    ~Str(){
        <span class="hljs-keyword">delete</span> pstr;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"析构函数"</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-built_in">string</span> * pstr;
};
Str func(Str s){
    <span class="hljs-keyword">return</span> s;
}
<span class="hljs-keyword">int</span> main(){
    Str str1(<span class="hljs-string">"aa"</span>);  <span class="hljs-comment">//直接初始化</span>
    Str str2 = str1; <span class="hljs-comment">//拷贝初始化</span>
    Str str3(str1);  <span class="hljs-comment">//拷贝初始化</span>
    Str str4;
    str4 = str1; <span class="hljs-comment">//赋值初始化</span>
    func(str1);<span class="hljs-comment">//见拷贝初始化，调用2次拷贝构造函数和2次析构函数</span>
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4"><strong>5、三/五法则、使用=default 、阻止拷贝：</strong></font> <br>
<font size="4"><strong>（1）三/五法则</strong></font> <br>
  <font size="4">如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。 <br>
  <font size="4">如果一个类需要一个拷贝构造函数，几乎可以肯定的它也需要一个拷贝赋值运算符，反之亦然。 <br>
  <font size="4">无论是需要拷贝构造函数还是需要拷贝运算符都不意味着也需要析构函数。</font></font></font></p>

<p><font size="4"><strong>（2）使用=default</strong></font> <br>
  <font size="4">我们可以通过将拷贝控制成员定义为=default来显示地让编译器来为我们生成默认版本。 <br>
<font size="4" color="green">【Note】： <br>
1）我们只能对具有合成版本的成员函数使用=default（即，默认构造函数或拷贝控制成员）。</font></font></p>

<p><font size="4"><strong>（3）阻止拷贝</strong></font> <br>
  <font size="4">新标准下，我们可以通过将拷贝构造函数和赋值运算符定义为删除的函数来阻止拷贝和赋值。 <br>
<font size="4" color="green">【Note】： <br>
1）=delete必须出现在函数第一次声明的时候。 <br>
2）析构函数不能是删除的成员。 <br>
3）如果一个类有数据成员不能默认构造、拷贝、复制或销毁、则对应的成员函数 <br>
将定义为删除的。</font> <br>
  <font size="4">删除一个类的析构函数或者类的某个成员的类型删除了析构函数，我们都不能定义该类的变量或临时对象。但可以动态分配这种类型，不能释放。</font></font></p>

<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">struct</span> NoDtor{  
    NoDtor() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">//使用合成默认构造函数  </span>
    ~NoDtor() = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">//我们不能销毁NoDtor类型的对象  </span>
};  
<span class="hljs-comment">//NoDtor nd;//错误：NoDtor的析构函数时删除的  </span>
NoDtor *p = <span class="hljs-keyword">new</span> NoDtor(); <span class="hljs-comment">//正确：但不能delete p  </span>
<span class="hljs-comment">//delete p; //错误：NoDtor的析构函数是删除的  </span></code></pre>

<p><font size="4"><strong>6、本节的demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;    </span>
<span class="hljs-preprocessor">#include &lt;string&gt;    </span>
<span class="hljs-preprocessor">#include &lt;fstream&gt;  </span>
<span class="hljs-preprocessor">#include &lt;list&gt;  </span>
<span class="hljs-preprocessor">#include &lt;vector&gt;   </span>
<span class="hljs-preprocessor">#include &lt;map&gt;    </span>
<span class="hljs-preprocessor">#include &lt;set&gt;  </span>
<span class="hljs-preprocessor">#include &lt;cctype&gt;  </span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;  </span>
<span class="hljs-preprocessor">#include &lt;utility&gt;<span class="hljs-comment">//保存pair的头文件。  </span></span>
<span class="hljs-preprocessor">#include &lt;memory&gt;  </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  
<span class="hljs-comment">//具体操作时将类的声明置于头文件中。  </span>
<span class="hljs-keyword">class</span> Employee  
{  
<span class="hljs-keyword">public</span>:  
    Employee();<span class="hljs-comment">//默认构造函数。  </span>
    Employee(<span class="hljs-built_in">string</span> &amp;s);<span class="hljs-comment">//接受一个string的构造函数。     </span>
    Employee(<span class="hljs-keyword">const</span> Employee &amp;) = <span class="hljs-keyword">delete</span>;<span class="hljs-comment">//不需要拷贝构造函数，雇员号不可能一样。将其声明为 =delete。  </span>
    Employee &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Employee &amp;) = <span class="hljs-keyword">delete</span>;  
    <span class="hljs-keyword">int</span> number(){<span class="hljs-keyword">return</span> _number;}  
<span class="hljs-keyword">private</span>:  
    <span class="hljs-built_in">string</span> employee;  
    <span class="hljs-keyword">int</span> _number;  
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> O_number;<span class="hljs-comment">//static静态成员数据在类内声明，但只可以在类外定义，在类外定义时可不加static。  </span>
};  

<span class="hljs-keyword">int</span> Employee::O_number = <span class="hljs-number">0</span>;  
Employee::Employee()<span class="hljs-comment">//默认构造函数。 </span>
{  
    _number = O_number++;  
}  
Employee::Employee(<span class="hljs-built_in">string</span>&amp; s)<span class="hljs-comment">//接受一个string的构造函数。  </span>
{  
    employee = s;  
    _number = O_number++;  
}  

<span class="hljs-keyword">void</span> show(Employee a)  
{  
    <span class="hljs-built_in">cout</span>&lt;&lt;a.number()&lt;&lt;endl;  
}  
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>**argv)    
{  
    Employee a, b, c;  
    show(a);<span class="hljs-comment">//调用函数时需要拷贝一次。  </span>
    show(b);<span class="hljs-comment">//发生错误，不允许拷贝和赋值。</span>
    show(c);  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}   </code></pre>

<p><font size="5"><strong>二、拷贝控制和资源管理、交换操作</strong></font> <br>
  <font size="4">通常管理类外资源的类必须定义拷贝控制成员。为了定义这些成员，首先必须确定此类型对象的拷贝语义。一般来说有两种选择： <br>
  <font size="4" color="blue">可以定义拷贝操作，使类看起来像一个值或像一个指针。值和指针的区别是，值由自己的状态，拷贝一个像值的对象，副本和原对象完全独立，而指针则共享状态。</font> <br>
  <font size="4">当用标准库时，容器和string类的行为像一个值。而不出意外的，shared_ptr类提供类似指针的行为，像StrBlob类一样。IO类型和unique_ptr不允许拷贝和赋值，因此它们的行为既不像值也不像指针。 <br>
<font size="4"><strong>1、行为像值的类</strong></font> <br>
  <font size="4">对于类资源的管理，每个对象都有一份自己的拷贝。 <br>
<font size="4" color="green">【Note】： <br>
1）如果将一个对象赋予它自身，赋值运算符必须能正常工作。 <br>
2）大多数赋值运算符组合了析构函数和拷贝构造函数的工作。 <br>
3）先将右侧运算对象拷贝到一个局部临时对象中，拷贝完后，左侧运算对象的现有成员就是安全的了。</font></font></font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> HasPtr{
    <span class="hljs-keyword">friend</span> ostream&amp; print(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> HasPtr&amp;);
<span class="hljs-keyword">public</span>:
    HasPtr(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s = <span class="hljs-built_in">string</span>()) :ps(<span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(s)), i(<span class="hljs-number">0</span>) { <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"构造函数"</span> &lt;&lt; endl; }
    HasPtr(<span class="hljs-keyword">const</span> HasPtr&amp; p) :ps(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p.ps)), i(p.i){ <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"拷贝构造函数"</span> &lt;&lt; endl; }
    HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr&amp;);
    ~HasPtr(){
        <span class="hljs-keyword">delete</span> ps;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"析构函数"</span> &lt;&lt; endl;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span>* ps;
    <span class="hljs-keyword">int</span> i;
};
HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> HasPtr &amp;p){
    <span class="hljs-keyword">auto</span> newp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(*p.ps);<span class="hljs-comment">//考给临时变量，万一=左值是自己就释放了。</span>
    <span class="hljs-keyword">delete</span> ps;
    ps = newp;
    i = p.i;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"拷贝赋值运算符"</span> &lt;&lt; endl;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
ostream&amp; print(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> HasPtr&amp; p){
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"string:"</span> &lt;&lt; *p.ps &lt;&lt; <span class="hljs-string">" int:"</span> &lt;&lt; p.i &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> os;
}

<span class="hljs-keyword">int</span> main(){
    HasPtr p1;
    HasPtr p2(<span class="hljs-string">"hehe"</span>);
    print(<span class="hljs-built_in">cout</span>, p1);
    print(<span class="hljs-built_in">cout</span>, p2);
    p1 = p2;
    print(<span class="hljs-built_in">cout</span>, p1);

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4"><strong>2、行为像指针的类</strong></font> <br>
  <font size="4">引用计数需要确定在哪里存放引用计数。计数器不能作为HasPtr对象的成员。一种方法是将计数器保存在动态内存中。当创建一个对象时，我们分配一个新的计数器。当拷贝或赋值对象时，拷贝指向计数器的指针。这种方式，副本和原对象都会指向相同的计数器。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">class</span> HasPtr{
    <span class="hljs-keyword">friend</span> ostream&amp; print(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> HasPtr&amp;);
<span class="hljs-keyword">public</span>:
    HasPtr(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s = <span class="hljs-built_in">string</span>()) :ps(<span class="hljs-keyword">new</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>(s)), i(<span class="hljs-number">0</span>), use(<span class="hljs-keyword">new</span> size_t(<span class="hljs-number">1</span>)){ <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"构造函数"</span> &lt;&lt; endl; }
    HasPtr(<span class="hljs-keyword">const</span> HasPtr&amp; p) :ps(p.ps), i(p.i), use(p.use){
        ++*use;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"拷贝构造函数"</span> &lt;&lt; endl;
    }
    HasPtr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> HasPtr&amp;);
    ~HasPtr();
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span>* ps;
    <span class="hljs-keyword">int</span> i;
    size_t* use;
};
HasPtr&amp; HasPtr::<span class="hljs-keyword">operator</span> = (<span class="hljs-keyword">const</span> HasPtr &amp;rhs){
    ++*rhs.use;  <span class="hljs-comment">//递增右侧运算对象的引用计数</span>
    <span class="hljs-keyword">if</span> (--*use == <span class="hljs-number">0</span>){  <span class="hljs-comment">//递减本对象的引用计数</span>
        <span class="hljs-keyword">delete</span> ps;
        <span class="hljs-keyword">delete</span> use;
    }
    ps = rhs.ps;  <span class="hljs-comment">//将数据从rhs拷贝到本对象</span>
    i = rhs.i;
    use = rhs.use;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
HasPtr::~HasPtr(){
    <span class="hljs-keyword">if</span> (--*use == <span class="hljs-number">0</span>){  <span class="hljs-comment">//如果引用计数变为0</span>
        <span class="hljs-keyword">delete</span> ps;     <span class="hljs-comment">//释放string内存</span>
        <span class="hljs-keyword">delete</span> use;   <span class="hljs-comment">//释放计时器内存</span>
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"析构函数"</span> &lt;&lt; endl;
}
ostream&amp; print(<span class="hljs-built_in">std</span>::ostream &amp;os, <span class="hljs-keyword">const</span> HasPtr&amp; p){
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"string:"</span> &lt;&lt; *p.ps &lt;&lt; <span class="hljs-string">" int:"</span> &lt;&lt; p.i &lt;&lt; <span class="hljs-string">" use:"</span> &lt;&lt; *p.use &lt;&lt; <span class="hljs-built_in">std</span>::endl;
    <span class="hljs-keyword">return</span> os;
}

<span class="hljs-keyword">int</span> main(){
    HasPtr p1;
    HasPtr p2(<span class="hljs-string">"hehe"</span>);
    print(<span class="hljs-built_in">cout</span>, p1);
    print(<span class="hljs-built_in">cout</span>, p2);
    p1 = p2;
    print(<span class="hljs-built_in">cout</span>, p1);

    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4"><strong>3、交换操作</strong></font> <br>
  <font size="4" color="red">与拷贝控制成员不同，swap并不是必要的，但对于分配了资源的类swap是个优化手段。</font> <br>
  <font size="4" color="red">swap函数应该调用swap而不是std::swap。</font> <br>
  <font size="4">标准库swap对HasPtr管理的string进行了不必要的拷贝。如果一个类的成员有自己类型特定的swap函数，调用std:swap就是错误的。如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本。拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这时，公共的工作应该放在private工具函数中完成。 <br>
  <font size="4">对于那些与重排元素顺序的算法一起使用的类，定义swap是非常重要的。这类算法在需要交换两个元素时会调用swap。</font></font></p>

<p><font size="4"><strong>4、本节的demo：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;    </span>
<span class="hljs-preprocessor">#include &lt;string&gt;  </span>
<span class="hljs-preprocessor">#include &lt;vector&gt;  </span>
<span class="hljs-preprocessor">#include &lt;algorithm&gt;  </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  

<span class="hljs-keyword">class</span> Hasptr1  
{  
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> swap(Hasptr1 &amp;,Hasptr1 &amp;);  
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Hasptr1 &amp;s1,<span class="hljs-keyword">const</span> Hasptr1 &amp;s2);  
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> show(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Hasptr1&gt;</span> &amp;vec);  
<span class="hljs-keyword">public</span>:  
    <span class="hljs-comment">//构造函数，初始化相关成员  </span>
    Hasptr1(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s = <span class="hljs-built_in">string</span>()):ps(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(s)),i(<span class="hljs-number">0</span>),use(<span class="hljs-keyword">new</span> size_t(<span class="hljs-number">1</span>)){}  

    <span class="hljs-comment">//拷贝构造函数，将引用计数也拷贝过来，并且递增引用计数  </span>
    Hasptr1(<span class="hljs-keyword">const</span> Hasptr1 &amp;p):ps(p.ps),i(p.i),use(p.use){++*use;}  

    <span class="hljs-comment">//拷贝赋值运算符  </span>
    Hasptr1 &amp;<span class="hljs-keyword">operator</span>= (<span class="hljs-keyword">const</span> Hasptr1 &amp;p1)  
    {  
        ++*p1.use;<span class="hljs-comment">//首先递增右侧运算符对象的引用计数  </span>
        <span class="hljs-keyword">if</span> (--*use == <span class="hljs-number">0</span>)<span class="hljs-comment">//递减本对象的引用计数，若没有其他用户，则释放本对象的成员  </span>
        {  
            <span class="hljs-keyword">delete</span> ps;  
            <span class="hljs-keyword">delete</span> use;  
        }  
        ps = p1.ps;<span class="hljs-comment">//进行拷贝  </span>
        use = p1.use;  
        i = p1.i;  
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  
    }  

    <span class="hljs-comment">//析构函数  </span>
    ~Hasptr1()  
    {  
        <span class="hljs-keyword">if</span> (*use == <span class="hljs-number">0</span>)<span class="hljs-comment">//引用计数变为0，说明已经没有对象再需要这块内存，进行释放内存操作  </span>
        {  
            <span class="hljs-keyword">delete</span> ps;  
            <span class="hljs-keyword">delete</span> use;  
        }  
    }  
<span class="hljs-keyword">private</span>:  
    <span class="hljs-comment">//定义为指针，是我们想将该string对象保存在动态内存中  </span>
    <span class="hljs-built_in">string</span> *ps;  
    size_t *use;<span class="hljs-comment">//将计数器的引用保存  </span>
    <span class="hljs-keyword">int</span> i;  
};  

<span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> swap(Hasptr1 &amp;a,Hasptr1 &amp;b)  
{  
    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;  
    swap(a.ps,b.ps);  
    <span class="hljs-built_in">std</span>::swap(a.i,b.i);  
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"123"</span>;  
}  

<span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt; (<span class="hljs-keyword">const</span> Hasptr1 &amp;s1,<span class="hljs-keyword">const</span> Hasptr1 &amp;s2)  
{  
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"定义的 Operator&lt; 被调用"</span>&lt;&lt;endl;  
    <span class="hljs-keyword">return</span> *s1.ps &lt; *s2.ps;  
}  

<span class="hljs-keyword">void</span> show(<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Hasptr1&gt;</span> &amp;vec)  
{  
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Hasptr1&gt;</span>::iterator it1 = vec.begin();  
    <span class="hljs-keyword">for</span> (it1; it1 != vec.end(); ++it1)  
    {  
        <span class="hljs-built_in">cout</span>&lt;&lt;*(it1-&gt;ps)&lt;&lt;endl;  
    }  
}  
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>**argv)    
{  
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Hasptr1&gt;</span> vec1;  
    Hasptr1 a(<span class="hljs-string">"l"</span>);  
    Hasptr1 b(<span class="hljs-string">"llll"</span>);  
    Hasptr1 c(<span class="hljs-string">"lll"</span>);  
    vec1.push_back(a);  
    vec1.push_back(b);  
    vec1.push_back(c);  
    <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;Hasptr1&gt;</span>::iterator it1 = vec1.begin();  
    sort(vec1.begin(),vec1.end());  
    show(vec1);  
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}    </code></pre>

<p><font size="5"><strong>三、拷贝控制示例</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> Message;
<span class="hljs-keyword">class</span> Folder
{
<span class="hljs-keyword">public</span>:
    Folder() = <span class="hljs-keyword">default</span>;
    Folder(<span class="hljs-keyword">const</span> Folder &amp;);
    Folder &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Folder &amp;);
    ~Folder() = <span class="hljs-keyword">default</span>;
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> AddMsg(Message* msg){ messages.insert(msg); }
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> RemMsg(Message* msg){ messages.erase(msg); }
<span class="hljs-keyword">private</span>:
    <span class="hljs-stl_container"><span class="hljs-built_in">set</span>&lt;Message*&gt;</span> messages;
};
<span class="hljs-keyword">class</span> Message
{
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> Folder;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">explicit</span> Message(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;str = <span class="hljs-string">""</span>):contents(str){}
    Message &amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Message &amp;);<span class="hljs-comment">//拷贝赋值运算符。</span>
    Message(<span class="hljs-keyword">const</span> Message &amp;);<span class="hljs-comment">//拷贝构造函数。</span>
    <span class="hljs-comment">//移动构造函数。移动contents。</span>
    Message(Message &amp;&amp;m): contents(<span class="hljs-built_in">std</span>::move(m.contents)){ move_folders(&amp;m); }
    Message &amp; <span class="hljs-keyword">operator</span>=(Message &amp;&amp;rhs);
    ~Message(){ remove_from_Folders(); }<span class="hljs-comment">//析构函数。</span>
    <span class="hljs-keyword">void</span> save(Folder &amp;);  
    <span class="hljs-keyword">void</span> remove(Folder &amp;);<span class="hljs-comment">//对Folder类的操作函数。</span>
    <span class="hljs-keyword">void</span> swap(Message &amp;m1,Message &amp;m2)。
    <span class="hljs-keyword">void</span> move_folders(Message *m);
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">string</span> contents;
    <span class="hljs-stl_container"><span class="hljs-built_in">set</span>&lt;Folder*&gt;</span> folders;
    <span class="hljs-keyword">void</span> add_to_Folders(<span class="hljs-keyword">const</span> Message&amp;);
    <span class="hljs-keyword">void</span> remove_from_Folders();<span class="hljs-comment">//从folders中删除本message。</span>
};

<span class="hljs-keyword">void</span> Message::move_folders(Message *m)
{
    folders = <span class="hljs-built_in">std</span>::move(m-&gt;folders);<span class="hljs-comment">//使用set的移动赋值。</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : folders)
    {
        f-&gt;RemMsg(m);<span class="hljs-comment">//删除旧元素。</span>
        f-&gt;AddMsg(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//添加新元素。</span>
    }
    m-&gt;folders.clear();<span class="hljs-comment">//确保销毁是无害的。</span>
}

<span class="hljs-keyword">void</span> Message::save(Folder &amp;f)
{
    folders.insert(&amp;f);<span class="hljs-comment">//将给定folder加入到我们的folders中。</span>
    f.AddMsg(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//将本message添加到给定folder中。</span>
}

<span class="hljs-keyword">void</span> Message::remove(Folder &amp;f)
{  
    folders.erase(&amp;f);<span class="hljs-comment">//将给定folder在我们的folders中删除。</span>
    f.RemMsg(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//将本message在给定folder中删除。</span>
} 

<span class="hljs-keyword">void</span> Message::add_to_Folders(<span class="hljs-keyword">const</span> Message &amp;m)  
{  
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : m.folders)  
    {  
        f-&gt;AddMsg(<span class="hljs-keyword">this</span>);  
    }  
}  

<span class="hljs-keyword">void</span> Message::remove_from_Folders()  
{  
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : folders)  
    {  
        f-&gt;RemMsg(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//所有包含此message的folder进行删除操作。 </span>
    }  
}  

Message &amp; Message::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Message &amp;m)<span class="hljs-comment">//拷贝赋值运算符。  </span>
{  
    remove_from_Folders();<span class="hljs-comment">//删除自身。  </span>
    contents = m.contents;  
    folders = m.folders;  
    add_to_Folders(m);<span class="hljs-comment">//将本message传入folder中。  </span>
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  
}

Message &amp; <span class="hljs-keyword">operator</span>=(Message &amp;&amp;rhs)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;rhs)
    {
        remove_from_Folders();
        contents = <span class="hljs-built_in">std</span>::move(rhs.contents);
        move_folders(&amp;rhs);
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-keyword">void</span> Message::swap(Message &amp;m1,Message &amp;m2)  
{  
    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;  
    <span class="hljs-comment">//先将每个message从其folders中删除。  </span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f : m1.folders)  
    {  
        f-&gt;RemMsg(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//所有包含此message的folder进行删除操作。  </span>
    }  
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> f : m2.folders)  
    {  
        f-&gt;RemMsg(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//所有包含此message的folder进行删除操作。  </span>
    }  
    swap(m1.folders,m2.folders);  
    swap(m1.contents,m2.contents);  
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : m1.folders)  
    {  
        f-&gt;AddMsg(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//再进行添加操作。  </span>
    }  
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> f : m2.folders)  
    {  
        f-&gt;AddMsg(<span class="hljs-keyword">this</span>);  
    }  
}  

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    Message m(<span class="hljs-string">"ABC"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="5"><strong>四、动态内存管理类</strong></font> <br>
  <font size="4">StrVec的设计：vector的每个添加元素的成员函数会检查是否有空间容纳更多的元素。如果有，成员函数会在下一个可用位置构造一个对象。如果没有可用空间，vector就会重新分配空间：它获得新的空间，将已有元素移动到新空间，释放旧空间，并添加新元素。free成员，一旦元素被销毁，就调用deallocate来释放StrVec对象分配的内存空间，我们传递给deallocate的指针必须是之前某次allocate调用所返回的指针，因此在调用deallocate之前我们首先检查elements是否为空。 <br>
  <font size="4">在重新分配内存的过程中移动而不是拷贝元素。当拷贝一个string时，新string和原string是相互独立的。由于string的行为类似值，每个string对构成它的所有字符都会保存自己的一份副本。拷贝一个string必须为这些字符 分配内存空间。一旦将元素拷贝到新空间，就会立即销毁原string。所以，拷贝这些string中的数据是多余的。move标准库函数定义在utility中。两个要点，当reallocate在新内存中构造string时，它必须调用move来表示希望使用string的移动构造函数。如果漏掉move操作，将使用string的拷贝构造函数。另外，不为move提供using声明。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;bits/stdc++.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> StrVec
{
<span class="hljs-keyword">public</span>:
    StrVec():elements(<span class="hljs-keyword">nullptr</span>), first_free(<span class="hljs-keyword">nullptr</span>), cap(<span class="hljs-keyword">nullptr</span>){}
    <span class="hljs-comment">//拷贝构造函数。</span>
    StrVec(<span class="hljs-keyword">const</span> StrVec &amp;);
    <span class="hljs-comment">//移动构造函数。</span>
    StrVec(StrVec &amp;&amp;s) <span class="hljs-keyword">noexcept</span> : elements(s.elements),first_free(s.first_free),cap(s.cap)
    {
        s.elements = s.first_free = s.cap = <span class="hljs-keyword">nullptr</span>;
    }
    <span class="hljs-comment">//拷贝赋值运算符。</span>
    StrVec &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> StrVec &amp;);
    <span class="hljs-comment">//移动赋值运算符。</span>
    StrVec &amp;<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span>;
    <span class="hljs-comment">//为三个指针进行初始化，并将成员进行赋值。</span>
    StrVec(initializer_list&lt;<span class="hljs-built_in">string</span>&gt; lst)
    {   
        <span class="hljs-keyword">auto</span> newdata = alloc_n_copy(lst.begin(), lst.end());    
        elements = newdata.first;    
        first_free = cap = newdata.second;    
    }
    ~StrVec(){ <span class="hljs-built_in">free</span>(); }
    <span class="hljs-keyword">void</span> push_back(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;);<span class="hljs-comment">//拷贝元素。</span>
    <span class="hljs-keyword">void</span> push_back(<span class="hljs-built_in">string</span> &amp;&amp;);<span class="hljs-comment">//移动元素。</span>
    size_t size() <span class="hljs-keyword">const</span>{ <span class="hljs-keyword">return</span> first_free - elements; }
    size_t capacity() <span class="hljs-keyword">const</span>{ <span class="hljs-keyword">return</span> cap - elements; }
    <span class="hljs-built_in">string</span> *begin() <span class="hljs-keyword">const</span>{ <span class="hljs-keyword">return</span> elements; }
    <span class="hljs-built_in">string</span> *end() <span class="hljs-keyword">const</span>{ <span class="hljs-keyword">return</span> first_free; }
<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">static</span> allocator&lt;<span class="hljs-built_in">string</span>&gt; alloc;<span class="hljs-comment">//声明但是未定义，静态成员必须在函数外定义。</span>
    <span class="hljs-comment">//没有空间容纳新元素，使用reallocate重新分配内存。</span>
    <span class="hljs-keyword">void</span> chk_n_alloc()
    {
        <span class="hljs-keyword">if</span>(size() == capacity())
            reallocate();
    }
    pair&lt;<span class="hljs-built_in">string</span>*,<span class="hljs-built_in">string</span>*&gt; alloc_n_copy(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>*, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>*);
    <span class="hljs-keyword">void</span> <span class="hljs-built_in">free</span>();<span class="hljs-comment">//销毁元素并释放内存。</span>
    <span class="hljs-keyword">void</span> reallocate();<span class="hljs-comment">//获得更多内存并拷贝已有元素。</span>
    <span class="hljs-built_in">string</span> *elements;<span class="hljs-comment">//指向数组首元素的指针。</span>
    <span class="hljs-built_in">string</span> *first_free;<span class="hljs-comment">//指向数组第一个空闲元素的指针。</span>
    <span class="hljs-built_in">string</span> *cap;<span class="hljs-comment">//指向数组尾后位置的指针。</span>
};

<span class="hljs-comment">//通过实参是右值还是左值确认调用那个版本。</span>
<span class="hljs-keyword">void</span> StrVec::push_back(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s)
{
    chk_n_alloc();<span class="hljs-comment">//确保有空间容纳新元素。</span>
    alloc.construct(first_free++, s);<span class="hljs-comment">//使用未加1之前的值，递增构造对象。</span>
}

<span class="hljs-keyword">void</span> StrVec::push_back(<span class="hljs-built_in">string</span> &amp;&amp;s)
{
    chk_n_alloc();
    alloc.construct(first_free++, <span class="hljs-built_in">std</span>::move(s));
}

pair&lt;<span class="hljs-built_in">string</span>*,<span class="hljs-built_in">string</span>*&gt; 
alloc_n_copy(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> *b, <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> *e)<span class="hljs-comment">//将元素拷贝到新的内存中。</span>
{
    <span class="hljs-keyword">auto</span> data = alloc.allocate(e - b);
    <span class="hljs-keyword">return</span> {data,uninitialized_copy(b,e,data)};<span class="hljs-comment">//使用列表初始化返回。</span>
}

<span class="hljs-keyword">void</span> StrVec::<span class="hljs-built_in">free</span>()
{
    <span class="hljs-keyword">if</span>(elements)
    {
        <span class="hljs-comment">//销毁旧元素。</span>
        for_each(elements, first_free, [<span class="hljs-keyword">this</span>](<span class="hljs-built_in">string</span> &amp;rhs){ alloc.destroy(&amp;rhs); });  
        alloc.deallocate(elements, cap-elements);
    }
}

<span class="hljs-comment">//拷贝构造函数。</span>
StrVec::StrVec(<span class="hljs-keyword">const</span> StrVec &amp;s)
{
    <span class="hljs-keyword">auto</span> newdata = alloc_n_copy(s.begin(),s.end());
    elements = newdata.first;
    first_free = cap = newdata.second;
}

<span class="hljs-comment">//拷贝赋值运算符。</span>
StrVec &amp;StrVec::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> StrVec &amp;rhs)
{
    <span class="hljs-comment">//调用alloc_n_copy分配内存。</span>
    <span class="hljs-keyword">auto</span> data = alloc_n_copy(rhs.begin(),rhs.end());
    <span class="hljs-built_in">free</span>();
    elements = data.first;
    first_free = cap = data.second;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-comment">//移动赋值运算符。</span>
StrVec &amp;StrVec::<span class="hljs-keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="hljs-keyword">noexcept</span>
{
    <span class="hljs-comment">//检查自赋值。</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> != &amp;rhs)
    {
        <span class="hljs-built_in">free</span>();<span class="hljs-comment">//释放旧资源。</span>
        <span class="hljs-comment">//从rhs接管资源。</span>
        elements = rhs.elements;
        first_free = rhs.first_free;
        cap = rhs.cap;
        <span class="hljs-comment">//将rhs置于可析构状态。</span>
        rhs.elements = rhs.first_free = rhs.cap = <span class="hljs-keyword">nullptr</span>;
    }
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}

<span class="hljs-keyword">void</span> StrVec::reallocate()
{  
    <span class="hljs-comment">//分配当前大小两倍的空间。</span>
    <span class="hljs-keyword">auto</span> newcapacity = size() ? <span class="hljs-number">2</span> * size() : <span class="hljs-number">1</span>;
    <span class="hljs-comment">//分配新内存。</span>
    <span class="hljs-keyword">auto</span> first = alloc.allocate(newcapacity);
    <span class="hljs-comment">//将数据从旧内存移动到新内存,使用移动迭代器。</span>
    <span class="hljs-keyword">auto</span> last = uninitialized_copy(
        make_move_iterator(begin()),
        make_move_iterator(end()),
        first);
    <span class="hljs-built_in">free</span>();<span class="hljs-comment">//释放旧内存。</span>
    <span class="hljs-comment">//更新数据。</span>
    elements = first;
    first_free = last;
    cap = elements + newcapacity;
}

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    StrVec sv;
    <span class="hljs-built_in">string</span> s = <span class="hljs-string">"ABC"</span>;
    sv.push_back(s);
    sv.push_back(<span class="hljs-string">"edf"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; sv.size() &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; sv.capacity() &lt;&lt; endl;
    system(<span class="hljs-string">"pause"</span>);    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="5"><strong>五、对象移动</strong></font> <br>
  <font size="4" color="blue">新标准的移动对象的能力。在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。这一特定源于IO类或unique_ptr这些类。它们包括被共享的资源，因此，这些类的对象不能拷贝只能移动。</font></p>

<p><font size="4"><strong>1、左值、右值、右值引用详解</strong></font> <br>
 <font size="4"><strong>（1）左值、右值</strong></font> <br>
  <font size="4">在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。<font color="green">在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）</font>。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</font></p>

<p><font size="4"><strong>（2）右值、将亡值</strong></font> <br>
  <font size="4">在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。 <br>
  <font size="4">C++11对C++98中的右值进行了扩充。<font color="red">在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）</font>。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；<font color="green">将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），</font>比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。 <br>
  <font size="4">将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</font></font></font></p>

<p><font size="4"><strong>（3）左值引用、右值引用</strong></font> <br>
  <font size="4" color="blue">左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</font> <br>
  <font size="4">右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，<font color="green">都必须立即进行初始化</font>。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。 <br>
  <font size="4">左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</font></font></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">int</span> &amp;a = <span class="hljs-number">2</span>;       <span class="hljs-preprocessor"># 左值引用绑定到右值，编译失败</span>
<span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;        <span class="hljs-preprocessor"># 非常量左值</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;c = b; <span class="hljs-preprocessor"># 常量左值引用绑定到非常量左值，编译通过</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> d = <span class="hljs-number">2</span>;  <span class="hljs-preprocessor"># 常量左值</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;e = c; <span class="hljs-preprocessor"># 常量左值引用绑定到常量左值，编译通过</span>
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;b =<span class="hljs-number">2</span>;  <span class="hljs-preprocessor"># 常量左值引用绑定到右值，编程通过</span></code></pre>

<p>  <font size="4">右值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">int</span> a;
<span class="hljs-keyword">int</span> &amp;&amp;r1 = c;             <span class="hljs-preprocessor"># 编译失败</span>
<span class="hljs-keyword">int</span> &amp;&amp;r2 = <span class="hljs-built_in">std</span>::move(a);  <span class="hljs-preprocessor"># 编译通过</span></code></pre>

<p>  <font size="4">下表列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。  <br>
<img src="http://img.blog.csdn.net/20180124205349732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></p>

<p><font size="4" color="green">【Note】： <br>
1）我们可以将一个右值引用绑定到表达式、字面值常量或者返回右值的表达式，但是不能将右值引用绑定到左值上。 <br>
2）右值引用指向将要被销毁的对象。 <br>
3）变量是左值，因此我们不能把右值引用直接绑定到变量上。 <br>
4）我们可以销毁一个移后源对象，也可以赋予其新值，但是不能使用一个移后源对象的值。 <br>
5）应该使用std::move而不是move，这样可以避免潜在的名字冲突。</font></p>

<p><font size="4"><strong>2、移动构造函数和移动赋值运算符</strong></font> <br>
 <font size="4"><strong>（1）移动语义详解</strong></font> <br>
  <font size="4">移动语义，简单来说解决的是各种情形下对象的资源所有权转移的问题。而在C++11之前，移动语义的缺失是C++饱受诟病的问题之一。举个栗子： <br>
  <font size="4">问题一：如何将大象放入冰箱？答案是众所周知的。首先你需要有一台特殊的冰箱，这台冰箱是为了装下大象而制造的。你打开冰箱门，将大象放入冰箱，然后关上冰箱门。 <br>
  <font size="4">问题二：如何将大象从一台冰箱转移到另一台冰箱？普通解答：打开冰箱门，取出大象，关上冰箱门，打开另一台冰箱门，放进大象，关上冰箱门。2B解答：在第二个冰箱中启动量子复制系统，克隆一只完全相同的大象，然后启动高能激光将第一个冰箱内的大象气化消失。等等，这个2B解答听起来很耳熟，这不就是C++中要移动一个对象时所做的事情吗？ <br>
  <font size="4">“移动”，这是一个三岁小孩都明白的概念。将大象（资源）从一台冰箱（对象）移动到另一台冰箱，这个行为是如此自然，没有任何人会采用先复制大象，再销毁大象这样匪夷所思的方法。C++通过拷贝构造函数和拷贝赋值操作符为类设计了拷贝/复制的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式。否则，就需要自己实现移动资源的接口。 <br>
  <font size="4">为了实现移动语义，首先需要解决的问题是，如何标识对象的资源是可以被移动的呢？这种机制必须以一种最低开销的方式实现，并且对所有的类都有效。C++的设计者们注意到，大多数情况下，右值所包含的对象都是可以安全的被移动的。右值（相对应的还有左值）是从C语言设计时就有的概念，但因为其如此基础，也是一个最常被忽略的概念。不严格的来说，左值对应变量的存储位置，而右值对应变量的值本身。C++中右值可以被赋值给左值或者绑定到引用。类的右值是一个临时对象，如果没有被绑定到引用，在表达式结束时就会被废弃。于是我们可以在右值被废弃之前，移走它的资源进行废物利用，从而避免无意义的复制。被移走资源的右值在废弃时已经成为空壳，析构的开销也会降低。右值中的数据可以被安全移走这一特性使得右值被用来表达移动语义。以同类型的右值构造对象时，需要以引用形式传入参数。右值引用顾名思义专门用来引用右值，左值引用和右值引用可以被分别重载，这样确保左值和右值分别调用到拷贝和移动的两种语义实现。对于左值，如果我们明确放弃对其资源的所有权，则可以通std::move()来将其转为右值引用。std::move()实际上是<code>static_cast&lt;T&amp;&amp;&gt;()</code>的简单封装。</font></font></font></font></font></p>

<p><font size="4"><strong>（2）移动构造函数</strong></font> <br>
  <font size="4">移动构造函数类似于拷贝构造函数，第一参数是该类类型的一个引用，但这个引用参数在移动构造函数中是一个右值引用。 <br>
  <font size="4" color="red">与拷贝构造函数不同，移动构造函数不分配新内存；它接管内存并把对象中的指针都置为nullptr。最终，移后源对象会被销毁，意味着将在其上运行析构函数。 <br>
<img src="http://img.blog.csdn.net/20180124211705711?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></font></p>

<pre class="prettyprint"><code class=" hljs livecodeserver">A(A &amp;&amp; h) : <span class="hljs-operator">a</span>(h.<span class="hljs-operator">a</span>)  
{  
    h.<span class="hljs-operator">a</span> = nullptr;<span class="hljs-comment"> //还记得nullptr？  </span>
}  </code></pre>

<p>  <font size="4">可以看到，这个构造函数的参数不同，有两个&amp;操作符，   移动构造函数接收的是“右值引用”的参数。 <br>
  <font size="4">移动构造函数何时触发？  那就是临时对象（右值）。用到临时对象的时候就会执行移动语义。<font color="green">这里要注意的是，异常发生的情况，要尽量保证移动构造函数 不发生异常，可以通过noexcept关键字，这里可以保证移动构造函数中抛出来的异常会直接调用terminate终止程序。</font></font></font></p>

<p><font size="4"><strong>（3）移动赋值操作符</strong></font> <br>
  <font size="4">原理跟移动构造函数相同，这里不再多说:</font></p>

<pre class="prettyprint"><code class=" hljs autohotkey"><span class="hljs-literal">A</span> &amp; operator = (<span class="hljs-literal">A</span>&amp;&amp; h)
{
    assert(this != &amp;h)<span class="hljs-comment">;</span>

    <span class="hljs-literal">a</span> = nullptr<span class="hljs-comment">;</span>
    <span class="hljs-literal">a</span> = move(h.<span class="hljs-literal">a</span>)<span class="hljs-comment">;</span>
    h.<span class="hljs-literal">a</span> = nullptr<span class="hljs-comment">;</span>
    <span class="hljs-keyword">return</span> *this<span class="hljs-comment">;</span>
}</code></pre>

<p><font size="4" color="green">【Note】： <br>
1）不抛出异常的移动构造函数和移动赋值函数运算符必须标记为noexcept。 <br>
2）移后源对象必须可析构。</font></p>

<p><font size="4"><strong>（4）合成的移动操作</strong></font> <br>
  <font size="4" color="blue">只有一个类没有定义任何拷贝控制成员(拷贝构造函数,拷贝赋值运算符,析构函数)时, 且类的所有非static成员都是可移动的, 此时编译器才会给该类合成移动构造函数和移动赋值运算符。</font> <br>
  <font size="4">当既有拷贝操作也有移动操作时,使用哪个? <br>
  <font size="4" color="green">一条原则:移动右值,拷贝左值。即当右边是一个右值时, 就优先使用移动操作(也可以使用拷贝)。当右边是一个左值时, 只能使用拷贝操作(除非使用std::move将其转换)。 <br>
  <font size="4">必要时候, 右值也能被拷贝构造函数和拷贝赋值运算符拷贝。但是拷贝构造函数和拷贝赋值运算符的参数必须是const类型的引用才行, 如果不是就会出错(可以自己试试看看到底是什么情况)。</font></font></font></p>

<p><font size="4"><strong>（5）赋值运算符实现拷贝赋值和移动赋值两种功能</strong></font> <br>
  <font size="4">如果赋值运算符的形参是传值调用, 那么用实参初始化形参就需要调用拷贝构造函数(实参是左值)或移动构造函数(实参是右值)。那么可以用下面方式实现等价的拷贝赋值和移动赋值。(注意:下面的程序=操作符内使用的是自定义的swap, 因为标准库的swap需要类支持=操作符, 但是=操作符我们还没定义)。</font></p>

<p><font size="4"><strong>3、右值和左值引用成员函数 </strong></font> <br>
  <font size="4">在类的成员函数后面加上&amp; 或&amp;&amp; 可以限定该成员函数只能接受左值或右值的参数。同样可以避免对右值对象使用=赋值等操作。 <br>
<img src="http://img.blog.csdn.net/20180124213315131?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></p>

<p>参考：<a href="http://blog.csdn.net/ruan875417/article/details/44854189" target="_blank">http://blog.csdn.net/ruan875417/article/details/44854189</a> <br>
<a href="http://blog.csdn.net/refuil/article/details/51547815" target="_blank">http://blog.csdn.net/refuil/article/details/51547815</a> <br>
<a href="http://blog.csdn.net/hyman_yx/article/details/52044632" target="_blank">http://blog.csdn.net/hyman_yx/article/details/52044632</a> <br>
<a href="https://www.zhihu.com/question/22111546" target="_blank">https://www.zhihu.com/question/22111546</a> <br>
<a href="http://blog.csdn.net/Jofranks/article/details/17438955" target="_blank">http://blog.csdn.net/Jofranks/article/details/17438955</a> <br>
<a href="http://blog.csdn.net/u013480600/article/details/44151643" target="_blank">http://blog.csdn.net/u013480600/article/details/44151643</a></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/01/24 21:36:02 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79155918">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79155918                    </div>
                    <div>
                        阅读：76                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]动态内存和智能指针]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79144866</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79144866</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/01/23 21:26:34</pubDate>
                <description>
                    <![CDATA[
                    <p><font size="5"><strong>一、动态内存</strong></font> <br>
  <font size="4">c++ 内存获取和释放 new/delete，new[]/delete[] <br>
  <font size="4">c 内存获取和释放 malloc/free,calloc/realloc <br>
  <font size="4">上述8个函数/操作符是c/c++语言里常用来做动态内存的申请和释放的，要理解这些接口，大概需要下面几个维度的了解: <br>
<font size="4"><strong>1、了解OS的进程空间模型</strong></font> <br>
  <font size="4">一个进程的地址空间，一般划分为内核区、用户区，用户区又划分为栈区、堆区、数据区、代码区。这里的‘堆区’，‘栈区’，‘数据区’，‘内核区’，其实就是一个虚拟地址区间，动态内存最终都是从OS的’堆区’上获取的。</font></font></font></font></p>

<p><font size="4"><strong>2、brk、mmap 系统调用</strong></font> <br>
  <font size="4">brk系统调用，可以让进程的堆指针增长一定的大小，逻辑上消耗掉一块本进程的虚拟地址区间，<font size="4" color="red">malloc向OS获取的内存大小比较小时，将直接通过brk调用获取虚拟地址，结果是将本进程的brk指针推高。</font> <br>
  <font size="4">mmap系统调用，可以让进程的虚拟地址区间里切分出一块指定大小的虚拟地址区间vma_struct，并返回给用户态进程，被mmap映射返回的虚拟地址，逻辑上被消耗了，直到用户进程调用munmap，才回收回来。<font size="4" color="green">malloc向系统获取比较大的内存时，会通过mmap直接映射一块虚拟地址区间。mmap系统调用用处非常多，比如一个进程的所有动态库文件.so的加载，都需要通过mmap系统调用映射指定大小的虚拟地址区间，然后将.so代码动态映射到这些区域，以供进程其他部分代码访问；另外，多进程通讯，也可以使用mmap，这块另开文章详解。</font> <br>
  <font size="4">无论是brk还是mmap返回的都是虚拟地址，在第一次访问这块地址的时候，会触发缺页异常，然后内核为这块虚拟地址申请并映射物理页框，建立页表映射关系，后续对该区间虚拟地址的访问，通过页表获取物理地址，然后就可以在物理内存上读写了。</font></font></font></p>

<p><font size="4"><strong>3、malloc/free 是libc库函数</strong></font> <br>
  <font size="4" color="blue">malloc/free是 libc实现的库函数，主要实现了一套内存管理机制，当其管理的内存不够时，通过brk/mmap等系统调用向内核申请进程的虚拟地址区间，如果其维护的内存能满足malloc调用，则直接返回，free时会将地址块返回空闲链表。</font> <br>
  <font size="4">malloc（size） 的时候，这个函数会多分配一块空间，用于保存size变量，free的时候，直接通过指针前移一定大小，就可以获取malloc时保存的size变量，从而free只需要一个指针作为参数就可以了calloc 库函数相当于 malloc + memset(0) <br>
  <font size="4" color="red">除了libc自带的动态内存管理库malloc, 有时候还可以使用其他的内存管理库替换</font>，比如使用google实现的tcmalloc ,只需要编译进程时链接上 tcmalloc的静态库并包含响应头文件，就可以透明地使用tcmalloc 了，与libc 的malloc相比， tcmalloc 在内存管理上有很多改进，效率和安全性更好。</font></p>

<p><font size="4"><strong>4、new/new[]/delete/delete[]</strong></font> <br>
  <font size="4">new/delete 是c++ 内置的运算符，相当于增强版的malloc/free. c++是兼容c的，一般来说，同样功能的库，c++会在安全性和功能性方面比c库做更多工作。动态内存管理这块也一样。 <br>
  <font size="4" color="green">new的实现会调用malloc，对于基本类型变量，它只是增加了一个cookie结构, 比如需要new的对象大小是 object_size, 则事实上调用 malloc 的参数是 object_size + cookie， 这个cookie 结构存放的信息包括对象大小，对象前后会包含两个用于检测内存溢出的变量，所有new申请的cookie块会链接成双向链表。由于内置了内存溢出检测，所以比malloc更安全。</font> <br>
  <font size="4">对于自定义类型，new会先申请上述的大小空间，然后调用自定义类型的构造函数，对object所在空间进行构造。c++比c强大的一个方面就是c++编译器可以自动做构造和析构，new运算符会自动计算需要的空间大小，然后根据类型自己调用构造函数，如果存在子类型对象，或者存在继承的基类型，new都会自动调用子类型的构造函数和基类型的构造函数完成构造。同样，delete 操作符根据cookie的size知道object的大小，如果是自定义类型，会调用析构函数对object所在空间进行析构，如果有子类型或继承，自动调用子类型和基类型的析构函数，然后将cookie块从双向链表摘除，最后调用 free_dbg 释放。 <br>
  <font size="4">new[] 和delete[]是另外两个操作符，用于数组类型的动态内存获取和释放，实现过程类似new/delete 。</font></font></font></p>

<p><font size="5"><strong>二、智能指针</strong></font> <br>
<font size="4"><strong>1、智能指针背后的设计思想</strong></font> <br>
  <font size="4">我们先来看一个简单的例子：</font></p>

<pre class="prettyprint"><code class=" hljs r">void remodel(std::string &amp; str)
{
    std::string * ps = new std::string(str);
    <span class="hljs-keyword">...</span>
    <span class="hljs-keyword">if</span> (weird_thing())
        throw exception();
    str = *ps; 
    delete ps;
    <span class="hljs-keyword">return</span>;
}</code></pre>

<p>  <font size="4">当出现异常时（weird_thing()返回true），delete将不被执行，因此将导致内存泄露。 <br>
  <font size="4">如何避免这种问题？有人会说，这还不简单，直接在throw exception();之前加上delete ps;不就行了。是的，你本应如此，问题是很多人都会忘记在适当的地方加上delete语句（连上述代码中最后的那句delete语句也会有很多人忘记吧），如果你要对一个庞大的工程进行review，看是否有这种潜在的内存泄露问题，那就是一场灾难！ <br>
  <font size="4">这时我们会想：当remodel这样的函数终止（不管是正常终止，还是由于出现了异常而终止），本地变量都将自动从栈内存中删除—因此指针ps占据的内存将被释放，如果ps指向的内存也被自动释放，那该有多好啊。 <br>
  <font size="4">我们知道析构函数有这个功能。如果ps有一个析构函数，该析构函数将在ps过期时自动释放它指向的内存。但ps的问题在于，它只是一个常规指针，不是有析构凼数的类对象指针。如果它指向的是对象，则可以在对象过期时，让它的析构函数删除指向的内存。 <br>
  <font size="4">这正是智能指针背后的设计思想。我简单的总结下就是：<font size="4" color="red">将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数里编写delete语句删除指针指向的内存空间。</font> <br>
  <font size="4">shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。</font></font></font></font></font></font></p>

<p><font size="4"><strong>2、shared_ptr类</strong></font> <br>
<img src="http://img.blog.csdn.net/20180123200609227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><img src="http://img.blog.csdn.net/20180123200625635?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="4"><strong>（1）make_shared函数</strong> <br>
  <font size="4">最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp">    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);<span class="hljs-comment">//效率比下面的高  </span>
    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; p2(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));<span class="hljs-comment">//不推荐,为了避免智能指针与普通指针的混用,所以最后使用make_shared,这样在内存分配之后立刻与智能指针绑定到一起.</span></code></pre>

<p><font size="4"><strong>（2）shared_ptr的拷贝和赋值</strong></font></p>

<pre class="prettyprint"><code class=" hljs perl">auto p = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>);
auto <span class="hljs-string">q(p)</span>;
auto r = p; <span class="hljs-regexp">//p</span>递增，r递减。</code></pre>

<p>  <font size="4" color="green">每个shared_ptr都有一个关联的计数器，通常称为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增；当我们给shared_ptr赋予一个新值或者shared_ptr被销毁时，引用计数会递减。一旦引用计数变为0，shared_ptr就会自动释放自己所管理的对象。</font></p>

<p><font size="4"><strong>（3）shared_ptr自动销毁所管理的对象</strong> <br>
  <font size="4" color="blue">shared_ptr的析构函数会递减它所指向的对象的引用计数，当引用计数变为0时，shared_ptr就会通过析构函数自动释放自己所管理的对象。当动态对象不再使用时，shared_ptr会自动释放对象，这一特性使得动态内存的使用变得非常容易（尽量使用智能指针管理动态内存）。如果将shared_ptr放于容器中，而后不再需要全部元素，而只是使用其中一部分，要记得用erase删除不再需要的那些元素。</font></font></p>

<p><font size="4"><strong>（4）使用动态内存的原因：</strong> <br>
<font size="4"> <br>
 - 程序不知道自己需要多少对象。 <br>
 - 程序不知道所需对象的准确类型。 <br>
 - 允许多个对象共享相同的状态。</font></font></p>

<p><font size="4"><strong>（5）使用shared_ptr的一个例子：</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-preprocessor">#include &lt;vector&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">class</span> StrBlob
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">typedef</span> <span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>::size_type st;
    StrBlob():data(make_shared&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>&gt;()){}
    StrBlob(initializer_list&lt;<span class="hljs-built_in">string</span>&gt; il):data(make_shared&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>&gt;()){}
    <span class="hljs-keyword">inline</span> st size() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> data-&gt;size(); } 
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> empty() <span class="hljs-keyword">const</span> { <span class="hljs-keyword">return</span> data-&gt;empty(); }
    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> push_back(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;t) { data-&gt;push_back(t); }
    <span class="hljs-keyword">void</span> pop_back();
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; front();
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; back();
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-stl_container"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;</span>&gt; data;
    <span class="hljs-keyword">void</span> check(st i,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;msg) <span class="hljs-keyword">const</span>;
};
<span class="hljs-keyword">void</span> StrBlob::check(st i,<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;msg) <span class="hljs-keyword">const</span>
{
    <span class="hljs-keyword">if</span>(i &gt;= data-&gt;size())
        <span class="hljs-keyword">throw</span> out_of_range(msg);
}
<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; StrBlob::front()
{
    StrBlob::check(<span class="hljs-number">0</span>,<span class="hljs-string">"front on empty StrBlob"</span>);
    <span class="hljs-keyword">return</span> data-&gt;front();
}
<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp; StrBlob::back()
{
    StrBlob::check(<span class="hljs-number">0</span>,<span class="hljs-string">"back on empty StrBlob"</span>);
    <span class="hljs-keyword">return</span> data-&gt;back();
}
<span class="hljs-keyword">void</span> StrBlob::pop_back()
{
    StrBlob::check(<span class="hljs-number">0</span>,<span class="hljs-string">"pop_back on empty StrBlob"</span>);
    <span class="hljs-keyword">return</span> data-&gt;pop_back();    
}
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    StrBlob b1;
    StrBlob b2 = {<span class="hljs-string">"a"</span>,<span class="hljs-string">"an"</span>,<span class="hljs-string">"the"</span>};
    b1 = b2;
    b2.push_back(<span class="hljs-string">"about"</span>);
    <span class="hljs-built_in">cout</span> &lt;&lt; b1.size() &lt;&lt; endl;
    <span class="hljs-built_in">cout</span> &lt;&lt; b2.size() &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4"><strong>2、shared_ptr的实现和循环引用问题</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">class</span> Dele
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T* ptr)
    {
        <span class="hljs-keyword">delete</span> ptr;
        ptr=NULL;
    }
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">class</span> Free
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T* ptr)
    {
        <span class="hljs-built_in">free</span>(ptr);
        ptr=NULL;
    }
};


<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;
<span class="hljs-keyword">class</span> File
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span>()(T* ptr)
    {
        fclose(ptr);
    }
};</code></pre>

<pre class="prettyprint"><code class=" hljs axapta">template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>,<span class="hljs-title">class</span> <span class="hljs-title">Des</span>=<span class="hljs-title">Dele</span>&lt;<span class="hljs-title">T</span>&gt;&gt;
<span class="hljs-title">class</span> <span class="hljs-title">SharedPtr</span>
{</span>
<span class="hljs-keyword">public</span>:
    SharedPtr(T* ptr=NULL)
        :_ptr(ptr)
        ,<span class="hljs-keyword">count</span>(<span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">if</span>(_ptr)
        {
            <span class="hljs-keyword">count</span>=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1</span>);
        }
    }

    SharedPtr(const SharedPtr&amp; sp)
    {
        _ptr=sp._ptr;
        <span class="hljs-keyword">count</span>=sp.<span class="hljs-keyword">count</span>;
        (*<span class="hljs-keyword">count</span>)++;
    }

    SharedPtr&amp; operator=(const SharedPtr&amp; sp)
    {
        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>!=&amp;sp)
        {
            <span class="hljs-keyword">if</span>(_ptr&amp;&amp;!(--*<span class="hljs-keyword">count</span>))
            {
                Destory();
            }
            _ptr=sp._ptr;
            <span class="hljs-keyword">count</span>=sp.<span class="hljs-keyword">count</span>;
            (*<span class="hljs-keyword">count</span>)++;
        }
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    ~SharedPtr()
    {
        <span class="hljs-keyword">if</span>(_ptr&amp;&amp;!(--(*<span class="hljs-keyword">count</span>)))
        {
            Destory();
        }
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">void</span> Destory()
    {
        Des()(_ptr);
        delete <span class="hljs-keyword">count</span>;
    }

<span class="hljs-keyword">private</span>:
    T* _ptr;
    <span class="hljs-keyword">int</span>* <span class="hljs-keyword">count</span>;
};</code></pre>

<p>  <font size="4">这里对于shared_ptr是利用了之前string类用过的引用计数，除了封装一个原生指针外还封装了一个int*的指针，当然标准库当中肯定没这么简单，上面只是简单的进行了模拟大致的方法，仅对于上述的模拟而言，<font size="4" color="red">shared_ptr增加了一个引用计数空间用于保存当前管理这块原生指针指向的空间的对象有多少，而根据这个引用计数来决定在析构某一对象的时候要不要释放空间；而除此之外这里还解决了一个问题，就是对于不同的指针而言，最后进行的处理是不同的，例如文件指针需要进行关闭文件，malloc出来的空间需要的是进行free而不是delete等，上述模拟根据这一问题对于不同的指针设计了对应的删除器来进行解决。</font> <br>
  <font size="4">但是这里还有一个严重的问题，就是关于循环引用的问题。对于什么是循环引用？我们用下面这个测试用例来解释：</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-preprocessor">#include &lt;memory&gt;</span>
<span class="hljs-preprocessor">#include "SharedPtr.h"</span>

<span class="hljs-keyword">struct</span> Node
{
    Node(<span class="hljs-keyword">int</span> va)
        :value(va)

    {
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Node()"</span>&lt;&lt;endl;
    }


    ~Node()
    {
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"~Node()"</span>&lt;&lt;endl;
    }
    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; _pre;
    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; _next;
    <span class="hljs-keyword">int</span> value;
};

<span class="hljs-keyword">void</span> funtest()
{
    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; sp1(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>));
    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; sp2(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>));

    sp1-&gt;_next=sp2;
    sp2-&gt;_pre=sp1;
}
<span class="hljs-keyword">int</span> main()
{
    funtest();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>  <font size="4">这里模拟了双向链表中的两个节点的情况，对于节点中的_pre和_next都用shared_ptr来进行管理，而节点本身也由shared_ptr进行管理，这样的话当funtest()运行结束后，我们会发现并没有调用~Node()，也就是说节点在这里并没有被释放，这里原因在于<font color="blue">有两个shared_ptr的对象管理同一个节点，而其中的一个对象就是另一个节点当中的_pre或是_next，当你对sp2进行释放的时候，由于引用计数为2，所以这里并不能把对应节点给释放掉，而是要等待对方也就是sp1的_next释放时才能将sp2的节点释放掉，反过来对于sp1与sp2同理，也要等待sp2中的_pre释放，所以这里两者都未能释放</font>。因此，在这里标准库就引用了weak_ptr，将上面的_pre和_next的类型换成weak_ptr，由于weak_ptr并不会增加引用计数use的值，所以这里就能够打破shared_ptr所造成的循环引用问题。但是这里要注意一点，就是weak_ptr并不能单独用来管理空间。</font></p>

<p><font size="4"><strong>3、weak_ptr类</strong></font> <br>
  <font size="4">根据上面的测试用例，我们知道sp1，sp2，_pre，_next均是shared_ptr的对象，所以上图中两个引用计数空间中的use均为2，weak均为1，而在出funtest()的作用域之前，会对栈空间上的变量进行销毁释放，也就是说在这里，会对sp1和sp2这两个对象进行释放，调用它们的析构函数，但由于在shared_ptr的析构函数中，只有当use=1，进行减减之后为0，才会释放_ptr所指向的空间，所以在这里sp1和sp2所管理的节点空间是不会被释放的，因此也不会调用~Node()这个析构函数，所以这里就出现了上篇文章末尾所出现的问题，也就是内存泄漏。 <br>
  <font size="4">由于在shared_ptr单独使用的时候会出现循环引用的问题，造成内存泄漏，所以标准库又从boost库当中引入了weak_ptr。对上面的测试用例进行修改：</font></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;  </span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;  

<span class="hljs-preprocessor">#include &lt;memory&gt;  </span>
<span class="hljs-preprocessor">#include "SharedPtr.h"  </span>

<span class="hljs-keyword">struct</span> Node  
{  
    Node(<span class="hljs-keyword">int</span> va)  
        :value(va)  

    {  
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"Node()"</span>&lt;&lt;endl;  
    }  


    ~Node()  
    {  
        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"~Node()"</span>&lt;&lt;endl;  
    }  
    weak_ptr&lt;Node&gt; _pre;  
    weak_ptr&lt;Node&gt; _next;  
    <span class="hljs-keyword">int</span> value;  
};  

<span class="hljs-keyword">void</span> funtest()  
{  
    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; sp1(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">1</span>));  
    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; sp2(<span class="hljs-keyword">new</span> Node(<span class="hljs-number">2</span>));  

    sp1-&gt;_next=sp2;  
    sp2-&gt;_pre=sp1;  
}  
<span class="hljs-keyword">int</span> main()  
{  
    funtest();  
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  
}  </code></pre>

<p>  <font size="4">其实也并没有做太大的修改，只是将其中的_pre和_next的类型换成weak_ptr，当这个测试用例运行到sp2-&gt;_pre=sp1结束后，节点之间的相互关系与上图基本无差别，但是这里有一点发生了变化，就是由于每个节点仅有一个shared_ptr的对象管理，这里两块引用计数空间中的use均为1，而由于多了weak_ptr的对象_pre或_next指向，这里weak的值就变成了2，因此根据前面的讨论，两个节点空间就成功释放了</font></p>

<p><img src="http://img.blog.csdn.net/20180123203301927?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
  <font size="4">weak_ptr是一种不控制所指向对象生存周期的智能指针，他指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr，不会改变shared_ptr的引用计数。</font></p>

<pre class="prettyprint"><code class=" hljs cpp">    <span class="hljs-keyword">auto</span> p = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">10</span>); <span class="hljs-comment">//使用shared_ptr来初始化。</span>
    weak_ptr&lt;<span class="hljs-keyword">int</span>&gt;wp(p);  

    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-keyword">int</span>&gt; np = wp.lock())<span class="hljs-comment">//访问对象必须调用lock()</span>
    {  
      <span class="hljs-comment">//使用np访问共享对象  </span>
    }  </code></pre>

<p><font size="4"><strong>4、unique_ptr类</strong></font> <br>
  <font size="4" color="green">unique_ptr 独占智能指针，某个时刻只能有一个unique_ptr 指向一个给定对象。当unique_ptr 被销毁时，它所指向的对象也被销毁。unique_ptr 不支持拷贝赋值等操作，除非这个unique_ptr将要被销毁,这种情况，编译器执行一种特殊的”拷贝”</font></p>

<pre class="prettyprint"><code class=" hljs cs">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>));<span class="hljs-comment">//必须直接初始化。</span>
unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; p2(p1);<span class="hljs-comment">//error</span>
unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; p3 = p1;/error

unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; clone(<span class="hljs-keyword">int</span> p)
{
  unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ret(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(p));
  <span class="hljs-keyword">return</span> ret; <span class="hljs-comment">//ok</span>
}</code></pre>

<p><img src="http://img.blog.csdn.net/20180123204443403?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br>
  <font size="4">虽然不能拷贝或者赋值unique_ptr，但是通过调用release或者reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique_ptr。调用release会切断unique_ptr和它原来管理对象间的联系。release返回的指针通常用来初始化另一个智能指针或者给另一个智能指针赋值。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; clone(<span class="hljs-keyword">int</span> p);
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    unique_ptr&lt;<span class="hljs-keyword">double</span>&gt; p;<span class="hljs-comment">//</span>
    unique_ptr&lt;<span class="hljs-built_in">string</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">"ABC"</span>));<span class="hljs-comment">//使用new返回的指针初始化。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;

    unique_ptr&lt;<span class="hljs-built_in">string</span>&gt; p2(p1.release());<span class="hljs-comment">//放弃对p1的控制权，返回指针并置空，然后初始化另一个指针。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;

    unique_ptr&lt;<span class="hljs-built_in">string</span>&gt; p3(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-string">"abc"</span>));
    p2.reset(p3.release());<span class="hljs-comment">//释放p2的对象，并将p3的所有权转移给p2。</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;

    <span class="hljs-built_in">cout</span> &lt;&lt; *clone(<span class="hljs-number">10</span>) &lt;&lt; endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; clone(<span class="hljs-keyword">int</span> p)
{
    <span class="hljs-keyword">return</span> unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(p));<span class="hljs-comment">//unique_ptr不能拷贝或者赋值，但是可以返回一个unique_ptr。</span>
}</code></pre>

<p><font size="4"><strong>5、unique_ptr类为何优于auto_ptr类</strong></font> <br>
  <font size="4">可能大家认为前面的例子已经说明了unique_ptr为何优于auto_ptr，也就是安全问题，下面再叙述的清晰一点。请看下面的语句:</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p1(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> (<span class="hljs-string">"auto"</span>) ； <span class="hljs-comment">//#1</span>
<span class="hljs-built_in">auto_ptr</span>&lt;<span class="hljs-built_in">string</span>&gt; p2;                       <span class="hljs-comment">//#2</span>
p2 = p1;</code></pre>

<p>  <font size="4">在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺。前面说过，这是好事，可防止p1和p2的析构函数试图刪同—个对象；但如果程序随后试图使用p1，这将是件坏事，因为p1不再指向有效的数据。下面来看使用unique_ptr的情况：</font></p>

<pre class="prettyprint"><code class=" hljs cs">unique_ptr&lt;<span class="hljs-keyword">string</span>&gt; p3 (<span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span> (<span class="hljs-string">"auto"</span>);   <span class="hljs-comment">//#4</span>
unique_ptr&lt;<span class="hljs-keyword">string</span>&gt; p4；                       <span class="hljs-comment">//#5</span>
p4 = p3;    </code></pre>

<p>  <font size="4">编译器认为语句#6非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。但unique_ptr还有更聪明的地方。有时候，会将一个智能指针赋给另一个并不会留下危险的悬挂指针。假设有如下函数定义：</font></p>

<pre class="prettyprint"><code class=" hljs cs">unique_ptr&lt;<span class="hljs-keyword">string</span>&gt; demo(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * s)
{
    unique_ptr&lt;<span class="hljs-keyword">string</span>&gt; temp (<span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span> (s))； 
    <span class="hljs-keyword">return</span> temp；
}

unique_ptr&lt;<span class="hljs-keyword">string</span>&gt; ps;
ps = demo(<span class="hljs-string">'Uniquely special")；</span></code></pre>

<p>  <font size="4">demo()返回一个临时unique_ptr，然后ps接管了原本归返回的unique_ptr所有的对象，而返回时临时的 unique_ptr 被销毁，也就是说没有机会使用 unique_ptr 来访问无效的数据，换句话来说，这种赋值是不会出现任何问题的，即没有理由禁止这种赋值。实际上，编译器确实允许这种赋值，这正是unique_ptr更聪明的地方。 <br>
  <font size="4" color="red">总之，当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做，比如：</font></font></p>

<pre class="prettyprint"><code class=" hljs cs">unique_ptr&lt;<span class="hljs-keyword">string</span>&gt; pu1(<span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span> (<span class="hljs-string">"hello world"</span>));
unique_ptr&lt;<span class="hljs-keyword">string</span>&gt; pu2;
pu2 = pu1;                                      <span class="hljs-comment">// #1 not allowed</span>
unique_ptr&lt;<span class="hljs-keyword">string</span>&gt; pu3;
pu3 = unique_ptr&lt;<span class="hljs-keyword">string</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">string</span> (<span class="hljs-string">"You"</span>));   <span class="hljs-comment">// #2 allowed</span></code></pre>

<p>  <font size="4">其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。</font></p>

<p><font size="4"><strong>6、使用智能指针需要注意的问题：</strong></font> <br>
<img src="http://img.blog.csdn.net/20180123205742997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><font size="4"><strong>7、如何选择智能指针？</strong></font> <br>
  <font size="4">在掌握了这几种智能指针后，应使用哪种智能指针呢？<font size="4"> <br>
 - <font color="green">如果程序要使用多个指向同一个对象的指针，应选择shared_ptr</font>。这样的情况包括：有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；两个对象包含都指向第三个对象的指针；STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。 <br>
 - <font color="green">如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。</font>如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr存储到STL容器在那个，只要不调用将一个unique_ptr复制或赋给另一个算法（如sort()）。</font></font></p>

<p><font size="5"><strong>三、动态数组和allocator类</strong></font> <br>
<font size="4"><strong>1、动态数组</strong></font> <br>
<font size="4"><strong>（1）使用new和delete管理动态内存三个常见的问题：</strong> <br>
<font color="blue">a、忘记释放（delete）内存。</font> <br>
  <font size="4">忘记释放动态内存会导致人们常说的 “内存泄漏（memory leak)” 问题 ，因为这种内存永远不可能归还系统，除非程序退出。比如在某个作用域的代码如下：向系统申请了一块内存，离开作用域之前没有接管用户这块内存，也没有释放这块内存。</font></font></p>

<pre class="prettyprint"><code class=" hljs cs">{  
    <span class="hljs-comment">//....  </span>
    <span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">0</span>);  
    <span class="hljs-comment">//....   </span>
}  </code></pre>

<p>  <font size="4">有两个方法可以避免以上问题： <br>
1） 在p离开它new所在作用域之前，释放这块内存。如：delete p</font></p>

<pre class="prettyprint"><code class=" hljs cpp">{  
     <span class="hljs-comment">//....  </span>
     <span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">0</span>);  
     <span class="hljs-comment">//....  </span>
     <span class="hljs-keyword">delete</span> p;      <span class="hljs-comment">//释放p的向系统申请的内存  </span>
     p = <span class="hljs-keyword">nullptr</span>;   <span class="hljs-comment">//避免出现野指针。 </span>
}  </code></pre>

<p><font size="4">2） 接管p的向系统申请的内存。 比如通过赋值，函数返回值等。</font></p>

<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">int</span> *pAnother;
{
    <span class="hljs-comment">//....</span>
    <span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">0</span>);
    <span class="hljs-comment">//....</span>
    pAnother = p; <span class="hljs-comment">//pAnother接管p所指向的内存。</span>
}
<span class="hljs-comment">//pAnother  do something</span>
<span class="hljs-keyword">delete</span> pAnother;   <span class="hljs-comment">//通关pAnother,将p所申请的内存归还系统。</span></code></pre>

<p><font size="4" color="blue">b、使用已经释放内存的对象。</font> <br>
  <font size="4">这种行为是未定义的，通过在释放内存后将指针设置位空指针（nullptr），有时可以避免这个问题（这是基于一个前提条件，使用动态分配内存对象前，需要检查该对象是否指向空（nullptr））。假如不对已经释放内存的对象赋值空指针，他的值是未定义的，就好比其他变量，使用未初始化的对象，其行为大都是未定义。 <br>
  <font size="4">nullptr(C++11刚引入)是一种特殊类型的字面值，它可以被转换成任何其他指针类型。过去程序使用NULL的预处理变量来给指针赋值。 他们的值都是0。 <br>
  <font size="4">使用已经释放内存的对象，如下代码：</font></font></font></p>

<pre class="prettyprint"><code class=" hljs ruby">{
    int *p = new int(<span class="hljs-number">0</span>);
    delete p;
    <span class="hljs-symbol">std:</span><span class="hljs-symbol">:cout&lt;&lt;*p&lt;&lt;std</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:endl</span>; <span class="hljs-regexp">//</span>*p的值是未定义
}</code></pre>

<p>  <font size="4">避免以上问题：（对已经释放内存对象赋于一个空指针,使用前进行判断是否为空指针）</font></p>

<pre class="prettyprint"><code class=" hljs cpp">{  
    <span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">0</span>);  
    <span class="hljs-keyword">delete</span> p; 
    p = <span class="hljs-keyword">nullptr</span>;  
    <span class="hljs-keyword">if</span>(p!=<span class="hljs-keyword">nullptr</span>) 
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;*p&lt;&lt;<span class="hljs-built_in">std</span>::endl;   
}  </code></pre>

<p>  <font size="4">同样当我们定义一个指针时，如果没有立即为它分配内存，也需要将指针设置为空指针，防止不恰当使用。这里也涉及一个问题，new出来的内存也应该初始化。</font></p>

<p><font size="4" color="blue">c、同一块内存释放两次。</font> <br>
  <font size="4">当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个对象进行了delete操作，对象的内存就归还给系统，如果我们随后有delete第二个指针，堆空间可能被破坏。产生问题代码：</font></p>

<pre class="prettyprint"><code class=" hljs d"><span class="hljs-keyword">int</span> *pAnother;  
{  
    <span class="hljs-comment">//....  </span>
    <span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">0</span>);  
    pAnother =p;  
    <span class="hljs-comment">//p do something....  </span>
    <span class="hljs-keyword">delete</span> p;  
}  
<span class="hljs-keyword">delete</span> pAnother;  <span class="hljs-comment">//未定义行为 </span></code></pre>

<p>  <font size="4">避免这个问题：在delete p 之后， 将p置为一个空指针。 <br>
  <font size="4">其次明白一个道理：delete  p, p 必须指向一个空指针或者动态分配的内存，否则其行为未定义。这也很好就解释了为什么delete一个对象之后需要将该对象置为空指针，一是为了避免再次访问它出现未定义行为，二是为了避免再次delete它出现未定义行为。 <br>
  <font size="4" color="red">【Note】：<font size="4"> <br>
 1）定义一个指针需要初始化为空指针，（除非在定义的时候给它申请一块内存）。 <br>
 2）访问一个指针需要先判断该指针是否为空指针。  <br>
 3）释放一个指针之后，应该将它置为空指针，防止出现野指针。</font></font></font></font></p>

<p><font size="4"><strong>（2）动态数组的一个例子</strong></font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-keyword">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">delete</span> [] p;

    unique_ptr&lt;<span class="hljs-keyword">int</span> []&gt; up(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]);<span class="hljs-comment">//使用unique_ptr管理动态数组。</span>
    up.release();

    <span class="hljs-comment">//动态申请高维数组。</span>
    <span class="hljs-keyword">int</span> row = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> col = <span class="hljs-number">5</span>;
    <span class="hljs-comment">//先申请int* 型数组的的空间，该空间存放的是int*型的指针变量，然后把这块指针变量的空间首地址赋给array。</span>
    <span class="hljs-keyword">int</span>** <span class="hljs-built_in">array</span>=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>* [row];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;row ; ++i)
    {
        <span class="hljs-built_in">array</span>[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[col];<span class="hljs-comment">//array[i]仍然是指针。</span>
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;row ; ++i)
    {
        <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">array</span>[i];
    }
    <span class="hljs-keyword">delete</span>[] <span class="hljs-built_in">array</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p><font size="4"><strong>2、allocator类</strong></font></p>

<p><img src="http://img.blog.csdn.net/20180123212002761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p><img src="http://img.blog.csdn.net/20180123212016960?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p>

<p>  <font size="4">allocator类帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</font></p>

<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;memory&gt;</span>
<span class="hljs-preprocessor">#include &lt;string&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])
{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;
    allocator&lt;<span class="hljs-built_in">string</span>&gt; alloc;
    <span class="hljs-keyword">auto</span> p = alloc.allocate(n);<span class="hljs-comment">//只分配内存。</span>
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">auto</span> q = p;
    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span> &gt;&gt; s &amp;&amp; q != p+n)
    {
        alloc.construct(q++,s);<span class="hljs-comment">//必须调用construct创建对象并赋值。</span>
    }
    <span class="hljs-keyword">while</span>(q != p)
    {
        alloc.destroy(--q);<span class="hljs-comment">//逐个销毁对象，destory接受一个指针。</span>
    }
    alloc.deallocate(p,n);<span class="hljs-comment">//分配多少内存，释放多少。</span>
    system(<span class="hljs-string">"pause"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>

<p>参考：<a href="https://www.cnblogs.com/jiayy/p/3420122.html">https://www.cnblogs.com/jiayy/p/3420122.html</a> <br>
<a href="http://blog.csdn.net/chenkaixin_1024/article/details/69390586">http://blog.csdn.net/chenkaixin_1024/article/details/69390586</a> <br>
<a href="http://blog.csdn.net/lanxuezaipiao/article/details/41603883">http://blog.csdn.net/lanxuezaipiao/article/details/41603883</a> <br>
<a href="http://blog.csdn.net/qq_33850438/article/details/52994314">http://blog.csdn.net/qq_33850438/article/details/52994314</a> <br>
<a href="http://makaidong.com/libin1105/1/1903_12244995.html">http://makaidong.com/libin1105/1/1903_12244995.html</a></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/01/23 21:26:34 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79144866">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79144866                    </div>
                    <div>
                        阅读：69                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[转]浅谈Session与Cookie的区别与联系]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79110902</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79110902</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/01/20 16:37:51</pubDate>
                <description>
                    <![CDATA[
                    <h2 id="一session的概念">一、Session的概念</h2>

<p>  <font size="4"><font color="red">Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。</font></font></p>

<p>  <font size="4">一般情况下，服务器会在一定时间内（默认30分钟）保存这个 Session，过了时间限制，就会销毁这个Session。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个 Session中。当然，也有使用数据库将这个Session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据 库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。</font></p>



<h2 id="二session的客户端实现形式即session-id的保存方法">二、Session的客户端实现形式（即Session ID的保存方法）</h2>

<p>  <font size="4">一般浏览器提供了几种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现： <br>
<font size="4"> <br>
 1. 使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。 <br>
 2. 使用URL附加信息的方式，也就是像我们经常看到JSP网站会有aaa.jsp?JSESSIONID=*一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。 <br>
 3. 第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。</font></font></p>

<p>  <font size="4">cookie与session的区别： <br>
  <font color="green" size="4">cookie数据保存在客户端，session数据保存在服务器端。</font> <br>
  <font size="4">简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。 <br>
  <font size="4">如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服 务器会解释为 cookie变量。所以只要不关闭浏览器，那么 cookie变量便一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器，曾经在学校的vbb论坛上面做过试验，copy别人的 cookie登录，冒用了别人的名义发帖子，完全没有问题。 <br>
  <font size="4">Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。 <br>
  <font size="4">服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。 <br>
  <font size="4">可以试一下，即使不写Cookie，在使用request.getCookies();取出的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值。</font></font></font></font></font></font></p>

<h2 id="三session与cookie区别和联系">三：Session与Cookie区别和联系：</h2>

<p>  <font color="blue" size="4">Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。</font></p>

<p>  <font size="4">Cookies与Session的应用场景： <br>
  <font size="4">Cookies的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以Cookies到底该不该用，到底该怎样用，就有了一个需要给定的底线。</font></font></p>

<p>  <font size="4">先来看看，网站的敏感数据有哪些。</font></p>

<p>  <font size="4">登陆验证信息。一般采用Session(“Logon”)＝true or false的形式。 <br>
用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里 <br>
需要在页面间传递的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更新到数据库。</font></p>

<p>  <font size="4">当然还会有很多，这里列举一些比较典型的： <br>
  <font size="4">假如，一个人孤僻到不想碰Session，因为他认为，如果用户万一不小心关闭了浏览器，那么之前保存的数据就全部丢失了。所以，他出于好意，决定把这些用Session的地方，都改成用Cookies来存储，这完全是可行的，且基本操作和用Session一模一样。那么，下面就针对以上的3个典型例子，做一个分析 <br>
很显然，只要某个有意非法入侵者，知道该网站验证登陆信息的Session变量是什么，那么他就可以事先编辑好该Cookies，放入到Cookies目录中，这样就可以顺利通过验证了。这是不是很可怕？ <br>
Cookies完全是可见的，即使程序员设定了Cookies的生存周期（比如只在用户会话有效期内有效），它也是不安全的。假设，用户忘了关浏览器 或者一个恶意者硬性把用户给打晕，那用户的损失将是巨大的。 <br>
这点如上点一样，很容易被它人窃取重要的私人信息。但，其还有一个问题所在是，可能这些数据信息量太大，而使得Cookies的文件大小剧增。这可不是用户希望所看到的。</font></font></p>

<p>  <font size="4">显然，Cookies并不是那么一块好啃的小甜饼。但，Cookies的存在，当然有其原因。它给予程序员更多发挥编程才能的空间。所以，使用Cookies改有个底线。这个底线一般来说，遵循以下原则。 <br>
不要保存私人信息。 <br>
任何重要数据，最好通过加密形式来保存数据（最简单的可以用URLEncode，当然也可以用完善的可逆加密方式，遗憾的是，最好不要用md5来加密）。 <br>
是否保存登陆信息，需有用户自行选择。 <br>
长于10K的数据，不要用到Cookies。 <br>
也不要用Cookies来玩点让客户惊喜的小游戏。</font></p>

<h2 id="四cookie最典型的应用是">四、cookie最典型的应用是：</h2>

<p>  <font color="red" size="4"> <br>
（一）：判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。 <br>
  <font size="4"> <br>
（二）：另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。</font></font></p>

<p>转自：<a href="http://blog.csdn.net/duan1078774504/article/details/51912868">http://blog.csdn.net/duan1078774504/article/details/51912868</a></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/01/20 16:37:51 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79110902">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79110902                    </div>
                    <div>
                        阅读：56                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]类]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/79110389</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/79110389</guid>
                <author>daaikuaichuan</author>
                <pubDate>2018/01/19 20:13:41</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4"> 类的基本思想是<font color="green">数据抽象和封装</font>，数据抽象是一种依赖于<font color="red">接口和实现分离</font>的编程技术。</font></p>

<p><font size="5"><strong>一、定义抽象数据类型:</strong></font> <br>
  <font size="4"> C++程序员们无须可以区分应用程序的用户以及类的用户。 <br>
<font color="red" size="4"> <strong>1. 成员函数、非成员函数、const成员函数、this对象：</strong></font> <br>
  （1）成员函数： <br>
<code>inline int Size() const{ return m_len; }</code> <br>
  （2）非成员函数： <br>
<code>istream &amp;Read(istream &amp;is, Sales_data &amp;item){ *** }</code> <br>
<font color="green" size="4">【Note】： <br>
   如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</font> <br>
  （3）const成员函数：在成员函数后加上常量符号，表示不能改变调用它的对象的内容。 <br>
<font color="green" size="4">【Note】： <br>
  常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。</font> <br>
  （4）this对象：成员函数通过一个名为this的额外的隐式参数来访问调用它的对象；引用this的目的总是指向“这个”对象，所以是一个常量指针；返回this对象的函数（更新对象的整体数据）：<code>return *this</code></font></p>

<p><font color="red" size="4"><strong>2. 构造函数、拷贝、赋值和析构：</strong></font> <br>
  <font size="4"> （1）构造函数：构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</font></p>



<pre class="prettyprint"><code class=" hljs cs">MyString() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">//合成默认构造函数【C++11】。</span>
MyString(<span class="hljs-keyword">const</span> MyString &amp;s);<span class="hljs-comment">//构造函数。</span>
SmallInt(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>):val(i)<span class="hljs-comment">//构造函数初始化列表。</span></code></pre>

<p><font color="green" size="4">【Note】： <br>
1）构造函数没有返回类型，不能被声明为const。 <br>
2）当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数（合成默认构造函数，无任何实参）；这种构造函数可能会执行错误的操作，所以不是安全的；有时候编译器不能为某些类合成默认的构造函数。</font></p>

<p>  <font size="4"> （2）拷贝构造函数、赋值函数、析构函数：</font></p>



<pre class="prettyprint"><code class=" hljs cs">MyString(<span class="hljs-keyword">const</span> MyString &amp;s);<span class="hljs-comment">//拷贝。</span>
~MyString();<span class="hljs-comment">//析构。</span>
MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> MyString &amp;s);<span class="hljs-comment">//赋值。</span></code></pre>

<p>  <font size="4">拷贝：初始化变量、按值传递、返回一个对象；赋值：适用赋值操作符；析构：当对象不再存在时执行销毁的操作。</font></p>

<p><font size="5"><strong>二、访问控制与封装:</strong></font> <br>
   <font size="4">public：成员在整个程序内可被访问。 <br>
  <font size="4">private：封装了类的实现细节，通过成员函数访问。 <br>
一般先写public公有成员函数再写private私有成员，便于阅读程序。 <br>
<font color="green" size="4">【Note】： <br>
1）适用class（成员默认是private）和struct（成员默认是public）定义类唯一的区别就是默认的访问权限。</font></font></font></p>

<p><font color="blue" size="4"> <strong>1. 友元：</strong></font> <br>
  <font size="4">类可以<font color="red" size="4">允许其他类或者函数访问它的非公有成员</font>，方法是令其他类或者函数成为它的友元，使用<font color="red" size="4">friend</font>关键字。 <br>
<font color="green" size="4">【Note】： <br>
1）友元函数声明只能出现在类定义的内部。 <br>
2）一般来说，最好在类定义开始或者结束前集中声明友元。</font></font></p>

<p><font color="blue" size="4"> <strong>2. 封装的益处：</strong></font> <br>
<font size="4">1）确保用户代码不会无意间破坏封装对象的状态。 <br>
<font size="4">2）被封装的类的具体实现细节可以随时改变，而无需调整用户级别的的代码。</font></font></p>

<p><font size="5"><strong>三、类的其他特性:</strong></font> <br>
<font size="4"> <strong>1. 类成员再探：</strong></font> <br>
  <font size="4">可变数据成员：mutable<font color="red" size="4">【C++11】</font>。一个可变数据成员永远不会是const，可以改变const成员函数中成员的值。</font></p>

<p><font size="4"> <strong>2. 返回*this的成员函数：</strong></font> <br>
  <font size="4">将this对象作为左值返回。<font color="green" size="4">一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。</font> <br>
  <font size="4">基于const的重载：通过区分成员函数是否是const的，我们可以对其进行重载。<font color="red">因为非常量版本的函数对于常量对象不可用，所以只能在一个常量对象上调用const成员函数。</font></font></font></p>

<p><font size="4"> <strong>3. 类类型：</strong></font> <br>
   <font size="4">每个类定义了唯一的类型。 <br>
  <font size="4">前向声明：当一个类要使用其他类时，需在改类前定义前向声明。</font></font></p>

<p><font size="4"> <strong>4. 友元再探：</strong></font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">class</span> A
{
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> B;<span class="hljs-comment">//友元类</span>
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> B::clear();<span class="hljs-comment">//令成员函数作为友元。</span>
};</code></pre>

<p><font color="green" size="4">【Note】： <br>
1）如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。 <br>
2）当把一个成员函数声明为友元时，我们必须明确指出该成员函数属于哪个类。</font></p>

<p><font size="5"><strong>四、类的作用域:</strong></font> <br>
  <font size="4">在类的作用域外，普通的数据和函数成员只能由对象、引用和指针使用成员访问运算符（::）；在类的外部，成员的名字被隐藏起来了。 <br>
<font color="green" size="4">【Note】： <br>
1）编译器处理完类中的全部声明后才会处理成员函数的定义。 <br>
2）类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。 <br>
3）尽管类的成员被隐藏了，但我们仍然可以通过加上类名或者使用this强制访问成员。</font></font></p>

<p><font size="5"><strong>五、构造函数再探:</strong></font> <br>
<font size="4"> <strong>1. 构造函数初始化列表：</strong></font> <br>
  <font size="4">建议使用构造函数初始化列表，这关系到底层效率，另外更重要的是有些成员必须初始化。 <br>
  <font color="blue" size="4">需要注意的是：构造函数初始化列表只说明用于初始化成员的值，而不限定具体执行顺序，即成员的初始化顺序与它们在类定义中的出现顺序一致。</font>所以最好令构造函数初始值的顺序与成员声明的顺序保持一致。 <br>
<font color="green" size="4">【Note】： <br>
1）如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，则必须通过构造函数初始化列表为这些成员提供初值。 <br>
2）如果构造函数为所有参数都提供了默认实参，那实际上也定义了默认构造函数。</font></font></p>

<p><font size="4"> <strong>2. 默认构造函数的作用：</strong></font> <br>
  <font size="4">当对象被默认初始化或者值初始化时自动执行默认构造函数。<font color="red">类必须包含一个默认构造函数以便在这些情况下使用</font>。实际上，即使定义了其他构造函数，最好也提供一个默认构造函数。</font></p>

<p><font size="4"> <strong>3. 隐式的类类型转换：</strong></font> <br>
  <font color="blue" size="4">转换构造函数：构造函数只接受一个实参，则它实际上定义了为此类类型的隐式转换机制。</font> <br>
  <font size="4">抑制构造函数定义的隐式转换：将构造函数声明为<font color="red" size="4">explicit</font>。</font></p>



<pre class="prettyprint"><code class=" hljs cpp"><span class="hljs-keyword">explicit</span> A(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span> &amp;s):a(s) {};
A a(<span class="hljs-string">"abc"</span>);<span class="hljs-comment">//直接初始化。</span>
a.fun(<span class="hljs-keyword">static_cast</span>&lt;A&gt;(<span class="hljs-built_in">cin</span>));<span class="hljs-comment">//强制执行显式转换。</span></code></pre>

<p><font color="green" size="4">【Note】： <br>
1）关键字explicit只对一个实参的构造函数有效，只能在类内定义。 <br>
2）当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用，而不能使用赋值初始化。</font></p>

<p><font size="4"> <strong>4. 聚合类：</strong></font> <br>
  <font size="4">聚合类使得用户可以直接访问其成员，需要满足的条件如下：<font size="4"> <br>
 - 所有成员都是public； <br>
 - 没有定义任何构造函数； <br>
 - 没有类内初始值； <br>
 - 没有基类，也没有虚函数。</font></font></p>



<pre class="prettyprint"><code class=" hljs ocaml"><span class="hljs-keyword">struct</span>
{
    <span class="hljs-built_in">int</span> <span class="hljs-keyword">val</span>;
    <span class="hljs-built_in">string</span> s;
}</code></pre>

<p><font size="4"> <strong>5. 字面值常量类：</strong></font> <br>
  <font size="4"> <br>
 - 类的成员都必须是字面值类型； <br>
 - 类必须至少包含一个constexpr构造函数。</font></p>

<p><font size="5"><strong>六、类的静态成员:</strong></font> <br>
  <font size="4">有时候类需要它的一些成员与类本身直接相关，而不是与类的某个对象保持关联。通过在成员声明之前加上<font color="red" size="4">static</font>关键字。 <br>
<font color="green" size="4">【Note】： <br>
1）static成员只属于类，可以被所有对象共享。不能被声明为const，也不能在static函数体内使用this指针。 <br>
2）静态成员在类内使用static声明，在类外定义（不适用static），如果想在类内初始化，必须使用常量表达式（constexpr）。使用作用域运算符或者静态成员函数访问。 <br>
3）静态成员的类型可以是不完全类型。 <br>
4）与普通成员的一个区别是，静态成员可以作为默认实参。</font></font></p>                    <div>
                        作者：daaikuaichuan 发表于 2018/01/19 20:13:41 <a href="http://blog.csdn.net/daaikuaichuan/article/details/79110389">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/79110389                    </div>
                    <div>
                        阅读：58                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[转]VS2015调试程序]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/78690255</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/78690255</guid>
                <author>daaikuaichuan</author>
                <pubDate>2017/12/01 19:17:36</pubDate>
                <description>
                    <![CDATA[
                    <p>  <font size="4">在vs中调试程序的，有时候需要设置断点看某个变量的内容，如果变量是一个指针、数组或结构体，则可以通过查看该变量所指向的内存来看变量的内容。 <br>
<font size="4"><strong>（1）设置断点后，在vs2015中打开调试窗口</strong></font> <br>
  <font size="4">在vs2015调试界面中，点击菜单【调试】-&gt;【窗口】-&gt;【内存】-&gt;【内存1】/【内存2】/【内存3】/【内存4】即可打开内存窗口。</font></font></p>

<p><font size="4"><strong>2、找到要查看的变量的内存地址</strong></font> <br>
  <font size="4">在VS调试界面中，右键点击要查看内存的变量，在弹出菜单中点击【添加监视】，该变量将被添加到监视窗口中，在监视窗口中该变量对应的【值】列就是该变量对应的内存的地址。</font></p>

<p><font size="4"><strong>3、将变量地址输入到内存窗口中</strong></font> <br>
  <font size="4">在内存窗口中，输入要监视的变量的地址（如0x001926E6），回车即可看到该内存块的内容了。 <br>
  <font size="4">也可以尝试输入&amp;+变量名。</font></font></p>

<p><font size="4"><strong>4、设置内存存储的内容的显示方式</strong></font> <br>
  <font size="4">在内存界面中，默认显示的是16进制的单字节整数，可以通过在显示区点击右键，在弹出菜单中选择内存内容的显示方式。如作为双字节整数显示、4字节整数显示、是否显示符号位等。</font></p>

<p>转自：<a href="http://www.sowsoy.com/topics-516.html" target="_blank">http://www.sowsoy.com/topics-516.html</a></p>                    <div>
                        作者：daaikuaichuan 发表于 2017/12/01 19:17:36 <a href="http://blog.csdn.net/daaikuaichuan/article/details/78690255">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/78690255                    </div>
                    <div>
                        阅读：150                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[转]详解大端模式和小端模式]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/78690185</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/78690185</guid>
                <author>daaikuaichuan</author>
                <pubDate>2017/12/01 19:07:21</pubDate>
                <description>
                    <![CDATA[
                    <p><strong><font size="5">一、什么是大端和小端<font></font></font></strong> <br>
  <font size="4">Big-Endian和Little-Endian的定义如下： <br>
1) Little-Endian就是<font color="#0099ff">低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</font> <br>
2) Big-Endian就是<font color="red">高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</font> <br>
  <font size="4">举一个例子，比如数字0x12 34 56 78在内存中的表示形式为： <br>
1)<strong>大端模式</strong>： <br>
低地址 —————–&gt; 高地址 <br>
0x12  |  0x34  |  0x56  |  0x78 <br>
2)<strong>小端模式</strong>： <br>
低地址 ——————&gt; 高地址 <br>
0x78  |  0x56  |  0x34  |  0x12 <br>
  可见，大端模式和字符串的存储模式类似。 <br>
3)<strong>下面是两个具体例子</strong>： <br>
  16bit宽的数0x1234在Little-endian模式（以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</font></font></p>

<table>
<thead>
<tr>
  <th>内存地址</th>
  <th>小端模式存放内容</th>
  <th>大端模式存放内容</th>
</tr>
</thead>
<tbody><tr>
  <td>0x4000</td>
  <td>0x34</td>
  <td>0x12</td>
</tr>
<tr>
  <td>0x4001</td>
  <td>0x12</td>
  <td>0x34</td>
</tr>
</tbody></table>


<p>  <font size="4">32bit宽的数0x12345678在Little-endian模式以及Big-endian模式）CPU内存中的存放方式（假设从地址0x4000开始存放）为：</font></p>

<table>
<thead>
<tr>
  <th>内存地址</th>
  <th>小端模式存放内容</th>
  <th>大端模式存放内容</th>
</tr>
</thead>
<tbody><tr>
  <td>0x4000</td>
  <td>0x78</td>
  <td>0x12</td>
</tr>
<tr>
  <td>0x4001</td>
  <td>0x56</td>
  <td>0x34</td>
</tr>
<tr>
  <td>0x4002</td>
  <td>0x34</td>
  <td>0x56</td>
</tr>
<tr>
  <td>0x4003</td>
  <td>0x12</td>
  <td>0x78</td>
</tr>
</tbody></table>


<p>4)<strong><font size="4">大端小端没有谁优谁劣，各自优势便是对方劣势</font></strong>： <br>
  <font size="4">小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。 <br>
  <font size="4">大端模式 ：符号位的判定固定为第一个字节，容易判断正负。</font></font></p>

<p><strong><font size="5">二、数组在大端小端情况下的存储<font></font></font></strong> <br>
  <font size="4">以unsigned int value = 0x12345678为例，分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value： <br>
  <font size="4">Big-Endian: 低地址存放高位，如下： <br>
高地址 <br>
        ————— <br>
        buf[3] (0x78) – 低位 <br>
        buf[2] (0x56) <br>
        buf[1] (0x34) <br>
        buf[0] (0x12) – 高位 <br>
        ————— <br>
低地址 <br>
  <font size="4">Little-Endian: 低地址存放低位，如下： <br>
高地址 <br>
        ————— <br>
        buf[3] (0x12) – 高位 <br>
        buf[2] (0x34) <br>
        buf[1] (0x56) <br>
        buf[0] (0x78) – 低位 <br>
        ————– <br>
低地址</font></font></font></p>

<p><strong><font size="5">三、为什么会有大小端模式之分呢？<font></font></font></strong> <br>
  <font size="4">这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。</font></p>

<p><strong><font size="5">四、判断大端模式和小端模式<font></font></font></strong></p>

<p><strong><font size="5">方法一：</font></strong></p>

<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">bool</span> IsBigEndian()
{
    <span class="hljs-keyword">int</span> a =<span class="hljs-number">1</span> ; 
    <span class="hljs-keyword">if</span>(((<span class="hljs-keyword">char</span>*)&amp;a)[<span class="hljs-number">3</span>] ==<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span> ;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span> ;
}</code></pre>

<p>  <font size="4">由于a是int，所以占四个字节，其值是00000001，存储方式如下。所以a[3]是0，不是大端序。一个更标准的写法是将a[3]替换为a[sizeof(int) - 1]。 <br>
<img src="http://img.blog.csdn.net/20171201185951795?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFhaWt1YWljaHVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></font></p>

<p><strong><font size="5"> 方法二：</font></strong> <br>
  <font size="4">使用union： <br>
<font size="4"> 1.  联合体union的存放顺序是所有成员都从<font color="green">低地址开始存放 。</font>  <br>
 2. 一个联合变量的长度等于<font color="green">各成员中最长的长度。</font> <br>
 3. 应该说明的是，这里所谓的共享不是指把多个成员同时装入一个联合变量内，  而是指该联合变量可被赋予任一成员值，但每次只能赋一种值，赋入新值则冲去旧值。  </font></font></p>



<pre class="prettyprint"><code class=" hljs d"><span class="hljs-built_in">bool</span> IsBigEndian2()
{
    <span class="hljs-keyword">union</span> NUM
    {
        <span class="hljs-keyword">int</span> a;
        <span class="hljs-built_in">char</span> b;
    }num;
    num.a = <span class="hljs-number">0</span>x1234;
    <span class="hljs-keyword">if</span> (num.b == <span class="hljs-number">0</span>x12)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
}</code></pre>

<p>参考： <br>
<a href="http://www.cnblogs.com/jiayouwyhit/p/3324448.html">http://www.cnblogs.com/jiayouwyhit/p/3324448.html</a> <br>
<a href="http://blog.csdn.net/dezhihuang/article/details/44150653">http://blog.csdn.net/dezhihuang/article/details/44150653</a> <br>
<a href="http://blog.csdn.net/ce123_zhouwei/article/details/6971544">http://blog.csdn.net/ce123_zhouwei/article/details/6971544</a></p>                    <div>
                        作者：daaikuaichuan 发表于 2017/12/01 19:07:21 <a href="http://blog.csdn.net/daaikuaichuan/article/details/78690185">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/78690185                    </div>
                    <div>
                        阅读：53                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
                    <item>
                                <title><![CDATA[[原]LATEX常用语法]]></title>
                <link>http://blog.csdn.net/daaikuaichuan/article/details/78626125</link>
                <guid>http://blog.csdn.net/daaikuaichuan/article/details/78626125</guid>
                <author>daaikuaichuan</author>
                <pubDate>2017/11/24 16:42:40</pubDate>
                <description>
                    <![CDATA[
                    <p><font size="5">1、多行公式编辑，编号居中：</font></p>



<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\begin</span><span class="hljs-special">{</span>equation<span class="hljs-special">}</span><span class="hljs-command">\label</span><span class="hljs-special">{</span>eqn:1<span class="hljs-special">}</span>
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>split<span class="hljs-special">}</span>
<span class="hljs-command">\min</span>_<span class="hljs-special">{</span><span class="hljs-command">\substack</span><span class="hljs-special">{</span>X<span class="hljs-special">}</span><span class="hljs-special">}</span> loss(X)+<span class="hljs-command">\alpha</span> R(X),
<span class="hljs-command">\end</span><span class="hljs-special">{</span>split<span class="hljs-special">}</span>
<span class="hljs-command">\end</span><span class="hljs-special">{</span>equation<span class="hljs-special">}</span>

<span class="hljs-command">\begin</span><span class="hljs-special">{</span>equation<span class="hljs-special">}</span>
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>split<span class="hljs-special">}</span>
<span class="hljs-special">&amp;</span><span class="hljs-command">\min</span>_<span class="hljs-special">{</span><span class="hljs-command">\substack</span><span class="hljs-special">{</span><span class="hljs-command">\beta</span><span class="hljs-special">}</span><span class="hljs-special">}</span> <span class="hljs-command">\|</span><span class="hljs-command">\beta</span><span class="hljs-command">\|</span>_0 <span class="hljs-command">\\</span> 
<span class="hljs-special">&amp;</span>s.t. X <span class="hljs-command">\beta</span> = y <span class="hljs-command">\label</span><span class="hljs-special">{</span>eq2<span class="hljs-special">}</span>.
<span class="hljs-command">\end</span><span class="hljs-special">{</span>split<span class="hljs-special">}</span>
<span class="hljs-command">\end</span><span class="hljs-special">{</span>equation<span class="hljs-special">}</span></code></pre>

<p><font size="5">2、范数：</font></p>

<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\|</span><span class="hljs-command">\beta</span><span class="hljs-command">\|</span>_1：β-1范数。</code></pre>

<p><font size="5">3、上标和下标：</font></p>



<pre class="prettyprint"><code class=" hljs tex">R^<span class="hljs-special">{</span>n <span class="hljs-command">\times</span> m<span class="hljs-special">}</span>：上标。
<span class="hljs-command">\|</span><span class="hljs-command">\beta</span><span class="hljs-command">\|</span>_1：下标。</code></pre>

<p><font size="5">4、论文句子间插入公式或者表达式</font></p>



<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$n</span> \ll m<span class="hljs-variable">$:</span>n &lt;&lt; m。</code></pre>

<p><font size="5">5、公式的引用：</font></p>



<pre class="prettyprint"><code class=" hljs mathematica">\label<span class="hljs-list">{eq3}</span>
(\ref<span class="hljs-list">{eq3}</span>)</code></pre>

<p><font size="5">6、在运算符下添加表达式：</font></p>



<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\begin</span><span class="hljs-special">{</span>equation<span class="hljs-special">}</span>   
<span class="hljs-command">\sum</span>_<span class="hljs-special">{</span><span class="hljs-command">\substack</span><span class="hljs-special">{</span>k_0,k_1,<span class="hljs-command">\dots</span>&gt;0 <span class="hljs-command">\\</span> k_0+k_1+<span class="hljs-command">\dots</span>=n<span class="hljs-special">}</span><span class="hljs-special">}</span> F(k_i)
<span class="hljs-command">\end</span><span class="hljs-special">{</span>equation<span class="hljs-special">}</span></code></pre>

<p><font size="5">7、表格:</font></p>



<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\begin</span><span class="hljs-special">{</span>table<span class="hljs-special">}</span><span class="hljs-special">[</span>htbp<span class="hljs-special">]</span>
<span class="hljs-command">\caption</span><span class="hljs-special">{</span>Table Type Styles<span class="hljs-special">}</span>
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>center<span class="hljs-special">}</span>
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>tabular<span class="hljs-special">}</span><span class="hljs-special">{</span>|c|c|c|c|<span class="hljs-special">}</span>
<span class="hljs-command">\hline</span>
<span class="hljs-command">\textbf</span><span class="hljs-special">{</span>Table<span class="hljs-special">}</span><span class="hljs-special">&amp;</span><span class="hljs-command">\multicolumn</span><span class="hljs-special">{</span>3<span class="hljs-special">}</span><span class="hljs-special">{</span>|c|<span class="hljs-special">}</span><span class="hljs-special">{</span><span class="hljs-command">\textbf</span><span class="hljs-special">{</span>Table Column Head<span class="hljs-special">}</span><span class="hljs-special">}</span> <span class="hljs-command">\\</span>
<span class="hljs-command">\cline</span><span class="hljs-special">{</span>2-4<span class="hljs-special">}</span>
<span class="hljs-command">\textbf</span><span class="hljs-special">{</span>Head<span class="hljs-special">}</span> <span class="hljs-special">&amp;</span> <span class="hljs-command">\textbf</span><span class="hljs-special">{</span><span class="hljs-command">\textit</span><span class="hljs-special">{</span>Table column subhead<span class="hljs-special">}</span><span class="hljs-special">}</span><span class="hljs-special">&amp;</span> <span class="hljs-command">\textbf</span><span class="hljs-special">{</span><span class="hljs-command">\textit</span><span class="hljs-special">{</span>Subhead<span class="hljs-special">}</span><span class="hljs-special">}</span><span class="hljs-special">&amp;</span> <span class="hljs-command">\textbf</span><span class="hljs-special">{</span><span class="hljs-command">\textit</span><span class="hljs-special">{</span>Subhead<span class="hljs-special">}</span><span class="hljs-special">}</span> <span class="hljs-command">\\</span>
<span class="hljs-command">\hline</span>
copy<span class="hljs-special">&amp;</span> More table copy<span class="hljs-formula">$^<span class="hljs-special">{</span><span class="hljs-command">\mathrm</span><span class="hljs-special">{</span>a<span class="hljs-special">}</span><span class="hljs-special">}</span>$</span><span class="hljs-special">&amp;</span> <span class="hljs-special">&amp;</span>  <span class="hljs-command">\\</span>
<span class="hljs-command">\hline</span>
<span class="hljs-command">\multicolumn</span><span class="hljs-special">{</span>4<span class="hljs-special">}</span><span class="hljs-special">{</span>l<span class="hljs-special">}</span><span class="hljs-special">{</span><span class="hljs-formula">$^<span class="hljs-special">{</span><span class="hljs-command">\mathrm</span><span class="hljs-special">{</span>a<span class="hljs-special">}</span><span class="hljs-special">}</span>$</span>Sample of a Table footnote.<span class="hljs-special">}</span>
<span class="hljs-command">\end</span><span class="hljs-special">{</span>tabular<span class="hljs-special">}</span>
<span class="hljs-command">\label</span><span class="hljs-special">{</span>tab1<span class="hljs-special">}</span>
<span class="hljs-command">\end</span><span class="hljs-special">{</span>center<span class="hljs-special">}</span>
<span class="hljs-command">\end</span><span class="hljs-special">{</span>table<span class="hljs-special">}</span></code></pre>

<p><font size="5">8、插入图片:</font></p>



<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\begin</span><span class="hljs-special">{</span>figure<span class="hljs-special">}</span><span class="hljs-special">[</span>htbp<span class="hljs-special">]</span>
<span class="hljs-command">\centerline</span><span class="hljs-special">{</span><span class="hljs-command">\includegraphics</span><span class="hljs-special">{</span>fig1.png<span class="hljs-special">}</span><span class="hljs-special">}</span>
<span class="hljs-command">\caption</span><span class="hljs-special">{</span>Example of a figure caption.<span class="hljs-special">}</span>
<span class="hljs-command">\label</span><span class="hljs-special">{</span>fig<span class="hljs-special">}</span>
<span class="hljs-command">\end</span><span class="hljs-special">{</span>figure<span class="hljs-special">}</span></code></pre>

<p><font size="5">9、在指定位置插入图片（有时候图片会在最上方）：</font></p>



<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\usepackage</span><span class="hljs-special">{</span>float<span class="hljs-special">}</span>
<span class="hljs-command">\usepackage</span><span class="hljs-special">{</span>graphix<span class="hljs-special">}</span>
<span class="hljs-command">\begin</span> <span class="hljs-special">{</span>figure<span class="hljs-special">}</span><span class="hljs-special">[</span>H<span class="hljs-special">]</span>
<span class="hljs-command">\centering</span>
<span class="hljs-command">\includegraphics</span><span class="hljs-special">[</span>width=7cm<span class="hljs-special">]</span><span class="hljs-special">{</span>endpoint.eps<span class="hljs-special">}</span>
<span class="hljs-command">\caption</span><span class="hljs-special">{</span>Endpoint detection<span class="hljs-special">}</span>
<span class="hljs-command">\end</span> <span class="hljs-special">{</span>figure<span class="hljs-special">}</span></code></pre>

<p><font size="5">10、列表:</font></p>



<pre class="prettyprint"><code class=" hljs tex">（无序）：
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>itemize<span class="hljs-special">}</span>
<span class="hljs-command">\item</span> 
<span class="hljs-command">\item</span> 
<span class="hljs-command">\item</span> 
<span class="hljs-command">\end</span><span class="hljs-special">{</span>itemize<span class="hljs-special">}</span>
（有序）：
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>enumerate<span class="hljs-special">}</span>
  <span class="hljs-command">\item</span> javascript
  <span class="hljs-command">\item</span> html
  <span class="hljs-command">\item</span> css
<span class="hljs-command">\end</span><span class="hljs-special">{</span>enumerate<span class="hljs-special">}</span>
</code></pre>

<p><font size="5">11、居中:</font></p>



<pre class="prettyprint"><code class=" hljs tex">（1）<span class="hljs-command">\begin</span><span class="hljs-special">{</span>center<span class="hljs-special">}</span>
	  pid = fork()
    <span class="hljs-command">\end</span><span class="hljs-special">{</span>center<span class="hljs-special">}</span>
（2）<span class="hljs-command">\centering</span></code></pre>

<p><font size="5">12、换行与换页：</font></p>



<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\par</span>：用在需要换行的内容前面，将之后的内容进行换行操作。
<span class="hljs-command">\\</span>：用在每一行的末尾，之后的内容便会出现在新的一行。
<span class="hljs-command">\newpage</span>：换页。</code></pre>

<p><font size="5">13、分式：</font></p>



<pre class="prettyprint"><code class=" hljs css">\<span class="hljs-tag">frac</span><span class="hljs-rules">{<span class="hljs-rule">1}</span></span><span class="hljs-rules">{<span class="hljs-rule">2</span></span></code></pre>

<p><font size="5">14、各种求和：</font></p>



<pre class="prettyprint"><code class=" hljs tex">（1）上下位置，独立公式情形：
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>equation*<span class="hljs-special">}</span>
p = <span class="hljs-command">\sum</span>_<span class="hljs-special">{</span>n=1<span class="hljs-special">}</span>^Na_n
<span class="hljs-command">\end</span><span class="hljs-special">{</span>equation*<span class="hljs-special">}</span>
（2）行间公式情形：
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>equation*<span class="hljs-special">}</span>
p = <span class="hljs-command">\sum</span>_<span class="hljs-special">{</span>n=1<span class="hljs-special">}</span>^Na_n
<span class="hljs-command">\end</span><span class="hljs-special">{</span>equation*<span class="hljs-special">}</span>

通过<span class="hljs-command">\limits</span> 与 <span class="hljs-command">\nolimits</span>可以改变缺省值。其中行间公式缺省使用<span class="hljs-command">\nolimits</span> 而独立公式缺省使用<span class="hljs-command">\limits</span>。如果要改变缺省规则，就要在符号后面、上下限之前加入上面的两个命令。
（3）
比如在独立公式前加<span class="hljs-command">\nolimits</span>限制，如下所示：
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>equation*<span class="hljs-special">}</span>
p = <span class="hljs-command">\sum</span><span class="hljs-command">\nolimits</span>_<span class="hljs-special">{</span>n=1<span class="hljs-special">}</span>^Na_n
<span class="hljs-command">\end</span><span class="hljs-special">{</span>equation*<span class="hljs-special">}</span>

（4）在行间前加<span class="hljs-command">\limits</span>限制，如下所示:
<span class="hljs-formula">$p = <span class="hljs-command">\sum</span><span class="hljs-command">\limits</span>_<span class="hljs-special">{</span>n=1<span class="hljs-special">}</span>^Na_n$</span></code></pre>

<p><font size="5">15、伪代码流程图：</font></p>



<pre class="prettyprint"><code class=" hljs tex"><span class="hljs-command">\begin</span><span class="hljs-special">{</span>algorithm<span class="hljs-special">}</span><span class="hljs-special">[</span>h<span class="hljs-special">]</span>
<span class="hljs-command">\renewcommand</span><span class="hljs-special">{</span><span class="hljs-command">\algorithmicrequire</span><span class="hljs-special">}</span><span class="hljs-special">{</span><span class="hljs-command">\textbf</span><span class="hljs-special">{</span>Input:<span class="hljs-special">}</span><span class="hljs-special">}</span>
<span class="hljs-command">\renewcommand</span><span class="hljs-command">\algorithmicensure</span> <span class="hljs-special">{</span><span class="hljs-command">\textbf</span><span class="hljs-special">{</span>Output:<span class="hljs-special">}</span> <span class="hljs-special">}</span>  
<span class="hljs-command">\caption</span><span class="hljs-special">{</span>Multiplicative Update Rule for NMF<span class="hljs-special">}</span>
<span class="hljs-command">\label</span><span class="hljs-special">{</span>alg::NMF<span class="hljs-special">}</span>
<span class="hljs-command">\begin</span><span class="hljs-special">{</span>algorithmic<span class="hljs-special">}</span><span class="hljs-special">[</span>1<span class="hljs-special">]</span>
<span class="hljs-command">\REQUIRE</span> 
  <span class="hljs-formula">$V$</span>: decomposed matrix;
  <span class="hljs-formula">$MaxIter$</span>: the number of iterations;
<span class="hljs-command">\ENSURE</span> 
  <span class="hljs-formula">$W,H$</span>
<span class="hljs-command">\STATE</span> initial W and H non negative;
<span class="hljs-command">\FOR</span><span class="hljs-special">{</span><span class="hljs-formula">$i=1:MaxIter$</span><span class="hljs-special">}</span>
  <span class="hljs-command">\STATE</span> Update row elements of the H matrix <span class="hljs-formula">$H_<span class="hljs-special">{</span><span class="hljs-special">[</span>i,j<span class="hljs-special">]</span><span class="hljs-special">}</span> <span class="hljs-command">\leftarrow</span> H_<span class="hljs-special">{</span><span class="hljs-special">[</span>i,j<span class="hljs-special">]</span><span class="hljs-special">}</span><span class="hljs-command">\frac</span><span class="hljs-special">{</span>(W^TV)_<span class="hljs-special">{</span><span class="hljs-special">[</span>i,j<span class="hljs-special">]</span><span class="hljs-special">}</span><span class="hljs-special">}</span><span class="hljs-special">{</span>(W^TWH)_<span class="hljs-special">{</span><span class="hljs-special">[</span>i,j<span class="hljs-special">]</span><span class="hljs-special">}</span><span class="hljs-special">}</span>$</span>;
  <span class="hljs-command">\STATE</span> Update column elements of the W matrix <span class="hljs-formula">$W_<span class="hljs-special">{</span><span class="hljs-special">[</span>i,j<span class="hljs-special">]</span><span class="hljs-special">}</span> <span class="hljs-command">\leftarrow</span> W_<span class="hljs-special">{</span><span class="hljs-special">[</span>i,j<span class="hljs-special">]</span><span class="hljs-special">}</span><span class="hljs-command">\frac</span><span class="hljs-special">{</span>(VH^T)_<span class="hljs-special">{</span><span class="hljs-special">[</span>i,j<span class="hljs-special">]</span><span class="hljs-special">}</span><span class="hljs-special">}</span><span class="hljs-special">{</span>(WHH^T)_<span class="hljs-special">{</span><span class="hljs-special">[</span>i,j<span class="hljs-special">]</span><span class="hljs-special">}</span><span class="hljs-special">}</span>$</span>;
  <span class="hljs-command">\IF</span> <span class="hljs-special">{</span> W and H are stable<span class="hljs-special">}</span>  
  <span class="hljs-command">\STATE</span> <span class="hljs-formula">$end$</span>;
  <span class="hljs-command">\ENDIF</span>
<span class="hljs-command">\ENDFOR</span>
<span class="hljs-command">\end</span><span class="hljs-special">{</span>algorithmic<span class="hljs-special">}</span>
<span class="hljs-command">\end</span><span class="hljs-special">{</span>algorithm<span class="hljs-special">}</span>  </code></pre>

<p><font size="5">16、把下标放置到正下方：</font></p>



<pre class="prettyprint"><code class=" hljs tex">如果是数学符号，那么直接用<span class="hljs-command">\limits</span>命令放在正下方，如：
<span class="hljs-formula">$ <span class="hljs-command">\sum</span><span class="hljs-command">\limits</span>_<span class="hljs-special">{</span>i=1<span class="hljs-special">}</span> $</span>
若是普通符号，那么要用<span class="hljs-command">\mathop</span>先转成数学符号再用<span class="hljs-command">\limits</span>，如：
<span class="hljs-formula">$ <span class="hljs-command">\mathop</span><span class="hljs-special">{</span>a<span class="hljs-special">}</span><span class="hljs-command">\limits</span>_<span class="hljs-special">{</span>i=1<span class="hljs-special">}</span> $</span></code></pre>                    <div>
                        作者：daaikuaichuan 发表于 2017/11/24 16:42:40 <a href="http://blog.csdn.net/daaikuaichuan/article/details/78626125">原文链接</a> http://blog.csdn.net/daaikuaichuan/article/details/78626125                    </div>
                    <div>
                        阅读：111                     </div>
                    ]]>
                </description>
                <category></category>
            </item>
            </channel>
</rss>
